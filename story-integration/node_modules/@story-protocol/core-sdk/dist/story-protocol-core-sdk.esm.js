import { isAddress, checksumAddress, formatEther, encodeFunctionData, decodeEventLog, zeroAddress, toFunctionSelector, keccak256, encodeAbiParameters, zeroHash, maxUint256, toHex, stringToHex, erc20Abi, maxUint32, createPublicClient, createWalletClient } from 'viem';
import * as dotenv from 'dotenv';
import { defineChain } from 'viem/utils';
import { CID } from 'multiformats/cid';
import bs58 from 'bs58';
import { base58btc } from 'multiformats/bases/base58';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

function toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var aeneid = defineChain({
  id: 1315,
  name: "aeneid",
  nativeCurrency: {
    name: "IP",
    symbol: "IP",
    decimals: 18
  },
  rpcUrls: {
    "default": {
      http: ["https://aeneid.storyrpc.io/"]
    }
  },
  blockExplorers: {
    "default": {
      name: "Explorer",
      url: "https://aeneid.storyscan.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5882
    }
  },
  testnet: true
});
var mainnet = defineChain({
  id: 1514,
  name: "mainnet",
  nativeCurrency: {
    name: "IP",
    symbol: "IP",
    decimals: 18
  },
  rpcUrls: {
    "default": {
      http: ["https://mainnet.storyrpc.io/"]
    }
  },
  blockExplorers: {
    "default": {
      name: "Explorer",
      url: "https://dev-mainnet.storyscan.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5882
    }
  },
  testnet: false
});

function chainStringToViemChain(chainId) {
  switch (chainId.toString()) {
    case "1315":
    case "aeneid":
      return aeneid;
    case "1514":
    case "mainnet":
      return mainnet;
    default:
      throw new Error("ChainId ".concat(chainId, " not supported"));
  }
}
var chain = {
  aeneid: "1315",
  1315: "1315",
  1514: "1514",
  mainnet: "1514"
};
function validateAddress(address) {
  if (!isAddress(address, {
    strict: false
  })) {
    throw Error("Invalid address: ".concat(address));
  }
  return address;
}
function validateAddresses(addresses) {
  return addresses.map(function (address) {
    return validateAddress(address);
  });
}

/** @deprecated use {@link validateAddress} */
var getAddress$1 = function getAddress(address, name, chainId) {
  if (!isAddress(address, {
    strict: false
  })) {
    throw Error("".concat(name, " address is invalid: ").concat(address, ", Address must be a hex value of 20 bytes (40 hex characters) and match its checksum counterpart."));
  }
  return checksumAddress(address, chainId);
};
function getTokenAmountDisplay(amount) {
  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "IP";
  return "".concat(formatEther(amount)).concat(unit);
}

function handleError(error, msg) {
  if (error instanceof Error) {
    var newError = new Error("".concat(msg, ": ").concat(error.message));
    newError.stack = error.stack;
    throw newError;
  }
  throw new Error("".concat(msg, ": Unknown error type"));
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

// AccessController
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var accessControllerAbi=[{type:"constructor",inputs:[{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"}],name:"AccessController__BothCallerAndRecipientAreNotRegisteredModule"},{type:"error",inputs:[],name:"AccessController__CallerIsNotIPAccountOrOwner"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessController__IPAccountIsNotValid"},{type:"error",inputs:[],name:"AccessController__IPAccountIsZeroAddress"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"AccessController__PermissionDenied"},{type:"error",inputs:[],name:"AccessController__PermissionIsNotValid"},{type:"error",inputs:[],name:"AccessController__SignerIsZeroAddress"},{type:"error",inputs:[],name:"AccessController__ToAndFuncAreZeroAddressShouldCallSetAllPermissions"},{type:"error",inputs:[],name:"AccessController__ZeroAccessManager"},{type:"error",inputs:[],name:"AccessController__ZeroIPAccountRegistry"},{type:"error",inputs:[],name:"AccessController__ZeroModuleRegistry"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"ipAccountOwner",internalType:"address",type:"address",indexed:false},{name:"ipAccount",internalType:"address",type:"address",indexed:true},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"func",internalType:"bytes4",type:"bytes4",indexed:false},{name:"permission",internalType:"uint8",type:"uint8",indexed:false}],name:"PermissionSet"},{type:"event",anonymous:false,inputs:[{name:"ipAccountOwner",internalType:"address",type:"address",indexed:false},{name:"ipAccount",internalType:"address",type:"address",indexed:true},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"func",internalType:"bytes4",type:"bytes4",indexed:false},{name:"permission",internalType:"uint8",type:"uint8",indexed:false}],name:"TransientPermissionSet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"checkPermission",outputs:[],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getPermanentPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getTransientPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setAllPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setAllTransientPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"permissions",internalType:"struct AccessPermission.Permission[]",type:"tuple[]",components:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}]}],name:"setBatchPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"permissions",internalType:"struct AccessPermission.Permission[]",type:"tuple[]",components:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}]}],name:"setBatchTransientPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setPermission",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setTransientPermission",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var accessControllerAddress={1315:"0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a",1514:"0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a"};// ArbitrationPolicyUMA
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var arbitrationPolicyUmaAbi=[{type:"constructor",inputs:[{name:"disputeModule",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__BondAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CannotCancel"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CannotDisputeAssertionIfTagIsInherited"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CurrencyNotWhitelisted"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__DisputeNotFound"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__IpOwnerTimePercentAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__LivenessAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__LivenessBelowMin"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__MaxBondBelowMinimumBond"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__MinLivenessAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NoCounterEvidence"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NotDisputeModule"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NotOOV3"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__OnlyDisputePolicyUMA"},{type:"error",inputs:[{name:"elapsedTime",internalType:"uint64",type:"uint64"},{name:"liveness",internalType:"uint64",type:"uint64"},{name:"caller",internalType:"address",type:"address"}],name:"ArbitrationPolicyUMA__OnlyTargetIpIdCanDisputeWithinTimeWindow"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroAccessManager"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroDisputeModule"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroMaxLiveness"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroMinLiveness"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroOOV3"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroRoyaltyModule"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32",indexed:false},{name:"counterEvidenceHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"AssertionDisputed"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"caller",internalType:"address",type:"address",indexed:false},{name:"liveness",internalType:"uint64",type:"uint64",indexed:false},{name:"currency",internalType:"address",type:"address",indexed:false},{name:"bond",internalType:"uint256",type:"uint256",indexed:false}],name:"DisputeRaisedUMA"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"minLiveness",internalType:"uint64",type:"uint64",indexed:false},{name:"maxLiveness",internalType:"uint64",type:"uint64",indexed:false},{name:"ipOwnerTimePercent",internalType:"uint32",type:"uint32",indexed:false}],name:"LivenessSet"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"maxBond",internalType:"uint256",type:"uint256",indexed:false}],name:"MaxBondSet"},{type:"event",anonymous:false,inputs:[{name:"oov3",internalType:"address",type:"address",indexed:false}],name:"OOV3Set"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"}],name:"assertionDisputedCallback",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"}],name:"assertionIdToDisputeId",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"},{name:"assertedTruthfully",internalType:"bool",type:"bool"}],name:"assertionResolvedCallback",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"},{name:"counterEvidenceHash",internalType:"bytes32",type:"bytes32"}],name:"disputeAssertion",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"disputeIdToAssertionId",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipOwnerTimePercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"ipOwnerTimePercents",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"maxBonds",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxLiveness",outputs:[{name:"",internalType:"uint64",type:"uint64"}],stateMutability:"view"},{type:"function",inputs:[],name:"minLiveness",outputs:[{name:"",internalType:"uint64",type:"uint64"}],stateMutability:"view"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onDisputeCancel",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"decision",internalType:"bool",type:"bool"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onDisputeJudgement",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onRaiseDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onResolveDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"oov3",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"minLiveness",internalType:"uint64",type:"uint64"},{name:"maxLiveness",internalType:"uint64",type:"uint64"},{name:"ipOwnerTimePercent",internalType:"uint32",type:"uint32"}],name:"setLiveness",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"maxBond",internalType:"uint256",type:"uint256"}],name:"setMaxBond",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"oov3",internalType:"address",type:"address"}],name:"setOOV3",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var arbitrationPolicyUmaAddress={1315:"0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936",1514:"0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936"};// CoreMetadataModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var coreMetadataModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"CoreMetadataModule__MetadataAlreadyFrozen"},{type:"error",inputs:[],name:"CoreMetadataModule__ZeroAccessManager"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true}],name:"MetadataFrozen"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"metadataURI",internalType:"string",type:"string",indexed:false},{name:"metadataHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"MetadataURISet"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"nftTokenURI",internalType:"string",type:"string",indexed:false},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"NFTTokenURISet"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"freezeMetadata",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isMetadataFrozen",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"metadataURI",internalType:"string",type:"string"},{name:"metadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"setAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"metadataURI",internalType:"string",type:"string"},{name:"metadataHash",internalType:"bytes32",type:"bytes32"}],name:"setMetadataURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"updateNftTokenURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var coreMetadataModuleAddress={1315:"0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16",1514:"0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16"};// DerivativeWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var derivativeWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"caller",internalType:"address",type:"address"},{name:"actualTokenOwner",internalType:"address",type:"address"}],name:"DerivativeWorkflows__CallerAndNotTokenOwner"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"DerivativeWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"DerivativeWorkflows__EmptyLicenseTokens"},{type:"error",inputs:[],name:"DerivativeWorkflows__ZeroAddressParam"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_TOKEN",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"recipient",internalType:"address",type:"address"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivative",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"recipient",internalType:"address",type:"address"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"recipient",internalType:"address",type:"address"}],name:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivativeDEPR",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"recipient",internalType:"address",type:"address"}],name:"mintAndRegisterIpAndMakeDerivative_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivative",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivativeWithLicenseTokens",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadata",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivativeWithLicenseTokens_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivativeDEPR",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadata",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivative_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var derivativeWorkflowsAddress={1315:"0x9e2d496f72C547C2C535B167e06ED8729B374a4f",1514:"0x9e2d496f72C547C2C535B167e06ED8729B374a4f"};// DisputeModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var disputeModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"DisputeModule__CannotBlacklistBaseArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__DisputeAlreadyPropagated"},{type:"error",inputs:[],name:"DisputeModule__DisputeWithoutInfringementTag"},{type:"error",inputs:[],name:"DisputeModule__EvidenceHashAlreadyUsed"},{type:"error",inputs:[],name:"DisputeModule__NotAbleToResolve"},{type:"error",inputs:[],name:"DisputeModule__NotAllowedToWhitelist"},{type:"error",inputs:[],name:"DisputeModule__NotArbitrationRelayer"},{type:"error",inputs:[],name:"DisputeModule__NotDerivativeOrGroupIp"},{type:"error",inputs:[],name:"DisputeModule__NotDisputeInitiator"},{type:"error",inputs:[],name:"DisputeModule__NotInDisputeState"},{type:"error",inputs:[],name:"DisputeModule__NotRegisteredIpId"},{type:"error",inputs:[],name:"DisputeModule__NotWhitelistedArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__NotWhitelistedDisputeTag"},{type:"error",inputs:[],name:"DisputeModule__RelatedDisputeNotResolved"},{type:"error",inputs:[],name:"DisputeModule__ZeroAccessController"},{type:"error",inputs:[],name:"DisputeModule__ZeroAccessManager"},{type:"error",inputs:[],name:"DisputeModule__ZeroArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__ZeroArbitrationPolicyCooldown"},{type:"error",inputs:[],name:"DisputeModule__ZeroDisputeEvidenceHash"},{type:"error",inputs:[],name:"DisputeModule__ZeroDisputeTag"},{type:"error",inputs:[],name:"DisputeModule__ZeroIPAssetRegistry"},{type:"error",inputs:[],name:"DisputeModule__ZeroIPGraphACL"},{type:"error",inputs:[],name:"DisputeModule__ZeroLicenseRegistry"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"cooldown",internalType:"uint256",type:"uint256",indexed:false}],name:"ArbitrationPolicyCooldownUpdated"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"nextArbitrationUpdateTimestamp",internalType:"uint256",type:"uint256",indexed:false}],name:"ArbitrationPolicySet"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"ArbitrationPolicyWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"arbitrationRelayer",internalType:"address",type:"address",indexed:false}],name:"ArbitrationRelayerUpdated"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false}],name:"DefaultArbitrationPolicyUpdated"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeCancelled"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"decision",internalType:"bool",type:"bool",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeJudgementSet"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"targetIpId",internalType:"address",type:"address",indexed:false},{name:"disputeInitiator",internalType:"address",type:"address",indexed:false},{name:"disputeTimestamp",internalType:"uint256",type:"uint256",indexed:false},{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32",indexed:false},{name:"targetTag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeRaised"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeResolved"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"infringingIpId",internalType:"address",type:"address",indexed:false},{name:"ipIdToTag",internalType:"address",type:"address",indexed:false},{name:"infringerDisputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"tag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"disputeTimestamp",internalType:"uint256",type:"uint256",indexed:false}],name:"IpTaggedOnRelatedIpInfringement"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"tag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"TagWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IN_DISPUTE",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"arbitrationPolicies",outputs:[{name:"policy",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"arbitrationPolicyCooldown",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"arbitrationRelayer",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"baseArbitrationPolicy",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"cancelDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"disputeCounter",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"disputes",outputs:[{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeInitiator",internalType:"address",type:"address"},{name:"disputeTimestamp",internalType:"uint256",type:"uint256"},{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"currentTag",internalType:"bytes32",type:"bytes32"},{name:"infringerDisputeId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isIpTagged",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"isWhitelistedArbitrationPolicy",outputs:[{name:"allowed",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"tag",internalType:"bytes32",type:"bytes32"}],name:"isWhitelistedDisputeTag",outputs:[{name:"allowed",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"nextArbitrationPolicies",outputs:[{name:"policy",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"nextArbitrationUpdateTimestamps",outputs:[{name:"timestamp",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"data",internalType:"bytes",type:"bytes"}],name:"raiseDispute",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"resolveDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"nextArbitrationPolicy",internalType:"address",type:"address"}],name:"setArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"cooldown",internalType:"uint256",type:"uint256"}],name:"setArbitrationPolicyCooldown",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"arbPolicyRelayer",internalType:"address",type:"address"}],name:"setArbitrationRelayer",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"setBaseArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"decision",internalType:"bool",type:"bool"},{name:"data",internalType:"bytes",type:"bytes"}],name:"setDisputeJudgement",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipIdToTag",internalType:"address",type:"address"},{name:"infringerDisputeId",internalType:"uint256",type:"uint256"}],name:"tagIfRelatedIpInfringed",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"updateActiveArbitrationPolicy",outputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"tag",internalType:"bytes32",type:"bytes32"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistDisputeTag",outputs:[],stateMutability:"nonpayable"}];/**

*/var disputeModuleAddress={1315:"0x9b7A9c70AFF961C799110954fc06F3093aeb94C5",1514:"0x9b7A9c70AFF961C799110954fc06F3093aeb94C5"};// GroupingModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var groupingModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"groupNFT",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"GroupingModule__CannotAddDisputedIpToGroup"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"childGroupId",internalType:"address",type:"address"}],name:"GroupingModule__CannotAddGroupToGroup"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotAddIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotClaimReward"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotCollectRoyalties"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupFrozenDueToAlreadyMintLicenseTokens"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupFrozenDueToHasDerivativeIps"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupIPHasNoLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupIPLicenseHasNotSpecifyRevenueToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"}],name:"GroupingModule__GroupRewardPoolNotWhitelisted"},{type:"error",inputs:[{name:"groupNFT",internalType:"address",type:"address"}],name:"GroupingModule__InvalidGroupNFT"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"expectGroupRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__IpExpectedShareExceedsMaxAllowedShare"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__MaxAllowedRewardShareExceeds100Percent"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"royaltyToken",internalType:"address",type:"address"}],name:"GroupingModule__RoyaltyTokenNotWhitelisted"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupCurrentToken",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"GroupingModule__TokenNotMatchGroupRevenueToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"totalGroupRewardShare",internalType:"uint256",type:"uint256"},{name:"ipId",internalType:"address",type:"address"},{name:"expectGroupRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__TotalGroupRewardShareExceeds100Percent"},{type:"error",inputs:[],name:"GroupingModule__ZeroAccessManager"},{type:"error",inputs:[],name:"GroupingModule__ZeroGroupNFT"},{type:"error",inputs:[],name:"GroupingModule__ZeroGroupRewardPool"},{type:"error",inputs:[],name:"GroupingModule__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"GroupingModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"GroupingModule__ZeroLicenseToken"},{type:"error",inputs:[],name:"GroupingModule__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"ipIds",internalType:"address[]",type:"address[]",indexed:false}],name:"AddedIpToGroup"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"token",internalType:"address",type:"address",indexed:true},{name:"ipId",internalType:"address[]",type:"address[]",indexed:false},{name:"amount",internalType:"uint256[]",type:"uint256[]",indexed:false}],name:"ClaimedReward"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"token",internalType:"address",type:"address",indexed:true},{name:"pool",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"CollectedRoyaltiesToGroupPool"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"groupPool",internalType:"address",type:"address",indexed:true}],name:"IPGroupRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"ipIds",internalType:"address[]",type:"address[]",indexed:false}],name:"RemovedIpFromGroup"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_NFT",outputs:[{name:"",internalType:"contract IGroupNFT",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_TOKEN",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"}],name:"addIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"claimReward",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"collectRoyalties",outputs:[{name:"royalties",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"getClaimableReward",outputs:[{name:"",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"}],name:"registerGroup",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"removeIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistGroupRewardPool",outputs:[],stateMutability:"nonpayable"}];/**

*/var groupingModuleAddress={1315:"0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac",1514:"0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac"};// GroupingWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var groupingWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"},{name:"groupNft",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"GroupingWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"GroupingWorkflows__NoLicenseData"},{type:"error",inputs:[],name:"GroupingWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"contract IGroupingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_NFT",outputs:[{name:"",internalType:"contract GroupNFT",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract RoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"currencyTokens",internalType:"address[]",type:"address[]"},{name:"memberIpIds",internalType:"address[]",type:"address[]"}],name:"collectRoyaltiesAndClaimReward",outputs:[{name:"collectedRoyalties",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"currencyTokens",internalType:"address[]",type:"address[]"},{name:"groupSnapshotIds",internalType:"uint256[]",type:"uint256[]"},{name:"memberIpIds",internalType:"address[]",type:"address[]"}],name:"collectRoyaltiesAndClaimReward_deprecated",outputs:[{name:"collectedRoyalties",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licensesData",internalType:"struct WorkflowStructs.LicenseData[]",type:"tuple[]",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigAddToGroup",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigAddToGroup",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"mintAndRegisterIpAndAttachLicenseAndAddToGroup_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"},{name:"licenseData",internalType:"struct WorkflowStructs.LicenseData",type:"tuple",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]}],name:"registerGroupAndAttachLicense",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licenseData",internalType:"struct WorkflowStructs.LicenseData",type:"tuple",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]}],name:"registerGroupAndAttachLicenseAndAddIps",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"registerGroupAndAttachLicenseAndAddIps_deprecated",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"registerGroupAndAttachLicense_deprecated",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"groupId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licensesData",internalType:"struct WorkflowStructs.LicenseData[]",type:"tuple[]",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigAddToGroup",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachLicenseAndAddToGroup",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"groupId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigAddToGroup",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachLicenseAndAddToGroup_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var groupingWorkflowsAddress={1315:"0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd",1514:"0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd"};// IPAccountImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var ipAccountImplAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[],name:"FnSelectorNotRecognized"},{type:"error",inputs:[],name:"IPAccountStorage__InvalidBatchLengths"},{type:"error",inputs:[{name:"module",internalType:"address",type:"address"}],name:"IPAccountStorage__NotRegisteredModule"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroModuleRegistry"},{type:"error",inputs:[],name:"IPAccount__ExpiredSignature"},{type:"error",inputs:[],name:"IPAccount__InvalidCalldata"},{type:"error",inputs:[],name:"IPAccount__InvalidOperation"},{type:"error",inputs:[],name:"IPAccount__InvalidSignature"},{type:"error",inputs:[],name:"IPAccount__InvalidSigner"},{type:"error",inputs:[],name:"IPAccount__UUPSUpgradeDisabled"},{type:"error",inputs:[],name:"IPAccount__ZeroAccessController"},{type:"error",inputs:[],name:"OperationNotSupported"},{type:"error",inputs:[],name:"SelfOwnDetected"},{type:"error",inputs:[],name:"Unauthorized"},{type:"error",inputs:[],name:"UnauthorizedCallContext"},{type:"error",inputs:[],name:"UpgradeFailed"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false},{name:"nonce",internalType:"bytes32",type:"bytes32",indexed:false}],name:"Executed"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false},{name:"nonce",internalType:"bytes32",type:"bytes32",indexed:false},{name:"deadline",internalType:"uint256",type:"uint256",indexed:false},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"signature",internalType:"bytes",type:"bytes",indexed:false}],name:"ExecutedWithSig"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"fallback",stateMutability:"payable"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"",internalType:"bytes32",type:"bytes32"},{name:"",internalType:"bytes32",type:"bytes32"}],name:"bytes32Data",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"",internalType:"bytes32",type:"bytes32"},{name:"",internalType:"bytes32",type:"bytes32"}],name:"bytesData",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[],name:"eip712Domain",outputs:[{name:"fields",internalType:"bytes1",type:"bytes1"},{name:"name",internalType:"string",type:"string"},{name:"version",internalType:"string",type:"string"},{name:"chainId",internalType:"uint256",type:"uint256"},{name:"verifyingContract",internalType:"address",type:"address"},{name:"salt",internalType:"bytes32",type:"bytes32"},{name:"extensions",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"},{name:"operation",internalType:"uint8",type:"uint8"}],name:"execute",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"execute",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct ERC6551.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}]},{name:"operation",internalType:"uint8",type:"uint8"}],name:"executeBatch",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"payable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"},{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}],name:"executeWithSig",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespace",internalType:"bytes32",type:"bytes32"},{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespace",internalType:"bytes32",type:"bytes32"},{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes32",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes32",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespaces",internalType:"bytes32[]",type:"bytes32[]"},{name:"keys",internalType:"bytes32[]",type:"bytes32[]"}],name:"getBytes32Batch",outputs:[{name:"values",internalType:"bytes32[]",type:"bytes32[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespaces",internalType:"bytes32[]",type:"bytes32[]"},{name:"keys",internalType:"bytes32[]",type:"bytes32[]"}],name:"getBytesBatch",outputs:[{name:"values",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"hash",internalType:"bytes32",type:"bytes32"},{name:"signature",internalType:"bytes",type:"bytes"}],name:"isValidSignature",outputs:[{name:"result",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"isValidSigner",outputs:[{name:"result",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"isValidSigner",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"owner",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"},{name:"value",internalType:"bytes",type:"bytes"}],name:"setBytes",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"},{name:"value",internalType:"bytes32",type:"bytes32"}],name:"setBytes32",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"keys",internalType:"bytes32[]",type:"bytes32[]"},{name:"values",internalType:"bytes32[]",type:"bytes32[]"}],name:"setBytes32Batch",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"keys",internalType:"bytes32[]",type:"bytes32[]"},{name:"values",internalType:"bytes[]",type:"bytes[]"}],name:"setBytesBatch",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"state",outputs:[{name:"result",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"token",outputs:[{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"receive",stateMutability:"payable"}];/**

*/var ipAccountImplAddress={1315:"0x7343646585443F1c3F64E4F08b708788527e1C77",1514:"0x7343646585443F1c3F64E4F08b708788527e1C77"};// IPAssetRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var ipAssetRegistryAbi=[{type:"constructor",inputs:[{name:"erc6551Registry",internalType:"address",type:"address"},{name:"ipAccountImpl",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"},{name:"ipAccountImplBeacon",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__CallerIsNotGroupingModule"},{type:"error",inputs:[{name:"groupPool",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__GroupRewardPoolNotRegistered"},{type:"error",inputs:[{name:"groupSize",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"GroupIPAssetRegistry__GroupSizeExceedsLimit"},{type:"error",inputs:[{name:"rewardPool",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__InvalidGroupRewardPool"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__NotRegisteredGroupIP"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__NotRegisteredIP"},{type:"error",inputs:[{name:"pageSize",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"GroupIPAssetRegistry__PageSizeExceedsLimit"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroERC6551Registry"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroIpAccountImpl"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroIpAccountImplBeacon"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"IPAssetRegistry__InvalidToken"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"}],name:"IPAssetRegistry__UnsupportedIERC721"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"}],name:"IPAssetRegistry__UnsupportedIERC721Metadata"},{type:"error",inputs:[],name:"IPAssetRegistry__ZeroAccessManager"},{type:"error",inputs:[{name:"name",internalType:"string",type:"string"}],name:"IPAssetRegistry__ZeroAddress"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[{name:"value",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"StringsInsufficientHexLength"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:true},{name:"implementation",internalType:"address",type:"address",indexed:true},{name:"chainId",internalType:"uint256",type:"uint256",indexed:true},{name:"tokenContract",internalType:"address",type:"address",indexed:false},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"IPAccountRegistered"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"chainId",internalType:"uint256",type:"uint256",indexed:true},{name:"tokenContract",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true},{name:"name",internalType:"string",type:"string",indexed:false},{name:"uri",internalType:"string",type:"string",indexed:false},{name:"registrationDate",internalType:"uint256",type:"uint256",indexed:false}],name:"IPRegistered"},{type:"event",anonymous:false,inputs:[{name:"payer",internalType:"address",type:"address",indexed:true},{name:"treasury",internalType:"address",type:"address",indexed:true},{name:"feeToken",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint96",type:"uint96",indexed:false}],name:"IPRegistrationFeePaid"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"treasury",internalType:"address",type:"address",indexed:true},{name:"feeToken",internalType:"address",type:"address",indexed:true},{name:"feeAmount",internalType:"uint96",type:"uint96",indexed:false}],name:"RegistrationFeeSet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ERC6551_PUBLIC_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"contract IGroupingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_IMPL",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_IMPL_UPGRADEABLE_BEACON",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_SALT",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_GROUP_SIZE",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"addGroupMember",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"}],name:"containsIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"getFeeAmount",outputs:[{name:"",internalType:"uint96",type:"uint96"}],stateMutability:"view"},{type:"function",inputs:[],name:"getFeeToken",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"startIndex",internalType:"uint256",type:"uint256"},{name:"size",internalType:"uint256",type:"uint256"}],name:"getGroupMembers",outputs:[{name:"results",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"getGroupRewardPool",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getIPAccountImpl",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getTreasury",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"chainId",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ipAccount",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"chainId",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ipId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"id",internalType:"address",type:"address"}],name:"isRegistered",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"isRegisteredGroup",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"}],name:"isWhitelistedGroupRewardPool",outputs:[{name:"isWhitelisted",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"chainid",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"register",outputs:[{name:"id",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupNft",internalType:"address",type:"address"},{name:"groupNftId",internalType:"uint256",type:"uint256"},{name:"rewardPool",internalType:"address",type:"address"},{name:"registerFeePayer",internalType:"address",type:"address"}],name:"registerGroup",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"removeGroupMember",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"treasury",internalType:"address",type:"address"},{name:"feeToken",internalType:"address",type:"address"},{name:"feeAmount",internalType:"uint96",type:"uint96"}],name:"setRegistrationFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"totalMembers",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newIpAccountImpl",internalType:"address",type:"address"}],name:"upgradeIPAccountImpl",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistGroupRewardPool",outputs:[],stateMutability:"nonpayable"}];/**

*/var ipAssetRegistryAddress={1315:"0x77319B4031e6eF1250907aa00018B8B1c67a244b",1514:"0x77319B4031e6eF1250907aa00018B8B1c67a244b"};// IpRoyaltyVaultImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var ipRoyaltyVaultImplAbi=[{type:"constructor",inputs:[{name:"disputeModule",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"allowance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientAllowance"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"balance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientBalance"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC20InvalidApprover"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC20InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC20InvalidSender"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"}],name:"ERC20InvalidSpender"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"IpRoyaltyVault__EnforcedPause"},{type:"error",inputs:[],name:"IpRoyaltyVault__GroupPoolMustClaimViaGroupingModule"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"account",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"IpRoyaltyVault__InsufficientBalance"},{type:"error",inputs:[],name:"IpRoyaltyVault__InvalidTargetIpId"},{type:"error",inputs:[],name:"IpRoyaltyVault__NegativeValueUnsafeCastingToUint256"},{type:"error",inputs:[],name:"IpRoyaltyVault__NoClaimableTokens"},{type:"error",inputs:[],name:"IpRoyaltyVault__NotAllowedToAddTokenToVault"},{type:"error",inputs:[],name:"IpRoyaltyVault__NotWhitelistedRoyaltyToken"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"from",internalType:"address",type:"address"}],name:"IpRoyaltyVault__SameFromToAddress"},{type:"error",inputs:[],name:"IpRoyaltyVault__VaultDoesNotBelongToAnAncestor"},{type:"error",inputs:[],name:"IpRoyaltyVault__VaultsMustClaimAsSelf"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroAmount"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"account",internalType:"address",type:"address"}],name:"IpRoyaltyVault__ZeroBalance"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroDisputeModule"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroGroupingModule"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"spender",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"claimer",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"revenueDebt",internalType:"int256",type:"int256",indexed:false}],name:"RevenueDebtUpdated"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"RevenueTokenAddedToVault"},{type:"event",anonymous:false,inputs:[{name:"claimer",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"RevenueTokenClaimed"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Transfer"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"}],name:"allowance",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"account",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenList",internalType:"address[]",type:"address[]"},{name:"targetIpId",internalType:"address",type:"address"}],name:"claimByTokenBatchAsSelf",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimRevenueOnBehalf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"tokenList",internalType:"address[]",type:"address[]"}],name:"claimRevenueOnBehalfByTokenBatch",outputs:[{name:"",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimableRevenue",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimerRevenueDebt",outputs:[{name:"",internalType:"int256",type:"int256"}],stateMutability:"view"},{type:"function",inputs:[],name:"decimals",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"pure"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"supply",internalType:"uint32",type:"uint32"},{name:"ipIdAddress",internalType:"address",type:"address"},{name:"rtReceiver",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"tokens",outputs:[{name:"",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transfer",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"updateVaultBalance",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"vaultAccBalances",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"}];/**

*/var ipRoyaltyVaultImplAddress={1315:"0x63cC7611316880213f3A4Ba9bD72b0EaA2010298",1514:"0x63cC7611316880213f3A4Ba9bD72b0EaA2010298"};// LicenseAttachmentWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var licenseAttachmentWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"LicenseAttachmentWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"LicenseAttachmentWorkflows__NoLicenseTermsData"},{type:"error",inputs:[],name:"LicenseAttachmentWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachDefaultTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachPILTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],name:"mintAndRegisterIpAndAttachPILTerms_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"terms",internalType:"struct PILTerms[]",type:"tuple[]",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],name:"mintAndRegisterIpAndAttachPILTerms_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndDefaultTerms",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachDefaultTerms",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"sigMetadata",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigAttach",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTerms_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"terms",internalType:"struct PILTerms[]",type:"tuple[]",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"sigMetadata",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigAttach",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTerms_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerPILTermsAndAttach",outputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"terms",internalType:"struct PILTerms[]",type:"tuple[]",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"sigAttach",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerPILTermsAndAttach_deprecated",outputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"sigAttach",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerPILTermsAndAttach_deprecated",outputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var licenseAttachmentWorkflowsAddress={1315:"0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8",1514:"0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8"};// LicenseRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var licenseRegistryAbi=[{type:"constructor",inputs:[{name:"groupIpAssetRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"}],name:"LicenseRegistry__AddParentIpToIPGraphFailed"},{type:"error",inputs:[],name:"LicenseRegistry__CallFailed"},{type:"error",inputs:[],name:"LicenseRegistry__CallerNotLicensingModule"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__CannotAddIpWithExpirationToGroup"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeAlreadyRegistered"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIpAlreadyHasChild"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIpAlreadyHasLicense"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIsParent"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DuplicateParentIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__EmptyGroupCannotMintLicenseToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupCannotHasParentIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupIpAlreadyHasLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipCommercialRevShare",internalType:"uint32",type:"uint32"},{name:"groupCommercialRevShare",internalType:"uint32",type:"uint32"}],name:"LicenseRegistry__GroupIpCommercialRevShareConfigMustNotLessThanIp"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupMustBeSoleParent"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IndexOutOfBounds"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"expectGroupRewardPool",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpectGroupRewardPoolNotMatch"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpectGroupRewardPoolNotSet"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpired"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpHasNoGroupLicenseTerms"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpLicenseDisabled"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"groupHookData",internalType:"bytes",type:"bytes"}],name:"LicenseRegistry__IpLicensingHookDataNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licensingHook",internalType:"address",type:"address"},{name:"groupLicensingHook",internalType:"address",type:"address"}],name:"LicenseRegistry__IpLicensingHookNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"groupMintingFee",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpMintingFeeNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsAlreadyAttached"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsCannotAttachToGroupIp"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsNotExists"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicensorIpHasNoLicenseTerms"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__NotLicenseTemplate"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpExpired"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__ParentIpHasNoLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpIsEmptyGroup"},{type:"error",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpNotRegistered"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpTagged"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpUnmatchedLicenseTemplate"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestors",internalType:"uint256",type:"uint256"},{name:"maxAncestors",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__TooManyAncestors"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parents",internalType:"uint256",type:"uint256"},{name:"maxParents",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__TooManyParents"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"newLicenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnmatchedLicenseTemplate"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnregisteredLicenseTemplate"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroAccessManager"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroDisputeModule"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroGroupIpRegistry"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroIPGraphACL"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroLicenseTemplate"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroLicensingModule"},{type:"error",inputs:[],name:"LicensingModule__DerivativesCannotAddLicenseTerms"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseTermsNotFound"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"RoyaltyModule__CallFailed"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:false}],name:"DefaultLicenseTermsSet"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"expireTime",internalType:"uint256",type:"uint256",indexed:false}],name:"ExpirationTimeSet"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"licenseTemplate",internalType:"address",type:"address",indexed:true}],name:"LicenseTemplateRegistered"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:true},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}],indexed:false}],name:"LicensingConfigSetForLicense"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"EXPIRATION_TIME",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_ANCESTORS",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_PARENTS",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"attachLicenseTermsToIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"exists",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getAncestorsCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getAttachedLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getAttachedLicenseTermsCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getDefaultLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getDerivativeIp",outputs:[{name:"childIpId",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"getDerivativeIpCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicensingConfig",outputs:[{name:"",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getParentIp",outputs:[{name:"parentIpId",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"getParentIpCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"}],name:"getParentLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getRoyaltyPercent",outputs:[{name:"royaltyPercent",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"hasDerivativeIps",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"hasIpAttachedLicenseTerms",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"isDefaultLicense",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"isDerivativeIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isExpiredNow",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"childIpId",internalType:"address",type:"address"}],name:"isParentIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"isRegisteredLicenseTemplate",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"isUsingLicenseToken",internalType:"bool",type:"bool"}],name:"registerDerivativeIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"registerLicenseTemplate",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newLicenseTemplate",internalType:"address",type:"address"},{name:"newLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"setDefaultLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],name:"setLicensingConfigForLicense",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"},{name:"groupLicenseTemplate",internalType:"address",type:"address"},{name:"groupLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"verifyGroupAddIp",outputs:[{name:"ipLicensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"isMintedByIpOwner",internalType:"bool",type:"bool"}],name:"verifyMintLicenseToken",outputs:[{name:"",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"}];/**

*/var licenseRegistryAddress={1315:"0x529a750E02d8E2f15649c13D69a465286a780e24",1514:"0x529a750E02d8E2f15649c13D69a465286a780e24"};// LicenseToken
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var licenseTokenAbi=[{type:"constructor",inputs:[{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"ERC721EnumerableForbiddenBatchMint"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"owner",internalType:"address",type:"address"}],name:"ERC721IncorrectOwner"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721InsufficientApproval"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC721InvalidApprover"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"}],name:"ERC721InvalidOperator"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"ERC721InvalidOwner"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC721InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC721InvalidSender"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721NonexistentToken"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"ERC721OutOfBoundsIndex"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"anotherLicenseTemplate",internalType:"address",type:"address"}],name:"LicenseToken__AllLicenseTokensMustFromSameLicenseTemplate"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"caller",internalType:"address",type:"address"},{name:"childIpIp",internalType:"address",type:"address"},{name:"actualTokenOwner",internalType:"address",type:"address"}],name:"LicenseToken__CallerAndChildIPNotTokenOwner"},{type:"error",inputs:[],name:"LicenseToken__CallerNotLicensingModule"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseToken__ChildIPAlreadyHasBeenMintedLicenseTokens"},{type:"error",inputs:[{name:"commercialRevenueShare",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"},{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__CommercialRevenueShareExceedMaxRevenueShare"},{type:"error",inputs:[{name:"invalidRoyaltyPercent",internalType:"uint32",type:"uint32"},{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__InvalidRoyaltyPercent"},{type:"error",inputs:[],name:"LicenseToken__NotTransferable"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__RevokedLicense"},{type:"error",inputs:[],name:"LicenseToken__ZeroAccessManager"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"value",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"StringsInsufficientHexLength"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"operator",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"ApprovalForAll"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"_fromTokenId",internalType:"uint256",type:"uint256",indexed:false},{name:"_toTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"BatchMetadataUpdate"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"minter",internalType:"address",type:"address",indexed:true},{name:"receiver",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"LicenseTokenMinted"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Transfer"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_COMMERCIAL_REVENUE_SHARE",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"holder",internalType:"address",type:"address"},{name:"tokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"burnLicenseTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getApproved",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTemplate",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTermsId",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTokenMetadata",outputs:[{name:"",internalType:"struct ILicenseToken.LicenseTokenMetadata",type:"tuple",components:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"transferable",internalType:"bool",type:"bool"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicensorIpId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"}],name:"getTotalTokensByLicensor",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"imageUrl",internalType:"string",type:"string"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"operator",internalType:"address",type:"address"}],name:"isApprovedForAll",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"isLicenseTokenRevoked",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"minter",internalType:"address",type:"address"},{name:"receiver",internalType:"address",type:"address"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"mintLicenseTokens",outputs:[{name:"startLicenseTokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ownerOf",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"url",internalType:"string",type:"string"}],name:"setLicensingImageUrl",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"index",internalType:"uint256",type:"uint256"}],name:"tokenByIndex",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"id",internalType:"uint256",type:"uint256"}],name:"tokenURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalMintedTokens",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"childIpId",internalType:"address",type:"address"},{name:"tokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"validateLicenseTokensForDerivative",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licensorIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"commercialRevShares",internalType:"uint32[]",type:"uint32[]"}],stateMutability:"view"}];/**

*/var licenseTokenAddress={1315:"0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC",1514:"0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC"};// LicensingModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var licensingModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"LicenseRegistry__LicenseTemplateCannotBeZeroAddress"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnregisteredLicenseTemplate"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"LicensingModule__CurrentLicenseNotAllowOverrideRoyaltyPercent"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicensingModule__DerivativeAlreadyHasBeenMintedLicenseTokens"},{type:"error",inputs:[],name:"LicensingModule__DisputedIpId"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"revenueShare",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"LicensingModule__ExceedMaxRevenueShare"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeHookData"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeIsSet"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeLicensingHook"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeMintingFee"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"},{name:"oldRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"LicensingModule__GroupIpCannotDecreaseRoyalty"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotSetExpectGroupRewardPool"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__InvalidLicenseTermsId"},{type:"error",inputs:[{name:"hook",internalType:"address",type:"address"}],name:"LicensingModule__InvalidLicensingHook"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensorIpId",internalType:"address",type:"address"}],name:"LicensingModule__LicenseDenyMintLicenseToken"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseDisabled"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicensingModule__LicenseNotCompatibleForDerivative"},{type:"error",inputs:[{name:"ipLength",internalType:"uint256",type:"uint256"},{name:"licenseTermsLength",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseTermsLengthMismatch"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"LicensingModule__LicenseTokenNotCompatibleForDerivative"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfigMintingFee",internalType:"uint256",type:"uint256"},{name:"licenseTermsMintingFee",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicensingConfigMintingFeeBelowLicenseTerms"},{type:"error",inputs:[],name:"LicensingModule__LicensorIpNotRegistered"},{type:"error",inputs:[],name:"LicensingModule__MintAmountZero"},{type:"error",inputs:[{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"}],name:"LicensingModule__MintingFeeExceedMaxMintingFee"},{type:"error",inputs:[],name:"LicensingModule__MintingFeeRequiresRoyaltyPolicy"},{type:"error",inputs:[],name:"LicensingModule__NoLicenseToken"},{type:"error",inputs:[],name:"LicensingModule__NoParentIp"},{type:"error",inputs:[],name:"LicensingModule__ReceiverZeroAddress"},{type:"error",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"anotherRoyaltyPolicy",internalType:"address",type:"address"}],name:"LicensingModule__RoyaltyPolicyMismatch"},{type:"error",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"ancestors",internalType:"uint256",type:"uint256"},{name:"maxAncestors",internalType:"uint256",type:"uint256"}],name:"LicensingModule__TooManyAncestorsForMintingLicenseTokenAllowRegisterDerivative"},{type:"error",inputs:[],name:"LicensingModule__ZeroAccessManager"},{type:"error",inputs:[],name:"LicensingModule__ZeroDisputeModule"},{type:"error",inputs:[],name:"LicensingModule__ZeroIPGraphACL"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseTemplate"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseToken"},{type:"error",inputs:[],name:"LicensingModule__ZeroModuleRegistry"},{type:"error",inputs:[],name:"LicensingModule__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"childIpId",internalType:"address",type:"address",indexed:true},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]",indexed:false},{name:"parentIpIds",internalType:"address[]",type:"address[]",indexed:false},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]",indexed:false},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false}],name:"DerivativeRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseTermsAttached"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"licensorIpId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"receiver",internalType:"address",type:"address",indexed:false},{name:"startLicenseTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseTokensMinted"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_NFT",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract RoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"attachDefaultLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"attachLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"receiver",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"mintLicenseTokens",outputs:[{name:"startLicenseTokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"receiver",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"}],name:"predictMintingLicenseFee",outputs:[{name:"currencyToken",internalType:"address",type:"address"},{name:"tokenAmount",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"registerDerivative",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"}],name:"registerDerivativeWithLicenseTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],name:"setLicensingConfig",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var licensingModuleAddress={1315:"0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f",1514:"0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f"};// ModuleRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var moduleRegistryAbi=[{type:"constructor",inputs:[],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"ModuleRegistry__InterfaceIdZero"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAddressNotContract"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAddressZeroAddress"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleNotRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleNotSupportExpectedModuleTypeInterfaceId"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeEmptyString"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeNotRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__NameAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__NameDoesNotMatch"},{type:"error",inputs:[],name:"ModuleRegistry__NameEmptyString"},{type:"error",inputs:[],name:"ModuleRegistry__ZeroAccessManager"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"name",internalType:"string",type:"string",indexed:false},{name:"module",internalType:"address",type:"address",indexed:true},{name:"moduleTypeInterfaceId",internalType:"bytes4",type:"bytes4",indexed:true},{name:"moduleType",internalType:"string",type:"string",indexed:false}],name:"ModuleAdded"},{type:"event",anonymous:false,inputs:[{name:"name",internalType:"string",type:"string",indexed:false},{name:"module",internalType:"address",type:"address",indexed:true}],name:"ModuleRemoved"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"getModule",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleAddress",internalType:"address",type:"address"}],name:"getModuleType",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleType",internalType:"string",type:"string"}],name:"getModuleTypeInterfaceId",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleAddress",internalType:"address",type:"address"}],name:"isRegistered",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"moduleAddress",internalType:"address",type:"address"}],name:"registerModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"moduleAddress",internalType:"address",type:"address"},{name:"moduleType",internalType:"string",type:"string"}],name:"registerModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"registerModuleType",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"removeModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"removeModuleType",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var moduleRegistryAddress={1315:"0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5",1514:"0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5"};// Multicall3
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var multicall3Abi=[{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"returnData",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call3[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"allowFailure",internalType:"bool",type:"bool"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate3",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call3Value[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"allowFailure",internalType:"bool",type:"bool"},{name:"value",internalType:"uint256",type:"uint256"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate3Value",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"blockAndAggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"blockHash",internalType:"bytes32",type:"bytes32"},{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[],name:"getBasefee",outputs:[{name:"basefee",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"}],name:"getBlockHash",outputs:[{name:"blockHash",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"getBlockNumber",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getChainId",outputs:[{name:"chainid",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockCoinbase",outputs:[{name:"coinbase",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockDifficulty",outputs:[{name:"difficulty",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockGasLimit",outputs:[{name:"gaslimit",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockTimestamp",outputs:[{name:"timestamp",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"addr",internalType:"address",type:"address"}],name:"getEthBalance",outputs:[{name:"balance",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getLastBlockHash",outputs:[{name:"blockHash",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"requireSuccess",internalType:"bool",type:"bool"},{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"tryAggregate",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"requireSuccess",internalType:"bool",type:"bool"},{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"tryBlockAndAggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"blockHash",internalType:"bytes32",type:"bytes32"},{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"}];/**

*/var multicall3Address={1315:"0xcA11bde05977b3631167028862bE2a173976CA11",1514:"0xcA11bde05977b3631167028862bE2a173976CA11"};// PILicenseTemplate
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var piLicenseTemplateAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddAttribution"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddCommercializers"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddDerivativeRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRevShare"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRoyaltyPolicy"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialEnabled_RoyaltyPolicyRequired"},{type:"error",inputs:[{name:"checker",internalType:"address",type:"address"}],name:"PILicenseTemplate__CommercializerCheckerDoesNotSupportHook"},{type:"error",inputs:[{name:"commercializerChecker",internalType:"address",type:"address"}],name:"PILicenseTemplate__CommercializerCheckerNotRegistered"},{type:"error",inputs:[],name:"PILicenseTemplate__CurrencyTokenNotWhitelisted"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddApproval"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddAttribution"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddDerivativeRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddReciprocal"},{type:"error",inputs:[],name:"PILicenseTemplate__MintingFeeRequiresRoyaltyPolicy"},{type:"error",inputs:[],name:"PILicenseTemplate__RoyaltyPolicyNotWhitelisted"},{type:"error",inputs:[],name:"PILicenseTemplate__RoyaltyPolicyRequiresCurrencyToken"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroAccessManager"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"caller",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"DerivativeApproved"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:true},{name:"licenseTerms",internalType:"bytes",type:"bytes",indexed:false}],name:"LicenseTermsRegistered"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"TERMS_RENDERER",outputs:[{name:"",internalType:"contract PILTermsRenderer",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"allowDerivativeRegistration",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"canAttachToGroupIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"canOverrideRoyaltyPercent",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"exists",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"start",internalType:"uint256",type:"uint256"}],name:"getEarlierExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"start",internalType:"uint256",type:"uint256"}],name:"getExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"selectedLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicenseTerms",outputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],name:"getLicenseTermsId",outputs:[{name:"selectedLicenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicenseTermsURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"getMetadataURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getRoyaltyPolicy",outputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"royaltyPercent",internalType:"uint32",type:"uint32"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"name",internalType:"string",type:"string"},{name:"metadataURI",internalType:"string",type:"string"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"childIpId",internalType:"address",type:"address"}],name:"isDerivativeApproved",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"isLicenseTransferable",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],name:"registerLicenseTerms",outputs:[{name:"id",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"childIpId",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApproval",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"toJson",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalRegisteredLicenseTerms",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],name:"verifyCompatibleLicenses",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensee",internalType:"address",type:"address"},{name:"licensorIpId",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"}],name:"verifyMintLicenseToken",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensee",internalType:"address",type:"address"}],name:"verifyRegisterDerivative",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"caller",internalType:"address",type:"address"}],name:"verifyRegisterDerivativeForAllParents",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"}];/**

*/var piLicenseTemplateAddress={1315:"0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316",1514:"0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316"};// RegistrationWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var registrationWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"RegistrationWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"RegistrationWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"spgNftContract",internalType:"address",type:"address",indexed:true}],name:"CollectionCreated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftInitParams",internalType:"struct ISPGNFT.InitParams",type:"tuple",components:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"baseURI",internalType:"string",type:"string"},{name:"contractURI",internalType:"string",type:"string"},{name:"maxSupply",internalType:"uint32",type:"uint32"},{name:"mintFee",internalType:"uint256",type:"uint256"},{name:"mintFeeToken",internalType:"address",type:"address"},{name:"mintFeeRecipient",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"},{name:"mintOpen",internalType:"bool",type:"bool"},{name:"isPublicMinting",internalType:"bool",type:"bool"}]}],name:"createCollection",outputs:[{name:"spgNftContract",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIp",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]}],name:"mintAndRegisterIp_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadata",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIp",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newNftContractBeacon",internalType:"address",type:"address"}],name:"setNftContractBeacon",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newNftContract",internalType:"address",type:"address"}],name:"upgradeCollections",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var registrationWorkflowsAddress={1315:"0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424",1514:"0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424"};// RoyaltyModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var royaltyModuleAbi=[{type:"constructor",inputs:[{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"RoyaltyModule__AboveAccumulatedRoyaltyPoliciesLimit"},{type:"error",inputs:[],name:"RoyaltyModule__AboveMaxPercent"},{type:"error",inputs:[],name:"RoyaltyModule__AboveMaxRts"},{type:"error",inputs:[],name:"RoyaltyModule__CallFailed"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"rewardPool",internalType:"address",type:"address"}],name:"RoyaltyModule__GroupRewardPoolNotWhitelisted"},{type:"error",inputs:[],name:"RoyaltyModule__InvalidExternalRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__IpExpired"},{type:"error",inputs:[],name:"RoyaltyModule__IpIsTagged"},{type:"error",inputs:[],name:"RoyaltyModule__NoParentsOnLinking"},{type:"error",inputs:[],name:"RoyaltyModule__NotAllowedCaller"},{type:"error",inputs:[],name:"RoyaltyModule__NotWhitelistedOrRegisteredRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__NotWhitelistedRoyaltyToken"},{type:"error",inputs:[],name:"RoyaltyModule__PaymentAmountIsTooLow"},{type:"error",inputs:[],name:"RoyaltyModule__PolicyAlreadyRegisteredAsExternalRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__PolicyAlreadyWhitelistedOrRegistered"},{type:"error",inputs:[],name:"RoyaltyModule__UnlinkableToParents"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAccessManager"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAccumulatedRoyaltyPoliciesLimit"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAmount"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroDisputeModule"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroIpGraphAcl"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroLicensingModule"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroParentIpId"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroReceiverVault"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroRoyaltyToken"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroTreasury"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"VaultController__ZeroIpRoyaltyVaultBeacon"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address",indexed:false}],name:"ExternalRoyaltyPolicyRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"ipRoyaltyVault",internalType:"address",type:"address",indexed:false}],name:"IpRoyaltyVaultDeployed"},{type:"event",anonymous:false,inputs:[{name:"receiverIpId",internalType:"address",type:"address",indexed:false},{name:"payerAddress",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"amountAfterFee",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseMintingFeePaid"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"royaltyPolicy",internalType:"address",type:"address",indexed:false},{name:"licensePercent",internalType:"uint32",type:"uint32",indexed:false},{name:"externalData",internalType:"bytes",type:"bytes",indexed:false}],name:"LicensedWithRoyalty"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"parentIpIds",internalType:"address[]",type:"address[]",indexed:false},{name:"licenseRoyaltyPolicies",internalType:"address[]",type:"address[]",indexed:false},{name:"licensesPercent",internalType:"uint32[]",type:"uint32[]",indexed:false},{name:"externalData",internalType:"bytes",type:"bytes",indexed:false}],name:"LinkedToParents"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"royaltyFeePercent",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyFeePercentSet"},{type:"event",anonymous:false,inputs:[{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyLimitsUpdated"},{type:"event",anonymous:false,inputs:[{name:"receiverIpId",internalType:"address",type:"address",indexed:false},{name:"payerIpId",internalType:"address",type:"address",indexed:false},{name:"sender",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"amountAfterFee",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyPaid"},{type:"event",anonymous:false,inputs:[{name:"royaltyPolicy",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"RoyaltyPolicyWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"RoyaltyTokenWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"treasury",internalType:"address",type:"address",indexed:false}],name:"TreasurySet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_PERCENT",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"accumulatedRoyaltyPolicies",outputs:[{name:"",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"globalRoyaltyStack",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"}],name:"hasAncestorIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipRoyaltyVaultBeacon",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"ipRoyaltyVaults",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipRoyaltyVault",internalType:"address",type:"address"}],name:"isIpRoyaltyVault",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address"}],name:"isRegisteredExternalRoyaltyPolicy",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"}],name:"isWhitelistedRoyaltyPolicy",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"isWhitelistedRoyaltyToken",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxAccumulatedRoyaltyPolicies",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxAncestors",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxParents",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxPercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"pure"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"licensePercent",internalType:"uint32",type:"uint32"},{name:"externalData",internalType:"bytes",type:"bytes"}],name:"onLicenseMinting",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseRoyaltyPolicies",internalType:"address[]",type:"address[]"},{name:"licensesPercent",internalType:"uint32[]",type:"uint32[]"},{name:"externalData",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"}],name:"onLinkToParents",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"receiverIpId",internalType:"address",type:"address"},{name:"payerAddress",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"payLicenseMintingFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"receiverIpId",internalType:"address",type:"address"},{name:"payerIpId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"payRoyaltyOnBehalf",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address"}],name:"registerExternalRoyaltyPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"royaltyFeePercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"beacon",internalType:"address",type:"address"}],name:"setIpRoyaltyVaultBeacon",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"royaltyFeePercent",internalType:"uint32",type:"uint32"}],name:"setRoyaltyFeePercent",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256"}],name:"setRoyaltyLimits",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"treasury",internalType:"address",type:"address"}],name:"setTreasury",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"royaltyPolicy",internalType:"address",type:"address"}],name:"totalRevenueTokensAccounted",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"totalRevenueTokensReceived",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"treasury",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"newVault",internalType:"address",type:"address"}],name:"upgradeVaults",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistRoyaltyPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistRoyaltyToken",outputs:[],stateMutability:"nonpayable"}];/**

*/var royaltyModuleAddress={1315:"0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086",1514:"0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086"};/**

*/var royaltyPolicyLapAddress={1315:"0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E",1514:"0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E"};// RoyaltyTokenDistributionWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var royaltyTokenDistributionWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"royaltyPolicyLAP",internalType:"address",type:"address"},{name:"wip",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"RoyaltyTokenDistributionWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__NoLicenseTermsData"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__RoyaltyVaultNotDeployed"},{type:"error",inputs:[{name:"totalShares",internalType:"uint32",type:"uint32"},{name:"ipAccountBalance",internalType:"uint32",type:"uint32"}],name:"RoyaltyTokenDistributionWorkflows__TotalSharesExceedsIPAccountBalance"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__ZeroAddressParam"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_POLICY_LAP",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"WIP",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"sigApproveRoyaltyTokens",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"distributeRoyaltyTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"terms",internalType:"struct PILTerms[]",type:"tuple[]",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]}],name:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"ipRoyaltyVault",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"terms",internalType:"struct PILTerms[]",type:"tuple[]",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"sigMetadata",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigAttach",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTermsAndDeployRoyaltyVault_deprecated",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"ipRoyaltyVault",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ipRoyaltyVault",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var royaltyTokenDistributionWorkflowsAddress={1315:"0xa38f42B8d33809917f23997B8423054aAB97322C",1514:"0xa38f42B8d33809917f23997B8423054aAB97322C"};// RoyaltyWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var royaltyWorkflowsAbi=[{type:"constructor",inputs:[{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"RoyaltyWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ancestorIpId",internalType:"address",type:"address"},{name:"claimer",internalType:"address",type:"address"},{name:"childIpIds",internalType:"address[]",type:"address[]"},{name:"royaltyPolicies",internalType:"address[]",type:"address[]"},{name:"currencyTokens",internalType:"address[]",type:"address[]"}],name:"claimAllRevenue",outputs:[{name:"amountsClaimed",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var royaltyWorkflowsAddress={1315:"0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890",1514:"0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890"};// SPGNFTImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var spgnftImplAbi=[{type:"constructor",inputs:[{name:"derivativeWorkflows",internalType:"address",type:"address"},{name:"groupingWorkflows",internalType:"address",type:"address"},{name:"licenseAttachmentWorkflows",internalType:"address",type:"address"},{name:"registrationWorkflows",internalType:"address",type:"address"},{name:"royaltyTokenDistributionWorkflows",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[],name:"AccessControlBadConfirmation"},{type:"error",inputs:[{name:"account",internalType:"address",type:"address"},{name:"neededRole",internalType:"bytes32",type:"bytes32"}],name:"AccessControlUnauthorizedAccount"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"owner",internalType:"address",type:"address"}],name:"ERC721IncorrectOwner"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721InsufficientApproval"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC721InvalidApprover"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"}],name:"ERC721InvalidOperator"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"ERC721InvalidOwner"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC721InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC721InvalidSender"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721NonexistentToken"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"SPGNFT__CallerNotFeeRecipientOrAdmin"},{type:"error",inputs:[],name:"SPGNFT__CallerNotPeripheryContract"},{type:"error",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"SPGNFT__DuplicatedNFTMetadataHash"},{type:"error",inputs:[],name:"SPGNFT__MaxSupplyReached"},{type:"error",inputs:[],name:"SPGNFT__MintingClosed"},{type:"error",inputs:[],name:"SPGNFT__MintingDenied"},{type:"error",inputs:[],name:"SPGNFT__ZeroAddressParam"},{type:"error",inputs:[],name:"SPGNFT__ZeroMaxSupply"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"operator",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"ApprovalForAll"},{type:"event",anonymous:false,inputs:[{name:"_fromTokenId",internalType:"uint256",type:"uint256",indexed:false},{name:"_toTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"BatchMetadataUpdate"},{type:"event",anonymous:false,inputs:[],name:"ContractURIUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"_tokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"MetadataUpdate"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"previousAdminRole",internalType:"bytes32",type:"bytes32",indexed:true},{name:"newAdminRole",internalType:"bytes32",type:"bytes32",indexed:true}],name:"RoleAdminChanged"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"account",internalType:"address",type:"address",indexed:true},{name:"sender",internalType:"address",type:"address",indexed:true}],name:"RoleGranted"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"account",internalType:"address",type:"address",indexed:true},{name:"sender",internalType:"address",type:"address",indexed:true}],name:"RoleRevoked"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Transfer"},{type:"function",inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"DERIVATIVE_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_ATTACHMENT_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"REGISTRATION_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_TOKEN_DISTRIBUTION_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"baseURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"contractURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getApproved",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"}],name:"getRoleAdmin",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"getTokenIdByMetadataHash",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"hasRole",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"initParams",internalType:"struct ISPGNFT.InitParams",type:"tuple",components:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"baseURI",internalType:"string",type:"string"},{name:"contractURI",internalType:"string",type:"string"},{name:"maxSupply",internalType:"uint32",type:"uint32"},{name:"mintFee",internalType:"uint256",type:"uint256"},{name:"mintFeeToken",internalType:"address",type:"address"},{name:"mintFeeRecipient",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"},{name:"mintOpen",internalType:"bool",type:"bool"},{name:"isPublicMinting",internalType:"bool",type:"bool"}]}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"operator",internalType:"address",type:"address"}],name:"isApprovedForAll",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mint",outputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"payer",internalType:"address",type:"address"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintByPeriphery",outputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"mintFee",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintFeeRecipient",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintFeeToken",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintOpen",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ownerOf",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"publicMinting",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"callerConfirmation",internalType:"address",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"baseURI",internalType:"string",type:"string"}],name:"setBaseURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"contractURI",internalType:"string",type:"string"}],name:"setContractURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"fee",internalType:"uint256",type:"uint256"}],name:"setMintFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newFeeRecipient",internalType:"address",type:"address"}],name:"setMintFeeRecipient",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"setMintFeeToken",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"mintOpen",internalType:"bool",type:"bool"}],name:"setMintOpen",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"isPublicMinting",internalType:"bool",type:"bool"}],name:"setPublicMinting",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"tokenURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"withdrawToken",outputs:[],stateMutability:"nonpayable"}];/**

*/var spgnftImplAddress={1315:"0x6Cfa03Bc64B1a76206d0Ea10baDed31D520449F5",1514:"0x6Cfa03Bc64B1a76206d0Ea10baDed31D520449F5"};// WrappedIP
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var wrappedIpAbi=[{type:"error",inputs:[],name:"AllowanceOverflow"},{type:"error",inputs:[],name:"AllowanceUnderflow"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC20InvalidReceiver"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"}],name:"ERC20InvalidSpender"},{type:"error",inputs:[],name:"IPTransferFailed"},{type:"error",inputs:[],name:"InsufficientAllowance"},{type:"error",inputs:[],name:"InsufficientBalance"},{type:"error",inputs:[],name:"InvalidPermit"},{type:"error",inputs:[],name:"Permit2AllowanceIsFixedAtInfinity"},{type:"error",inputs:[],name:"PermitExpired"},{type:"error",inputs:[],name:"TotalSupplyOverflow"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"spender",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Deposit"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Transfer"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Withdrawal"},{type:"function",inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{name:"result",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"}],name:"allowance",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"decimals",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[],name:"deposit",outputs:[],stateMutability:"payable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"nonces",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"v",internalType:"uint8",type:"uint8"},{name:"r",internalType:"bytes32",type:"bytes32"},{name:"s",internalType:"bytes32",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"transfer",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"value",internalType:"uint256",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable"},{type:"receive",stateMutability:"payable"}];/**

*/var wrappedIpAddress={1315:"0x1514000000000000000000000000000000000000",1514:"0x1514000000000000000000000000000000000000"};// SDK
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// COMMON =============================================================
function getAddress(address,chainId){return address[chainId||0]||"0x";}// Contract AccessController =============================================================
/**
 * AccessControllerPermissionSetEvent
 *
 * @param ipAccountOwner address
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 */ /**
 * AccessControllerSetAllPermissionsRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param permission uint8
 */ /**
 * AccessControllerSetBatchPermissionsRequest
 *
 * @param permissions tuple[]
 */ /**
 * AccessControllerSetPermissionRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 */ /**
 * contract AccessController event
 */var AccessControllerEventClient=/*#__PURE__*/function(){function AccessControllerEventClient(rpcClient,address){var _rpcClient$chain;_classCallCheck(this,AccessControllerEventClient);this.address=address||getAddress(accessControllerAddress,(_rpcClient$chain=rpcClient.chain)===null||_rpcClient$chain===void 0?void 0:_rpcClient$chain.id);this.rpcClient=rpcClient;}/**
   * event PermissionSet for contract AccessController
   */return _createClass(AccessControllerEventClient,[{key:"watchPermissionSetEvent",value:function watchPermissionSetEvent(_onLogs){return this.rpcClient.watchContractEvent({abi:accessControllerAbi,address:this.address,eventName:"PermissionSet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event PermissionSet for contract AccessController
   */},{key:"parseTxPermissionSetEvent",value:function parseTxPermissionSetEvent(txReceipt){var targetLogs=[];var _iterator=_createForOfIteratorHelper(txReceipt.logs),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var log=_step.value;try{var event=decodeEventLog({abi:accessControllerAbi,eventName:"PermissionSet",data:log.data,topics:log.topics});if(event.eventName==="PermissionSet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return targetLogs;}}]);}();/**
 * contract AccessController write method
 */var AccessControllerClient=/*#__PURE__*/function(_AccessControllerEven){function AccessControllerClient(rpcClient,wallet,address){var _this;_classCallCheck(this,AccessControllerClient);_this=_callSuper(this,AccessControllerClient,[rpcClient,address]);_this.wallet=wallet;return _this;}/**
   * method setAllPermissions for contract AccessController
   *
   * @param request AccessControllerSetAllPermissionsRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(AccessControllerClient,_AccessControllerEven);return _createClass(AccessControllerClient,[{key:"setAllPermissions",value:(function(){var _setAllPermissions=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request){var _yield$this$rpcClient,call;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:_context.next=2;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setAllPermissions",account:this.wallet.account,args:[request.ipAccount,request.signer,request.permission]});case 2:_yield$this$rpcClient=_context.sent;call=_yield$this$rpcClient.request;_context.next=6;return this.wallet.writeContract(call);case 6:return _context.abrupt("return",_context.sent);case 7:case"end":return _context.stop();}},_callee,this);}));function setAllPermissions(_x){return _setAllPermissions.apply(this,arguments);}return setAllPermissions;}()/**
   * method setAllPermissions for contract AccessController with only encode
   *
   * @param request AccessControllerSetAllPermissionsRequest
   * @return EncodedTxData
   */)},{key:"setAllPermissionsEncode",value:function setAllPermissionsEncode(request){return {to:this.address,data:encodeFunctionData({abi:accessControllerAbi,functionName:"setAllPermissions",args:[request.ipAccount,request.signer,request.permission]})};}/**
   * method setBatchPermissions for contract AccessController
   *
   * @param request AccessControllerSetBatchPermissionsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setBatchPermissions",value:(function(){var _setBatchPermissions=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request){var _yield$this$rpcClient2,call;return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:_context2.next=2;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setBatchPermissions",account:this.wallet.account,args:[request.permissions]});case 2:_yield$this$rpcClient2=_context2.sent;call=_yield$this$rpcClient2.request;_context2.next=6;return this.wallet.writeContract(call);case 6:return _context2.abrupt("return",_context2.sent);case 7:case"end":return _context2.stop();}},_callee2,this);}));function setBatchPermissions(_x2){return _setBatchPermissions.apply(this,arguments);}return setBatchPermissions;}()/**
   * method setBatchPermissions for contract AccessController with only encode
   *
   * @param request AccessControllerSetBatchPermissionsRequest
   * @return EncodedTxData
   */)},{key:"setBatchPermissionsEncode",value:function setBatchPermissionsEncode(request){return {to:this.address,data:encodeFunctionData({abi:accessControllerAbi,functionName:"setBatchPermissions",args:[request.permissions]})};}/**
   * method setPermission for contract AccessController
   *
   * @param request AccessControllerSetPermissionRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setPermission",value:(function(){var _setPermission=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request){var _yield$this$rpcClient3,call;return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:_context3.next=2;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setPermission",account:this.wallet.account,args:[request.ipAccount,request.signer,request.to,request.func,request.permission]});case 2:_yield$this$rpcClient3=_context3.sent;call=_yield$this$rpcClient3.request;_context3.next=6;return this.wallet.writeContract(call);case 6:return _context3.abrupt("return",_context3.sent);case 7:case"end":return _context3.stop();}},_callee3,this);}));function setPermission(_x3){return _setPermission.apply(this,arguments);}return setPermission;}()/**
   * method setPermission for contract AccessController with only encode
   *
   * @param request AccessControllerSetPermissionRequest
   * @return EncodedTxData
   */)},{key:"setPermissionEncode",value:function setPermissionEncode(request){return {to:this.address,data:encodeFunctionData({abi:accessControllerAbi,functionName:"setPermission",args:[request.ipAccount,request.signer,request.to,request.func,request.permission]})};}}]);}(AccessControllerEventClient);// Contract ArbitrationPolicyUMA =============================================================
/**
 * ArbitrationPolicyUmaMaxBondsRequest
 *
 * @param token address
 */ /**
 * contract ArbitrationPolicyUMA readonly method
 */var ArbitrationPolicyUmaReadOnlyClient=/*#__PURE__*/function(){function ArbitrationPolicyUmaReadOnlyClient(rpcClient,address){var _rpcClient$chain2;_classCallCheck(this,ArbitrationPolicyUmaReadOnlyClient);this.address=address||getAddress(arbitrationPolicyUmaAddress,(_rpcClient$chain2=rpcClient.chain)===null||_rpcClient$chain2===void 0?void 0:_rpcClient$chain2.id);this.rpcClient=rpcClient;}/**
   * method maxBonds for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMaxBondsRequest
   * @return Promise<ArbitrationPolicyUmaMaxBondsResponse>
   */return _createClass(ArbitrationPolicyUmaReadOnlyClient,[{key:"maxBonds",value:(function(){var _maxBonds=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request){return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1)switch(_context4.prev=_context4.next){case 0:_context4.next=2;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"maxBonds",args:[request.token]});case 2:return _context4.abrupt("return",_context4.sent);case 3:case"end":return _context4.stop();}},_callee4,this);}));function maxBonds(_x4){return _maxBonds.apply(this,arguments);}return maxBonds;}()/**
   * method maxLiveness for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMaxLivenessRequest
   * @return Promise<ArbitrationPolicyUmaMaxLivenessResponse>
   */)},{key:"maxLiveness",value:(function(){var _maxLiveness=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(){return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1)switch(_context5.prev=_context5.next){case 0:_context5.next=2;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"maxLiveness"});case 2:return _context5.abrupt("return",_context5.sent);case 3:case"end":return _context5.stop();}},_callee5,this);}));function maxLiveness(){return _maxLiveness.apply(this,arguments);}return maxLiveness;}()/**
   * method minLiveness for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMinLivenessRequest
   * @return Promise<ArbitrationPolicyUmaMinLivenessResponse>
   */)},{key:"minLiveness",value:(function(){var _minLiveness=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(){return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1)switch(_context6.prev=_context6.next){case 0:_context6.next=2;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"minLiveness"});case 2:return _context6.abrupt("return",_context6.sent);case 3:case"end":return _context6.stop();}},_callee6,this);}));function minLiveness(){return _minLiveness.apply(this,arguments);}return minLiveness;}())}]);}();// Contract CoreMetadataModule =============================================================
/**
 * CoreMetadataModuleAuthorityUpdatedEvent
 *
 * @param authority address
 */ /**
 * CoreMetadataModuleInitializedEvent
 *
 * @param version uint64
 */ /**
 * CoreMetadataModuleMetadataFrozenEvent
 *
 * @param ipId address
 */ /**
 * CoreMetadataModuleMetadataUriSetEvent
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 */ /**
 * CoreMetadataModuleNftTokenUriSetEvent
 *
 * @param ipId address
 * @param nftTokenURI string
 * @param nftMetadataHash bytes32
 */ /**
 * CoreMetadataModuleUpgradedEvent
 *
 * @param implementation address
 */ /**
 * CoreMetadataModuleIsMetadataFrozenRequest
 *
 * @param ipId address
 */ /**
 * CoreMetadataModuleSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 */ /**
 * CoreMetadataModuleFreezeMetadataRequest
 *
 * @param ipId address
 */ /**
 * CoreMetadataModuleInitializeRequest
 *
 * @param accessManager address
 */ /**
 * CoreMetadataModuleSetAllRequest
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 * @param nftMetadataHash bytes32
 */ /**
 * CoreMetadataModuleSetAuthorityRequest
 *
 * @param newAuthority address
 */ /**
 * CoreMetadataModuleSetMetadataUriRequest
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 */ /**
 * CoreMetadataModuleUpdateNftTokenUriRequest
 *
 * @param ipId address
 * @param nftMetadataHash bytes32
 */ /**
 * CoreMetadataModuleUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */ /**
 * contract CoreMetadataModule event
 */var CoreMetadataModuleEventClient=/*#__PURE__*/function(){function CoreMetadataModuleEventClient(rpcClient,address){var _rpcClient$chain3;_classCallCheck(this,CoreMetadataModuleEventClient);this.address=address||getAddress(coreMetadataModuleAddress,(_rpcClient$chain3=rpcClient.chain)===null||_rpcClient$chain3===void 0?void 0:_rpcClient$chain3.id);this.rpcClient=rpcClient;}/**
   * event AuthorityUpdated for contract CoreMetadataModule
   */return _createClass(CoreMetadataModuleEventClient,[{key:"watchAuthorityUpdatedEvent",value:function watchAuthorityUpdatedEvent(_onLogs2){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"AuthorityUpdated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs2(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AuthorityUpdated for contract CoreMetadataModule
   */},{key:"parseTxAuthorityUpdatedEvent",value:function parseTxAuthorityUpdatedEvent(txReceipt){var targetLogs=[];var _iterator2=_createForOfIteratorHelper(txReceipt.logs),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var log=_step2.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"AuthorityUpdated",data:log.data,topics:log.topics});if(event.eventName==="AuthorityUpdated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return targetLogs;}/**
   * event Initialized for contract CoreMetadataModule
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs3){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs3(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract CoreMetadataModule
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator3=_createForOfIteratorHelper(txReceipt.logs),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var log=_step3.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return targetLogs;}/**
   * event MetadataFrozen for contract CoreMetadataModule
   */},{key:"watchMetadataFrozenEvent",value:function watchMetadataFrozenEvent(_onLogs4){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"MetadataFrozen",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs4(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event MetadataFrozen for contract CoreMetadataModule
   */},{key:"parseTxMetadataFrozenEvent",value:function parseTxMetadataFrozenEvent(txReceipt){var targetLogs=[];var _iterator4=_createForOfIteratorHelper(txReceipt.logs),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var log=_step4.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"MetadataFrozen",data:log.data,topics:log.topics});if(event.eventName==="MetadataFrozen"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}return targetLogs;}/**
   * event MetadataURISet for contract CoreMetadataModule
   */},{key:"watchMetadataUriSetEvent",value:function watchMetadataUriSetEvent(_onLogs5){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"MetadataURISet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs5(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event MetadataURISet for contract CoreMetadataModule
   */},{key:"parseTxMetadataUriSetEvent",value:function parseTxMetadataUriSetEvent(txReceipt){var targetLogs=[];var _iterator5=_createForOfIteratorHelper(txReceipt.logs),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var log=_step5.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"MetadataURISet",data:log.data,topics:log.topics});if(event.eventName==="MetadataURISet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}return targetLogs;}/**
   * event NFTTokenURISet for contract CoreMetadataModule
   */},{key:"watchNftTokenUriSetEvent",value:function watchNftTokenUriSetEvent(_onLogs6){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"NFTTokenURISet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs6(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event NFTTokenURISet for contract CoreMetadataModule
   */},{key:"parseTxNftTokenUriSetEvent",value:function parseTxNftTokenUriSetEvent(txReceipt){var targetLogs=[];var _iterator6=_createForOfIteratorHelper(txReceipt.logs),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var log=_step6.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"NFTTokenURISet",data:log.data,topics:log.topics});if(event.eventName==="NFTTokenURISet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}return targetLogs;}/**
   * event Upgraded for contract CoreMetadataModule
   */},{key:"watchUpgradedEvent",value:function watchUpgradedEvent(_onLogs7){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"Upgraded",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs7(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Upgraded for contract CoreMetadataModule
   */},{key:"parseTxUpgradedEvent",value:function parseTxUpgradedEvent(txReceipt){var targetLogs=[];var _iterator7=_createForOfIteratorHelper(txReceipt.logs),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var log=_step7.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"Upgraded",data:log.data,topics:log.topics});if(event.eventName==="Upgraded"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}return targetLogs;}}]);}();/**
 * contract CoreMetadataModule readonly method
 */var CoreMetadataModuleReadOnlyClient=/*#__PURE__*/function(_CoreMetadataModuleEv){function CoreMetadataModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,CoreMetadataModuleReadOnlyClient);return _callSuper(this,CoreMetadataModuleReadOnlyClient,[rpcClient,address]);}/**
   * method ACCESS_CONTROLLER for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleAccessControllerRequest
   * @return Promise<CoreMetadataModuleAccessControllerResponse>
   */_inherits(CoreMetadataModuleReadOnlyClient,_CoreMetadataModuleEv);return _createClass(CoreMetadataModuleReadOnlyClient,[{key:"accessController",value:(function(){var _accessController=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(){return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1)switch(_context7.prev=_context7.next){case 0:_context7.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"ACCESS_CONTROLLER"});case 2:return _context7.abrupt("return",_context7.sent);case 3:case"end":return _context7.stop();}},_callee7,this);}));function accessController(){return _accessController.apply(this,arguments);}return accessController;}()/**
   * method IP_ASSET_REGISTRY for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIpAssetRegistryRequest
   * @return Promise<CoreMetadataModuleIpAssetRegistryResponse>
   */)},{key:"ipAssetRegistry",value:(function(){var _ipAssetRegistry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(){return _regeneratorRuntime().wrap(function _callee8$(_context8){while(1)switch(_context8.prev=_context8.next){case 0:_context8.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"IP_ASSET_REGISTRY"});case 2:return _context8.abrupt("return",_context8.sent);case 3:case"end":return _context8.stop();}},_callee8,this);}));function ipAssetRegistry(){return _ipAssetRegistry.apply(this,arguments);}return ipAssetRegistry;}()/**
   * method UPGRADE_INTERFACE_VERSION for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpgradeInterfaceVersionRequest
   * @return Promise<CoreMetadataModuleUpgradeInterfaceVersionResponse>
   */)},{key:"upgradeInterfaceVersion",value:(function(){var _upgradeInterfaceVersion=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(){return _regeneratorRuntime().wrap(function _callee9$(_context9){while(1)switch(_context9.prev=_context9.next){case 0:_context9.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"UPGRADE_INTERFACE_VERSION"});case 2:return _context9.abrupt("return",_context9.sent);case 3:case"end":return _context9.stop();}},_callee9,this);}));function upgradeInterfaceVersion(){return _upgradeInterfaceVersion.apply(this,arguments);}return upgradeInterfaceVersion;}()/**
   * method authority for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleAuthorityRequest
   * @return Promise<CoreMetadataModuleAuthorityResponse>
   */)},{key:"authority",value:(function(){var _authority=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(){return _regeneratorRuntime().wrap(function _callee10$(_context10){while(1)switch(_context10.prev=_context10.next){case 0:_context10.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"authority"});case 2:return _context10.abrupt("return",_context10.sent);case 3:case"end":return _context10.stop();}},_callee10,this);}));function authority(){return _authority.apply(this,arguments);}return authority;}()/**
   * method isConsumingScheduledOp for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIsConsumingScheduledOpRequest
   * @return Promise<CoreMetadataModuleIsConsumingScheduledOpResponse>
   */)},{key:"isConsumingScheduledOp",value:(function(){var _isConsumingScheduledOp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(){return _regeneratorRuntime().wrap(function _callee11$(_context11){while(1)switch(_context11.prev=_context11.next){case 0:_context11.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"isConsumingScheduledOp"});case 2:return _context11.abrupt("return",_context11.sent);case 3:case"end":return _context11.stop();}},_callee11,this);}));function isConsumingScheduledOp(){return _isConsumingScheduledOp.apply(this,arguments);}return isConsumingScheduledOp;}()/**
   * method isMetadataFrozen for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIsMetadataFrozenRequest
   * @return Promise<CoreMetadataModuleIsMetadataFrozenResponse>
   */)},{key:"isMetadataFrozen",value:(function(){var _isMetadataFrozen=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(request){return _regeneratorRuntime().wrap(function _callee12$(_context12){while(1)switch(_context12.prev=_context12.next){case 0:_context12.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"isMetadataFrozen",args:[request.ipId]});case 2:return _context12.abrupt("return",_context12.sent);case 3:case"end":return _context12.stop();}},_callee12,this);}));function isMetadataFrozen(_x5){return _isMetadataFrozen.apply(this,arguments);}return isMetadataFrozen;}()/**
   * method name for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleNameRequest
   * @return Promise<CoreMetadataModuleNameResponse>
   */)},{key:"name",value:(function(){var _name=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(){return _regeneratorRuntime().wrap(function _callee13$(_context13){while(1)switch(_context13.prev=_context13.next){case 0:_context13.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"name"});case 2:return _context13.abrupt("return",_context13.sent);case 3:case"end":return _context13.stop();}},_callee13,this);}));function name(){return _name.apply(this,arguments);}return name;}()/**
   * method proxiableUUID for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleProxiableUuidRequest
   * @return Promise<CoreMetadataModuleProxiableUuidResponse>
   */)},{key:"proxiableUuid",value:(function(){var _proxiableUuid=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(){return _regeneratorRuntime().wrap(function _callee14$(_context14){while(1)switch(_context14.prev=_context14.next){case 0:_context14.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"proxiableUUID"});case 2:return _context14.abrupt("return",_context14.sent);case 3:case"end":return _context14.stop();}},_callee14,this);}));function proxiableUuid(){return _proxiableUuid.apply(this,arguments);}return proxiableUuid;}()/**
   * method supportsInterface for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSupportsInterfaceRequest
   * @return Promise<CoreMetadataModuleSupportsInterfaceResponse>
   */)},{key:"supportsInterface",value:(function(){var _supportsInterface=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(request){return _regeneratorRuntime().wrap(function _callee15$(_context15){while(1)switch(_context15.prev=_context15.next){case 0:_context15.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"supportsInterface",args:[request.interfaceId]});case 2:return _context15.abrupt("return",_context15.sent);case 3:case"end":return _context15.stop();}},_callee15,this);}));function supportsInterface(_x6){return _supportsInterface.apply(this,arguments);}return supportsInterface;}())}]);}(CoreMetadataModuleEventClient);/**
 * contract CoreMetadataModule write method
 */var CoreMetadataModuleClient=/*#__PURE__*/function(_CoreMetadataModuleRe){function CoreMetadataModuleClient(rpcClient,wallet,address){var _this2;_classCallCheck(this,CoreMetadataModuleClient);_this2=_callSuper(this,CoreMetadataModuleClient,[rpcClient,address]);_this2.wallet=wallet;return _this2;}/**
   * method freezeMetadata for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleFreezeMetadataRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(CoreMetadataModuleClient,_CoreMetadataModuleRe);return _createClass(CoreMetadataModuleClient,[{key:"freezeMetadata",value:(function(){var _freezeMetadata=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(request){var _yield$this$rpcClient4,call;return _regeneratorRuntime().wrap(function _callee16$(_context16){while(1)switch(_context16.prev=_context16.next){case 0:_context16.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"freezeMetadata",account:this.wallet.account,args:[request.ipId]});case 2:_yield$this$rpcClient4=_context16.sent;call=_yield$this$rpcClient4.request;_context16.next=6;return this.wallet.writeContract(call);case 6:return _context16.abrupt("return",_context16.sent);case 7:case"end":return _context16.stop();}},_callee16,this);}));function freezeMetadata(_x7){return _freezeMetadata.apply(this,arguments);}return freezeMetadata;}()/**
   * method freezeMetadata for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleFreezeMetadataRequest
   * @return EncodedTxData
   */)},{key:"freezeMetadataEncode",value:function freezeMetadataEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"freezeMetadata",args:[request.ipId]})};}/**
   * method initialize for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleInitializeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"initialize",value:(function(){var _initialize=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(request){var _yield$this$rpcClient5,call;return _regeneratorRuntime().wrap(function _callee17$(_context17){while(1)switch(_context17.prev=_context17.next){case 0:_context17.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"initialize",account:this.wallet.account,args:[request.accessManager]});case 2:_yield$this$rpcClient5=_context17.sent;call=_yield$this$rpcClient5.request;_context17.next=6;return this.wallet.writeContract(call);case 6:return _context17.abrupt("return",_context17.sent);case 7:case"end":return _context17.stop();}},_callee17,this);}));function initialize(_x8){return _initialize.apply(this,arguments);}return initialize;}()/**
   * method initialize for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleInitializeRequest
   * @return EncodedTxData
   */)},{key:"initializeEncode",value:function initializeEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"initialize",args:[request.accessManager]})};}/**
   * method setAll for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetAllRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAll",value:(function(){var _setAll=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(request){var _yield$this$rpcClient6,call;return _regeneratorRuntime().wrap(function _callee18$(_context18){while(1)switch(_context18.prev=_context18.next){case 0:_context18.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setAll",account:this.wallet.account,args:[request.ipId,request.metadataURI,request.metadataHash,request.nftMetadataHash]});case 2:_yield$this$rpcClient6=_context18.sent;call=_yield$this$rpcClient6.request;_context18.next=6;return this.wallet.writeContract(call);case 6:return _context18.abrupt("return",_context18.sent);case 7:case"end":return _context18.stop();}},_callee18,this);}));function setAll(_x9){return _setAll.apply(this,arguments);}return setAll;}()/**
   * method setAll for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetAllRequest
   * @return EncodedTxData
   */)},{key:"setAllEncode",value:function setAllEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setAll",args:[request.ipId,request.metadataURI,request.metadataHash,request.nftMetadataHash]})};}/**
   * method setAuthority for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetAuthorityRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAuthority",value:(function(){var _setAuthority=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(request){var _yield$this$rpcClient7,call;return _regeneratorRuntime().wrap(function _callee19$(_context19){while(1)switch(_context19.prev=_context19.next){case 0:_context19.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setAuthority",account:this.wallet.account,args:[request.newAuthority]});case 2:_yield$this$rpcClient7=_context19.sent;call=_yield$this$rpcClient7.request;_context19.next=6;return this.wallet.writeContract(call);case 6:return _context19.abrupt("return",_context19.sent);case 7:case"end":return _context19.stop();}},_callee19,this);}));function setAuthority(_x10){return _setAuthority.apply(this,arguments);}return setAuthority;}()/**
   * method setAuthority for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetAuthorityRequest
   * @return EncodedTxData
   */)},{key:"setAuthorityEncode",value:function setAuthorityEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setAuthority",args:[request.newAuthority]})};}/**
   * method setMetadataURI for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetMetadataUriRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setMetadataUri",value:(function(){var _setMetadataUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(request){var _yield$this$rpcClient8,call;return _regeneratorRuntime().wrap(function _callee20$(_context20){while(1)switch(_context20.prev=_context20.next){case 0:_context20.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setMetadataURI",account:this.wallet.account,args:[request.ipId,request.metadataURI,request.metadataHash]});case 2:_yield$this$rpcClient8=_context20.sent;call=_yield$this$rpcClient8.request;_context20.next=6;return this.wallet.writeContract(call);case 6:return _context20.abrupt("return",_context20.sent);case 7:case"end":return _context20.stop();}},_callee20,this);}));function setMetadataUri(_x11){return _setMetadataUri.apply(this,arguments);}return setMetadataUri;}()/**
   * method setMetadataURI for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetMetadataUriRequest
   * @return EncodedTxData
   */)},{key:"setMetadataUriEncode",value:function setMetadataUriEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setMetadataURI",args:[request.ipId,request.metadataURI,request.metadataHash]})};}/**
   * method updateNftTokenURI for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpdateNftTokenUriRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"updateNftTokenUri",value:(function(){var _updateNftTokenUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(request){var _yield$this$rpcClient9,call;return _regeneratorRuntime().wrap(function _callee21$(_context21){while(1)switch(_context21.prev=_context21.next){case 0:_context21.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"updateNftTokenURI",account:this.wallet.account,args:[request.ipId,request.nftMetadataHash]});case 2:_yield$this$rpcClient9=_context21.sent;call=_yield$this$rpcClient9.request;_context21.next=6;return this.wallet.writeContract(call);case 6:return _context21.abrupt("return",_context21.sent);case 7:case"end":return _context21.stop();}},_callee21,this);}));function updateNftTokenUri(_x12){return _updateNftTokenUri.apply(this,arguments);}return updateNftTokenUri;}()/**
   * method updateNftTokenURI for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleUpdateNftTokenUriRequest
   * @return EncodedTxData
   */)},{key:"updateNftTokenUriEncode",value:function updateNftTokenUriEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"updateNftTokenURI",args:[request.ipId,request.nftMetadataHash]})};}/**
   * method upgradeToAndCall for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpgradeToAndCallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"upgradeToAndCall",value:(function(){var _upgradeToAndCall=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(request){var _yield$this$rpcClient10,call;return _regeneratorRuntime().wrap(function _callee22$(_context22){while(1)switch(_context22.prev=_context22.next){case 0:_context22.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"upgradeToAndCall",account:this.wallet.account,args:[request.newImplementation,request.data]});case 2:_yield$this$rpcClient10=_context22.sent;call=_yield$this$rpcClient10.request;_context22.next=6;return this.wallet.writeContract(call);case 6:return _context22.abrupt("return",_context22.sent);case 7:case"end":return _context22.stop();}},_callee22,this);}));function upgradeToAndCall(_x13){return _upgradeToAndCall.apply(this,arguments);}return upgradeToAndCall;}()/**
   * method upgradeToAndCall for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleUpgradeToAndCallRequest
   * @return EncodedTxData
   */)},{key:"upgradeToAndCallEncode",value:function upgradeToAndCallEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"upgradeToAndCall",args:[request.newImplementation,request.data]})};}}]);}(CoreMetadataModuleReadOnlyClient);// Contract DerivativeWorkflows =============================================================
/**
 * DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
 *
 * @param spgNftContract address
 * @param derivData tuple
 * @param ipMetadata tuple
 * @param recipient address
 * @param allowDuplicates bool
 */ /**
 * DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param spgNftContract address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 * @param ipMetadata tuple
 * @param recipient address
 * @param allowDuplicates bool
 */ /**
 * DerivativeWorkflowsMulticallRequest
 *
 * @param data bytes[]
 */ /**
 * DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param derivData tuple
 * @param ipMetadata tuple
 * @param sigMetadataAndRegister tuple
 */ /**
 * DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 * @param ipMetadata tuple
 * @param sigMetadataAndRegister tuple
 */ /**
 * contract DerivativeWorkflows write method
 */var DerivativeWorkflowsClient=/*#__PURE__*/function(){function DerivativeWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain4;_classCallCheck(this,DerivativeWorkflowsClient);this.address=address||getAddress(derivativeWorkflowsAddress,(_rpcClient$chain4=rpcClient.chain)===null||_rpcClient$chain4===void 0?void 0:_rpcClient$chain4.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method mintAndRegisterIpAndMakeDerivative for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(DerivativeWorkflowsClient,[{key:"mintAndRegisterIpAndMakeDerivative",value:(function(){var _mintAndRegisterIpAndMakeDerivative=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(request){var _yield$this$rpcClient11,call;return _regeneratorRuntime().wrap(function _callee23$(_context23){while(1)switch(_context23.prev=_context23.next){case 0:_context23.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivative",account:this.wallet.account,args:[request.spgNftContract,request.derivData,request.ipMetadata,request.recipient,request.allowDuplicates]});case 2:_yield$this$rpcClient11=_context23.sent;call=_yield$this$rpcClient11.request;_context23.next=6;return this.wallet.writeContract(call);case 6:return _context23.abrupt("return",_context23.sent);case 7:case"end":return _context23.stop();}},_callee23,this);}));function mintAndRegisterIpAndMakeDerivative(_x14){return _mintAndRegisterIpAndMakeDerivative.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivative;}()/**
   * method mintAndRegisterIpAndMakeDerivative for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeEncode",value:function mintAndRegisterIpAndMakeDerivativeEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivative",args:[request.spgNftContract,request.derivData,request.ipMetadata,request.recipient,request.allowDuplicates]})};}/**
   * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",value:(function(){var _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(request){var _yield$this$rpcClient12,call;return _regeneratorRuntime().wrap(function _callee24$(_context24){while(1)switch(_context24.prev=_context24.next){case 0:_context24.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.spgNftContract,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.recipient,request.allowDuplicates]});case 2:_yield$this$rpcClient12=_context24.sent;call=_yield$this$rpcClient12.request;_context24.next=6;return this.wallet.writeContract(call);case 6:return _context24.abrupt("return",_context24.sent);case 7:case"end":return _context24.stop();}},_callee24,this);}));function mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_x15){return _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivativeWithLicenseTokens;}()/**
   * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode",value:function mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",args:[request.spgNftContract,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.recipient,request.allowDuplicates]})};}/**
   * method multicall for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(request){var _yield$this$rpcClient13,call;return _regeneratorRuntime().wrap(function _callee25$(_context25){while(1)switch(_context25.prev=_context25.next){case 0:_context25.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 2:_yield$this$rpcClient13=_context25.sent;call=_yield$this$rpcClient13.request;_context25.next=6;return this.wallet.writeContract(call);case 6:return _context25.abrupt("return",_context25.sent);case 7:case"end":return _context25.stop();}},_callee25,this);}));function multicall(_x16){return _multicall.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIpAndMakeDerivative for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivative",value:(function(){var _registerIpAndMakeDerivative=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(request){var _yield$this$rpcClient14,call;return _regeneratorRuntime().wrap(function _callee26$(_context26){while(1)switch(_context26.prev=_context26.next){case 0:_context26.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivative",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.derivData,request.ipMetadata,request.sigMetadataAndRegister]});case 2:_yield$this$rpcClient14=_context26.sent;call=_yield$this$rpcClient14.request;_context26.next=6;return this.wallet.writeContract(call);case 6:return _context26.abrupt("return",_context26.sent);case 7:case"end":return _context26.stop();}},_callee26,this);}));function registerIpAndMakeDerivative(_x17){return _registerIpAndMakeDerivative.apply(this,arguments);}return registerIpAndMakeDerivative;}()/**
   * method registerIpAndMakeDerivative for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeEncode",value:function registerIpAndMakeDerivativeEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"registerIpAndMakeDerivative",args:[request.nftContract,request.tokenId,request.derivData,request.ipMetadata,request.sigMetadataAndRegister]})};}/**
   * method registerIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivativeWithLicenseTokens",value:(function(){var _registerIpAndMakeDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27(request){var _yield$this$rpcClient15,call;return _regeneratorRuntime().wrap(function _callee27$(_context27){while(1)switch(_context27.prev=_context27.next){case 0:_context27.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.sigMetadataAndRegister]});case 2:_yield$this$rpcClient15=_context27.sent;call=_yield$this$rpcClient15.request;_context27.next=6;return this.wallet.writeContract(call);case 6:return _context27.abrupt("return",_context27.sent);case 7:case"end":return _context27.stop();}},_callee27,this);}));function registerIpAndMakeDerivativeWithLicenseTokens(_x18){return _registerIpAndMakeDerivativeWithLicenseTokens.apply(this,arguments);}return registerIpAndMakeDerivativeWithLicenseTokens;}()/**
   * method registerIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeWithLicenseTokensEncode",value:function registerIpAndMakeDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"registerIpAndMakeDerivativeWithLicenseTokens",args:[request.nftContract,request.tokenId,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.sigMetadataAndRegister]})};}}]);}();// Contract DisputeModule =============================================================
/**
 * DisputeModuleDisputeCancelledEvent
 *
 * @param disputeId uint256
 * @param data bytes
 */ /**
 * DisputeModuleDisputeRaisedEvent
 *
 * @param disputeId uint256
 * @param targetIpId address
 * @param disputeInitiator address
 * @param disputeTimestamp uint256
 * @param arbitrationPolicy address
 * @param disputeEvidenceHash bytes32
 * @param targetTag bytes32
 * @param data bytes
 */ /**
 * DisputeModuleDisputeResolvedEvent
 *
 * @param disputeId uint256
 * @param data bytes
 */ /**
 * DisputeModuleIsWhitelistedDisputeTagRequest
 *
 * @param tag bytes32
 */ /**
 * DisputeModuleIsWhitelistedDisputeTagResponse
 *
 * @param allowed bool
 */ /**
 * DisputeModuleCancelDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 */ /**
 * DisputeModuleRaiseDisputeRequest
 *
 * @param targetIpId address
 * @param disputeEvidenceHash bytes32
 * @param targetTag bytes32
 * @param data bytes
 */ /**
 * DisputeModuleResolveDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 */ /**
 * contract DisputeModule event
 */var DisputeModuleEventClient=/*#__PURE__*/function(){function DisputeModuleEventClient(rpcClient,address){var _rpcClient$chain5;_classCallCheck(this,DisputeModuleEventClient);this.address=address||getAddress(disputeModuleAddress,(_rpcClient$chain5=rpcClient.chain)===null||_rpcClient$chain5===void 0?void 0:_rpcClient$chain5.id);this.rpcClient=rpcClient;}/**
   * event DisputeCancelled for contract DisputeModule
   */return _createClass(DisputeModuleEventClient,[{key:"watchDisputeCancelledEvent",value:function watchDisputeCancelledEvent(_onLogs8){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeCancelled",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs8(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeCancelled for contract DisputeModule
   */},{key:"parseTxDisputeCancelledEvent",value:function parseTxDisputeCancelledEvent(txReceipt){var targetLogs=[];var _iterator8=_createForOfIteratorHelper(txReceipt.logs),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var log=_step8.value;try{var event=decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeCancelled",data:log.data,topics:log.topics});if(event.eventName==="DisputeCancelled"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}return targetLogs;}/**
   * event DisputeRaised for contract DisputeModule
   */},{key:"watchDisputeRaisedEvent",value:function watchDisputeRaisedEvent(_onLogs9){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeRaised",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs9(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeRaised for contract DisputeModule
   */},{key:"parseTxDisputeRaisedEvent",value:function parseTxDisputeRaisedEvent(txReceipt){var targetLogs=[];var _iterator9=_createForOfIteratorHelper(txReceipt.logs),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var log=_step9.value;try{var event=decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeRaised",data:log.data,topics:log.topics});if(event.eventName==="DisputeRaised"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}return targetLogs;}/**
   * event DisputeResolved for contract DisputeModule
   */},{key:"watchDisputeResolvedEvent",value:function watchDisputeResolvedEvent(_onLogs10){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeResolved",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs10(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeResolved for contract DisputeModule
   */},{key:"parseTxDisputeResolvedEvent",value:function parseTxDisputeResolvedEvent(txReceipt){var targetLogs=[];var _iterator10=_createForOfIteratorHelper(txReceipt.logs),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var log=_step10.value;try{var event=decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeResolved",data:log.data,topics:log.topics});if(event.eventName==="DisputeResolved"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}return targetLogs;}}]);}();/**
 * contract DisputeModule readonly method
 */var DisputeModuleReadOnlyClient=/*#__PURE__*/function(_DisputeModuleEventCl){function DisputeModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,DisputeModuleReadOnlyClient);return _callSuper(this,DisputeModuleReadOnlyClient,[rpcClient,address]);}/**
   * method isWhitelistedDisputeTag for contract DisputeModule
   *
   * @param request DisputeModuleIsWhitelistedDisputeTagRequest
   * @return Promise<DisputeModuleIsWhitelistedDisputeTagResponse>
   */_inherits(DisputeModuleReadOnlyClient,_DisputeModuleEventCl);return _createClass(DisputeModuleReadOnlyClient,[{key:"isWhitelistedDisputeTag",value:(function(){var _isWhitelistedDisputeTag=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(request){var result;return _regeneratorRuntime().wrap(function _callee28$(_context28){while(1)switch(_context28.prev=_context28.next){case 0:_context28.next=2;return this.rpcClient.readContract({abi:disputeModuleAbi,address:this.address,functionName:"isWhitelistedDisputeTag",args:[request.tag]});case 2:result=_context28.sent;return _context28.abrupt("return",{allowed:result});case 4:case"end":return _context28.stop();}},_callee28,this);}));function isWhitelistedDisputeTag(_x19){return _isWhitelistedDisputeTag.apply(this,arguments);}return isWhitelistedDisputeTag;}())}]);}(DisputeModuleEventClient);/**
 * contract DisputeModule write method
 */var DisputeModuleClient=/*#__PURE__*/function(_DisputeModuleReadOnl){function DisputeModuleClient(rpcClient,wallet,address){var _this3;_classCallCheck(this,DisputeModuleClient);_this3=_callSuper(this,DisputeModuleClient,[rpcClient,address]);_this3.wallet=wallet;return _this3;}/**
   * method cancelDispute for contract DisputeModule
   *
   * @param request DisputeModuleCancelDisputeRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(DisputeModuleClient,_DisputeModuleReadOnl);return _createClass(DisputeModuleClient,[{key:"cancelDispute",value:(function(){var _cancelDispute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29(request){var _yield$this$rpcClient16,call;return _regeneratorRuntime().wrap(function _callee29$(_context29){while(1)switch(_context29.prev=_context29.next){case 0:_context29.next=2;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"cancelDispute",account:this.wallet.account,args:[request.disputeId,request.data]});case 2:_yield$this$rpcClient16=_context29.sent;call=_yield$this$rpcClient16.request;_context29.next=6;return this.wallet.writeContract(call);case 6:return _context29.abrupt("return",_context29.sent);case 7:case"end":return _context29.stop();}},_callee29,this);}));function cancelDispute(_x20){return _cancelDispute.apply(this,arguments);}return cancelDispute;}()/**
   * method cancelDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleCancelDisputeRequest
   * @return EncodedTxData
   */)},{key:"cancelDisputeEncode",value:function cancelDisputeEncode(request){return {to:this.address,data:encodeFunctionData({abi:disputeModuleAbi,functionName:"cancelDispute",args:[request.disputeId,request.data]})};}/**
   * method raiseDispute for contract DisputeModule
   *
   * @param request DisputeModuleRaiseDisputeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"raiseDispute",value:(function(){var _raiseDispute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(request){var _yield$this$rpcClient17,call;return _regeneratorRuntime().wrap(function _callee30$(_context30){while(1)switch(_context30.prev=_context30.next){case 0:_context30.next=2;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"raiseDispute",account:this.wallet.account,args:[request.targetIpId,request.disputeEvidenceHash,request.targetTag,request.data]});case 2:_yield$this$rpcClient17=_context30.sent;call=_yield$this$rpcClient17.request;_context30.next=6;return this.wallet.writeContract(call);case 6:return _context30.abrupt("return",_context30.sent);case 7:case"end":return _context30.stop();}},_callee30,this);}));function raiseDispute(_x21){return _raiseDispute.apply(this,arguments);}return raiseDispute;}()/**
   * method raiseDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleRaiseDisputeRequest
   * @return EncodedTxData
   */)},{key:"raiseDisputeEncode",value:function raiseDisputeEncode(request){return {to:this.address,data:encodeFunctionData({abi:disputeModuleAbi,functionName:"raiseDispute",args:[request.targetIpId,request.disputeEvidenceHash,request.targetTag,request.data]})};}/**
   * method resolveDispute for contract DisputeModule
   *
   * @param request DisputeModuleResolveDisputeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"resolveDispute",value:(function(){var _resolveDispute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31(request){var _yield$this$rpcClient18,call;return _regeneratorRuntime().wrap(function _callee31$(_context31){while(1)switch(_context31.prev=_context31.next){case 0:_context31.next=2;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"resolveDispute",account:this.wallet.account,args:[request.disputeId,request.data]});case 2:_yield$this$rpcClient18=_context31.sent;call=_yield$this$rpcClient18.request;_context31.next=6;return this.wallet.writeContract(call);case 6:return _context31.abrupt("return",_context31.sent);case 7:case"end":return _context31.stop();}},_callee31,this);}));function resolveDispute(_x22){return _resolveDispute.apply(this,arguments);}return resolveDispute;}()/**
   * method resolveDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleResolveDisputeRequest
   * @return EncodedTxData
   */)},{key:"resolveDisputeEncode",value:function resolveDisputeEncode(request){return {to:this.address,data:encodeFunctionData({abi:disputeModuleAbi,functionName:"resolveDispute",args:[request.disputeId,request.data]})};}}]);}(DisputeModuleReadOnlyClient);// Contract EvenSplitGroupPool =============================================================
/**
 * GroupingModuleAddedIpToGroupEvent
 *
 * @param groupId address
 * @param ipIds address[]
 */ /**
 * GroupingModuleAuthorityUpdatedEvent
 *
 * @param authority address
 */ /**
 * GroupingModuleClaimedRewardEvent
 *
 * @param groupId address
 * @param token address
 * @param ipId address[]
 * @param amount uint256[]
 */ /**
 * GroupingModuleCollectedRoyaltiesToGroupPoolEvent
 *
 * @param groupId address
 * @param token address
 * @param pool address
 * @param amount uint256
 */ /**
 * GroupingModuleIpGroupRegisteredEvent
 *
 * @param groupId address
 * @param groupPool address
 */ /**
 * GroupingModuleInitializedEvent
 *
 * @param version uint64
 */ /**
 * GroupingModulePausedEvent
 *
 * @param account address
 */ /**
 * GroupingModuleRemovedIpFromGroupEvent
 *
 * @param groupId address
 * @param ipIds address[]
 */ /**
 * GroupingModuleUnpausedEvent
 *
 * @param account address
 */ /**
 * GroupingModuleUpgradedEvent
 *
 * @param implementation address
 */ /**
 * GroupingModuleGetClaimableRewardRequest
 *
 * @param groupId address
 * @param token address
 * @param ipIds address[]
 */ /**
 * GroupingModuleSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 */ /**
 * GroupingModuleProtocolPausableInitRequest
 *
 * @param accessManager address
 */ /**
 * GroupingModuleAddIpRequest
 *
 * @param groupIpId address
 * @param ipIds address[]
 * @param maxAllowedRewardShare uint256
 */ /**
 * GroupingModuleClaimRewardRequest
 *
 * @param groupId address
 * @param token address
 * @param ipIds address[]
 */ /**
 * GroupingModuleCollectRoyaltiesRequest
 *
 * @param groupId address
 * @param token address
 */ /**
 * GroupingModuleInitializeRequest
 *
 * @param accessManager address
 */ /**
 * GroupingModuleRegisterGroupRequest
 *
 * @param groupPool address
 */ /**
 * GroupingModuleRemoveIpRequest
 *
 * @param groupIpId address
 * @param ipIds address[]
 */ /**
 * GroupingModuleSetAuthorityRequest
 *
 * @param newAuthority address
 */ /**
 * GroupingModuleUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */ /**
 * GroupingModuleWhitelistGroupRewardPoolRequest
 *
 * @param rewardPool address
 * @param allowed bool
 */ /**
 * contract GroupingModule event
 */var GroupingModuleEventClient=/*#__PURE__*/function(){function GroupingModuleEventClient(rpcClient,address){var _rpcClient$chain7;_classCallCheck(this,GroupingModuleEventClient);this.address=address||getAddress(groupingModuleAddress,(_rpcClient$chain7=rpcClient.chain)===null||_rpcClient$chain7===void 0?void 0:_rpcClient$chain7.id);this.rpcClient=rpcClient;}/**
   * event AddedIpToGroup for contract GroupingModule
   */return _createClass(GroupingModuleEventClient,[{key:"watchAddedIpToGroupEvent",value:function watchAddedIpToGroupEvent(_onLogs16){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"AddedIpToGroup",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs16(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AddedIpToGroup for contract GroupingModule
   */},{key:"parseTxAddedIpToGroupEvent",value:function parseTxAddedIpToGroupEvent(txReceipt){var targetLogs=[];var _iterator16=_createForOfIteratorHelper(txReceipt.logs),_step16;try{for(_iterator16.s();!(_step16=_iterator16.n()).done;){var log=_step16.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"AddedIpToGroup",data:log.data,topics:log.topics});if(event.eventName==="AddedIpToGroup"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator16.e(err);}finally{_iterator16.f();}return targetLogs;}/**
   * event AuthorityUpdated for contract GroupingModule
   */},{key:"watchAuthorityUpdatedEvent",value:function watchAuthorityUpdatedEvent(_onLogs17){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"AuthorityUpdated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs17(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AuthorityUpdated for contract GroupingModule
   */},{key:"parseTxAuthorityUpdatedEvent",value:function parseTxAuthorityUpdatedEvent(txReceipt){var targetLogs=[];var _iterator17=_createForOfIteratorHelper(txReceipt.logs),_step17;try{for(_iterator17.s();!(_step17=_iterator17.n()).done;){var log=_step17.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"AuthorityUpdated",data:log.data,topics:log.topics});if(event.eventName==="AuthorityUpdated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator17.e(err);}finally{_iterator17.f();}return targetLogs;}/**
   * event ClaimedReward for contract GroupingModule
   */},{key:"watchClaimedRewardEvent",value:function watchClaimedRewardEvent(_onLogs18){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"ClaimedReward",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs18(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event ClaimedReward for contract GroupingModule
   */},{key:"parseTxClaimedRewardEvent",value:function parseTxClaimedRewardEvent(txReceipt){var targetLogs=[];var _iterator18=_createForOfIteratorHelper(txReceipt.logs),_step18;try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){var log=_step18.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"ClaimedReward",data:log.data,topics:log.topics});if(event.eventName==="ClaimedReward"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}return targetLogs;}/**
   * event CollectedRoyaltiesToGroupPool for contract GroupingModule
   */},{key:"watchCollectedRoyaltiesToGroupPoolEvent",value:function watchCollectedRoyaltiesToGroupPoolEvent(_onLogs19){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"CollectedRoyaltiesToGroupPool",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs19(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event CollectedRoyaltiesToGroupPool for contract GroupingModule
   */},{key:"parseTxCollectedRoyaltiesToGroupPoolEvent",value:function parseTxCollectedRoyaltiesToGroupPoolEvent(txReceipt){var targetLogs=[];var _iterator19=_createForOfIteratorHelper(txReceipt.logs),_step19;try{for(_iterator19.s();!(_step19=_iterator19.n()).done;){var log=_step19.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"CollectedRoyaltiesToGroupPool",data:log.data,topics:log.topics});if(event.eventName==="CollectedRoyaltiesToGroupPool"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}return targetLogs;}/**
   * event IPGroupRegistered for contract GroupingModule
   */},{key:"watchIpGroupRegisteredEvent",value:function watchIpGroupRegisteredEvent(_onLogs20){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"IPGroupRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs20(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPGroupRegistered for contract GroupingModule
   */},{key:"parseTxIpGroupRegisteredEvent",value:function parseTxIpGroupRegisteredEvent(txReceipt){var targetLogs=[];var _iterator20=_createForOfIteratorHelper(txReceipt.logs),_step20;try{for(_iterator20.s();!(_step20=_iterator20.n()).done;){var log=_step20.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"IPGroupRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPGroupRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator20.e(err);}finally{_iterator20.f();}return targetLogs;}/**
   * event Initialized for contract GroupingModule
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs21){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs21(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract GroupingModule
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator21=_createForOfIteratorHelper(txReceipt.logs),_step21;try{for(_iterator21.s();!(_step21=_iterator21.n()).done;){var log=_step21.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator21.e(err);}finally{_iterator21.f();}return targetLogs;}/**
   * event Paused for contract GroupingModule
   */},{key:"watchPausedEvent",value:function watchPausedEvent(_onLogs22){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"Paused",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs22(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Paused for contract GroupingModule
   */},{key:"parseTxPausedEvent",value:function parseTxPausedEvent(txReceipt){var targetLogs=[];var _iterator22=_createForOfIteratorHelper(txReceipt.logs),_step22;try{for(_iterator22.s();!(_step22=_iterator22.n()).done;){var log=_step22.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"Paused",data:log.data,topics:log.topics});if(event.eventName==="Paused"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator22.e(err);}finally{_iterator22.f();}return targetLogs;}/**
   * event RemovedIpFromGroup for contract GroupingModule
   */},{key:"watchRemovedIpFromGroupEvent",value:function watchRemovedIpFromGroupEvent(_onLogs23){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"RemovedIpFromGroup",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs23(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RemovedIpFromGroup for contract GroupingModule
   */},{key:"parseTxRemovedIpFromGroupEvent",value:function parseTxRemovedIpFromGroupEvent(txReceipt){var targetLogs=[];var _iterator23=_createForOfIteratorHelper(txReceipt.logs),_step23;try{for(_iterator23.s();!(_step23=_iterator23.n()).done;){var log=_step23.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"RemovedIpFromGroup",data:log.data,topics:log.topics});if(event.eventName==="RemovedIpFromGroup"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator23.e(err);}finally{_iterator23.f();}return targetLogs;}/**
   * event Unpaused for contract GroupingModule
   */},{key:"watchUnpausedEvent",value:function watchUnpausedEvent(_onLogs24){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"Unpaused",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs24(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Unpaused for contract GroupingModule
   */},{key:"parseTxUnpausedEvent",value:function parseTxUnpausedEvent(txReceipt){var targetLogs=[];var _iterator24=_createForOfIteratorHelper(txReceipt.logs),_step24;try{for(_iterator24.s();!(_step24=_iterator24.n()).done;){var log=_step24.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"Unpaused",data:log.data,topics:log.topics});if(event.eventName==="Unpaused"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator24.e(err);}finally{_iterator24.f();}return targetLogs;}/**
   * event Upgraded for contract GroupingModule
   */},{key:"watchUpgradedEvent",value:function watchUpgradedEvent(_onLogs25){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"Upgraded",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs25(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Upgraded for contract GroupingModule
   */},{key:"parseTxUpgradedEvent",value:function parseTxUpgradedEvent(txReceipt){var targetLogs=[];var _iterator25=_createForOfIteratorHelper(txReceipt.logs),_step25;try{for(_iterator25.s();!(_step25=_iterator25.n()).done;){var log=_step25.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"Upgraded",data:log.data,topics:log.topics});if(event.eventName==="Upgraded"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator25.e(err);}finally{_iterator25.f();}return targetLogs;}}]);}();/**
 * contract GroupingModule readonly method
 */var GroupingModuleReadOnlyClient=/*#__PURE__*/function(_GroupingModuleEventC){function GroupingModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,GroupingModuleReadOnlyClient);return _callSuper(this,GroupingModuleReadOnlyClient,[rpcClient,address]);}/**
   * method ACCESS_CONTROLLER for contract GroupingModule
   *
   * @param request GroupingModuleAccessControllerRequest
   * @return Promise<GroupingModuleAccessControllerResponse>
   */_inherits(GroupingModuleReadOnlyClient,_GroupingModuleEventC);return _createClass(GroupingModuleReadOnlyClient,[{key:"accessController",value:(function(){var _accessController2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee58(){return _regeneratorRuntime().wrap(function _callee58$(_context58){while(1)switch(_context58.prev=_context58.next){case 0:_context58.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"ACCESS_CONTROLLER"});case 2:return _context58.abrupt("return",_context58.sent);case 3:case"end":return _context58.stop();}},_callee58,this);}));function accessController(){return _accessController2.apply(this,arguments);}return accessController;}()/**
   * method DISPUTE_MODULE for contract GroupingModule
   *
   * @param request GroupingModuleDisputeModuleRequest
   * @return Promise<GroupingModuleDisputeModuleResponse>
   */)},{key:"disputeModule",value:(function(){var _disputeModule=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee59(){return _regeneratorRuntime().wrap(function _callee59$(_context59){while(1)switch(_context59.prev=_context59.next){case 0:_context59.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"DISPUTE_MODULE"});case 2:return _context59.abrupt("return",_context59.sent);case 3:case"end":return _context59.stop();}},_callee59,this);}));function disputeModule(){return _disputeModule.apply(this,arguments);}return disputeModule;}()/**
   * method GROUP_IP_ASSET_REGISTRY for contract GroupingModule
   *
   * @param request GroupingModuleGroupIpAssetRegistryRequest
   * @return Promise<GroupingModuleGroupIpAssetRegistryResponse>
   */)},{key:"groupIpAssetRegistry",value:(function(){var _groupIpAssetRegistry2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee60(){return _regeneratorRuntime().wrap(function _callee60$(_context60){while(1)switch(_context60.prev=_context60.next){case 0:_context60.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"GROUP_IP_ASSET_REGISTRY"});case 2:return _context60.abrupt("return",_context60.sent);case 3:case"end":return _context60.stop();}},_callee60,this);}));function groupIpAssetRegistry(){return _groupIpAssetRegistry2.apply(this,arguments);}return groupIpAssetRegistry;}()/**
   * method GROUP_NFT for contract GroupingModule
   *
   * @param request GroupingModuleGroupNftRequest
   * @return Promise<GroupingModuleGroupNftResponse>
   */)},{key:"groupNft",value:(function(){var _groupNft=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee61(){return _regeneratorRuntime().wrap(function _callee61$(_context61){while(1)switch(_context61.prev=_context61.next){case 0:_context61.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"GROUP_NFT"});case 2:return _context61.abrupt("return",_context61.sent);case 3:case"end":return _context61.stop();}},_callee61,this);}));function groupNft(){return _groupNft.apply(this,arguments);}return groupNft;}()/**
   * method IP_ASSET_REGISTRY for contract GroupingModule
   *
   * @param request GroupingModuleIpAssetRegistryRequest
   * @return Promise<GroupingModuleIpAssetRegistryResponse>
   */)},{key:"ipAssetRegistry",value:(function(){var _ipAssetRegistry2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee62(){return _regeneratorRuntime().wrap(function _callee62$(_context62){while(1)switch(_context62.prev=_context62.next){case 0:_context62.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"IP_ASSET_REGISTRY"});case 2:return _context62.abrupt("return",_context62.sent);case 3:case"end":return _context62.stop();}},_callee62,this);}));function ipAssetRegistry(){return _ipAssetRegistry2.apply(this,arguments);}return ipAssetRegistry;}()/**
   * method LICENSE_REGISTRY for contract GroupingModule
   *
   * @param request GroupingModuleLicenseRegistryRequest
   * @return Promise<GroupingModuleLicenseRegistryResponse>
   */)},{key:"licenseRegistry",value:(function(){var _licenseRegistry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee63(){return _regeneratorRuntime().wrap(function _callee63$(_context63){while(1)switch(_context63.prev=_context63.next){case 0:_context63.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"LICENSE_REGISTRY"});case 2:return _context63.abrupt("return",_context63.sent);case 3:case"end":return _context63.stop();}},_callee63,this);}));function licenseRegistry(){return _licenseRegistry.apply(this,arguments);}return licenseRegistry;}()/**
   * method LICENSE_TOKEN for contract GroupingModule
   *
   * @param request GroupingModuleLicenseTokenRequest
   * @return Promise<GroupingModuleLicenseTokenResponse>
   */)},{key:"licenseToken",value:(function(){var _licenseToken=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee64(){return _regeneratorRuntime().wrap(function _callee64$(_context64){while(1)switch(_context64.prev=_context64.next){case 0:_context64.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"LICENSE_TOKEN"});case 2:return _context64.abrupt("return",_context64.sent);case 3:case"end":return _context64.stop();}},_callee64,this);}));function licenseToken(){return _licenseToken.apply(this,arguments);}return licenseToken;}()/**
   * method ROYALTY_MODULE for contract GroupingModule
   *
   * @param request GroupingModuleRoyaltyModuleRequest
   * @return Promise<GroupingModuleRoyaltyModuleResponse>
   */)},{key:"royaltyModule",value:(function(){var _royaltyModule2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee65(){return _regeneratorRuntime().wrap(function _callee65$(_context65){while(1)switch(_context65.prev=_context65.next){case 0:_context65.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"ROYALTY_MODULE"});case 2:return _context65.abrupt("return",_context65.sent);case 3:case"end":return _context65.stop();}},_callee65,this);}));function royaltyModule(){return _royaltyModule2.apply(this,arguments);}return royaltyModule;}()/**
   * method UPGRADE_INTERFACE_VERSION for contract GroupingModule
   *
   * @param request GroupingModuleUpgradeInterfaceVersionRequest
   * @return Promise<GroupingModuleUpgradeInterfaceVersionResponse>
   */)},{key:"upgradeInterfaceVersion",value:(function(){var _upgradeInterfaceVersion3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee66(){return _regeneratorRuntime().wrap(function _callee66$(_context66){while(1)switch(_context66.prev=_context66.next){case 0:_context66.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"UPGRADE_INTERFACE_VERSION"});case 2:return _context66.abrupt("return",_context66.sent);case 3:case"end":return _context66.stop();}},_callee66,this);}));function upgradeInterfaceVersion(){return _upgradeInterfaceVersion3.apply(this,arguments);}return upgradeInterfaceVersion;}()/**
   * method authority for contract GroupingModule
   *
   * @param request GroupingModuleAuthorityRequest
   * @return Promise<GroupingModuleAuthorityResponse>
   */)},{key:"authority",value:(function(){var _authority3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee67(){return _regeneratorRuntime().wrap(function _callee67$(_context67){while(1)switch(_context67.prev=_context67.next){case 0:_context67.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"authority"});case 2:return _context67.abrupt("return",_context67.sent);case 3:case"end":return _context67.stop();}},_callee67,this);}));function authority(){return _authority3.apply(this,arguments);}return authority;}()/**
   * method getClaimableReward for contract GroupingModule
   *
   * @param request GroupingModuleGetClaimableRewardRequest
   * @return Promise<GroupingModuleGetClaimableRewardResponse>
   */)},{key:"getClaimableReward",value:(function(){var _getClaimableReward=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee68(request){return _regeneratorRuntime().wrap(function _callee68$(_context68){while(1)switch(_context68.prev=_context68.next){case 0:_context68.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"getClaimableReward",args:[request.groupId,request.token,request.ipIds]});case 2:return _context68.abrupt("return",_context68.sent);case 3:case"end":return _context68.stop();}},_callee68,this);}));function getClaimableReward(_x38){return _getClaimableReward.apply(this,arguments);}return getClaimableReward;}()/**
   * method isConsumingScheduledOp for contract GroupingModule
   *
   * @param request GroupingModuleIsConsumingScheduledOpRequest
   * @return Promise<GroupingModuleIsConsumingScheduledOpResponse>
   */)},{key:"isConsumingScheduledOp",value:(function(){var _isConsumingScheduledOp3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee69(){return _regeneratorRuntime().wrap(function _callee69$(_context69){while(1)switch(_context69.prev=_context69.next){case 0:_context69.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"isConsumingScheduledOp"});case 2:return _context69.abrupt("return",_context69.sent);case 3:case"end":return _context69.stop();}},_callee69,this);}));function isConsumingScheduledOp(){return _isConsumingScheduledOp3.apply(this,arguments);}return isConsumingScheduledOp;}()/**
   * method name for contract GroupingModule
   *
   * @param request GroupingModuleNameRequest
   * @return Promise<GroupingModuleNameResponse>
   */)},{key:"name",value:(function(){var _name2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee70(){return _regeneratorRuntime().wrap(function _callee70$(_context70){while(1)switch(_context70.prev=_context70.next){case 0:_context70.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"name"});case 2:return _context70.abrupt("return",_context70.sent);case 3:case"end":return _context70.stop();}},_callee70,this);}));function name(){return _name2.apply(this,arguments);}return name;}()/**
   * method paused for contract GroupingModule
   *
   * @param request GroupingModulePausedRequest
   * @return Promise<GroupingModulePausedResponse>
   */)},{key:"paused",value:(function(){var _paused2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee71(){return _regeneratorRuntime().wrap(function _callee71$(_context71){while(1)switch(_context71.prev=_context71.next){case 0:_context71.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"paused"});case 2:return _context71.abrupt("return",_context71.sent);case 3:case"end":return _context71.stop();}},_callee71,this);}));function paused(){return _paused2.apply(this,arguments);}return paused;}()/**
   * method proxiableUUID for contract GroupingModule
   *
   * @param request GroupingModuleProxiableUuidRequest
   * @return Promise<GroupingModuleProxiableUuidResponse>
   */)},{key:"proxiableUuid",value:(function(){var _proxiableUuid3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee72(){return _regeneratorRuntime().wrap(function _callee72$(_context72){while(1)switch(_context72.prev=_context72.next){case 0:_context72.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"proxiableUUID"});case 2:return _context72.abrupt("return",_context72.sent);case 3:case"end":return _context72.stop();}},_callee72,this);}));function proxiableUuid(){return _proxiableUuid3.apply(this,arguments);}return proxiableUuid;}()/**
   * method supportsInterface for contract GroupingModule
   *
   * @param request GroupingModuleSupportsInterfaceRequest
   * @return Promise<GroupingModuleSupportsInterfaceResponse>
   */)},{key:"supportsInterface",value:(function(){var _supportsInterface2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee73(request){return _regeneratorRuntime().wrap(function _callee73$(_context73){while(1)switch(_context73.prev=_context73.next){case 0:_context73.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"supportsInterface",args:[request.interfaceId]});case 2:return _context73.abrupt("return",_context73.sent);case 3:case"end":return _context73.stop();}},_callee73,this);}));function supportsInterface(_x39){return _supportsInterface2.apply(this,arguments);}return supportsInterface;}())}]);}(GroupingModuleEventClient);/**
 * contract GroupingModule write method
 */var GroupingModuleClient=/*#__PURE__*/function(_GroupingModuleReadOn){function GroupingModuleClient(rpcClient,wallet,address){var _this5;_classCallCheck(this,GroupingModuleClient);_this5=_callSuper(this,GroupingModuleClient,[rpcClient,address]);_this5.wallet=wallet;return _this5;}/**
   * method __ProtocolPausable_init for contract GroupingModule
   *
   * @param request GroupingModuleProtocolPausableInitRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(GroupingModuleClient,_GroupingModuleReadOn);return _createClass(GroupingModuleClient,[{key:"protocolPausableInit",value:(function(){var _protocolPausableInit2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee74(request){var _yield$this$rpcClient29,call;return _regeneratorRuntime().wrap(function _callee74$(_context74){while(1)switch(_context74.prev=_context74.next){case 0:_context74.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"__ProtocolPausable_init",account:this.wallet.account,args:[request.accessManager]});case 2:_yield$this$rpcClient29=_context74.sent;call=_yield$this$rpcClient29.request;_context74.next=6;return this.wallet.writeContract(call);case 6:return _context74.abrupt("return",_context74.sent);case 7:case"end":return _context74.stop();}},_callee74,this);}));function protocolPausableInit(_x40){return _protocolPausableInit2.apply(this,arguments);}return protocolPausableInit;}()/**
   * method __ProtocolPausable_init for contract GroupingModule with only encode
   *
   * @param request GroupingModuleProtocolPausableInitRequest
   * @return EncodedTxData
   */)},{key:"protocolPausableInitEncode",value:function protocolPausableInitEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"__ProtocolPausable_init",args:[request.accessManager]})};}/**
   * method addIp for contract GroupingModule
   *
   * @param request GroupingModuleAddIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"addIp",value:(function(){var _addIp2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee75(request){var _yield$this$rpcClient30,call;return _regeneratorRuntime().wrap(function _callee75$(_context75){while(1)switch(_context75.prev=_context75.next){case 0:_context75.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"addIp",account:this.wallet.account,args:[request.groupIpId,request.ipIds,request.maxAllowedRewardShare]});case 2:_yield$this$rpcClient30=_context75.sent;call=_yield$this$rpcClient30.request;_context75.next=6;return this.wallet.writeContract(call);case 6:return _context75.abrupt("return",_context75.sent);case 7:case"end":return _context75.stop();}},_callee75,this);}));function addIp(_x41){return _addIp2.apply(this,arguments);}return addIp;}()/**
   * method addIp for contract GroupingModule with only encode
   *
   * @param request GroupingModuleAddIpRequest
   * @return EncodedTxData
   */)},{key:"addIpEncode",value:function addIpEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"addIp",args:[request.groupIpId,request.ipIds,request.maxAllowedRewardShare]})};}/**
   * method claimReward for contract GroupingModule
   *
   * @param request GroupingModuleClaimRewardRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"claimReward",value:(function(){var _claimReward=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee76(request){var _yield$this$rpcClient31,call;return _regeneratorRuntime().wrap(function _callee76$(_context76){while(1)switch(_context76.prev=_context76.next){case 0:_context76.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"claimReward",account:this.wallet.account,args:[request.groupId,request.token,request.ipIds]});case 2:_yield$this$rpcClient31=_context76.sent;call=_yield$this$rpcClient31.request;_context76.next=6;return this.wallet.writeContract(call);case 6:return _context76.abrupt("return",_context76.sent);case 7:case"end":return _context76.stop();}},_callee76,this);}));function claimReward(_x42){return _claimReward.apply(this,arguments);}return claimReward;}()/**
   * method claimReward for contract GroupingModule with only encode
   *
   * @param request GroupingModuleClaimRewardRequest
   * @return EncodedTxData
   */)},{key:"claimRewardEncode",value:function claimRewardEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"claimReward",args:[request.groupId,request.token,request.ipIds]})};}/**
   * method collectRoyalties for contract GroupingModule
   *
   * @param request GroupingModuleCollectRoyaltiesRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"collectRoyalties",value:(function(){var _collectRoyalties=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee77(request){var _yield$this$rpcClient32,call;return _regeneratorRuntime().wrap(function _callee77$(_context77){while(1)switch(_context77.prev=_context77.next){case 0:_context77.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"collectRoyalties",account:this.wallet.account,args:[request.groupId,request.token]});case 2:_yield$this$rpcClient32=_context77.sent;call=_yield$this$rpcClient32.request;_context77.next=6;return this.wallet.writeContract(call);case 6:return _context77.abrupt("return",_context77.sent);case 7:case"end":return _context77.stop();}},_callee77,this);}));function collectRoyalties(_x43){return _collectRoyalties.apply(this,arguments);}return collectRoyalties;}()/**
   * method collectRoyalties for contract GroupingModule with only encode
   *
   * @param request GroupingModuleCollectRoyaltiesRequest
   * @return EncodedTxData
   */)},{key:"collectRoyaltiesEncode",value:function collectRoyaltiesEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"collectRoyalties",args:[request.groupId,request.token]})};}/**
   * method initialize for contract GroupingModule
   *
   * @param request GroupingModuleInitializeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"initialize",value:(function(){var _initialize3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee78(request){var _yield$this$rpcClient33,call;return _regeneratorRuntime().wrap(function _callee78$(_context78){while(1)switch(_context78.prev=_context78.next){case 0:_context78.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"initialize",account:this.wallet.account,args:[request.accessManager]});case 2:_yield$this$rpcClient33=_context78.sent;call=_yield$this$rpcClient33.request;_context78.next=6;return this.wallet.writeContract(call);case 6:return _context78.abrupt("return",_context78.sent);case 7:case"end":return _context78.stop();}},_callee78,this);}));function initialize(_x44){return _initialize3.apply(this,arguments);}return initialize;}()/**
   * method initialize for contract GroupingModule with only encode
   *
   * @param request GroupingModuleInitializeRequest
   * @return EncodedTxData
   */)},{key:"initializeEncode",value:function initializeEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"initialize",args:[request.accessManager]})};}/**
   * method pause for contract GroupingModule
   *
   * @param request GroupingModulePauseRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"pause",value:(function(){var _pause2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee79(){var _yield$this$rpcClient34,call;return _regeneratorRuntime().wrap(function _callee79$(_context79){while(1)switch(_context79.prev=_context79.next){case 0:_context79.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"pause",account:this.wallet.account});case 2:_yield$this$rpcClient34=_context79.sent;call=_yield$this$rpcClient34.request;_context79.next=6;return this.wallet.writeContract(call);case 6:return _context79.abrupt("return",_context79.sent);case 7:case"end":return _context79.stop();}},_callee79,this);}));function pause(){return _pause2.apply(this,arguments);}return pause;}()/**
   * method pause for contract GroupingModule with only encode
   *
   * @param request GroupingModulePauseRequest
   * @return EncodedTxData
   */)},{key:"pauseEncode",value:function pauseEncode(){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"pause"})};}/**
   * method registerGroup for contract GroupingModule
   *
   * @param request GroupingModuleRegisterGroupRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroup",value:(function(){var _registerGroup=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee80(request){var _yield$this$rpcClient35,call;return _regeneratorRuntime().wrap(function _callee80$(_context80){while(1)switch(_context80.prev=_context80.next){case 0:_context80.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"registerGroup",account:this.wallet.account,args:[request.groupPool]});case 2:_yield$this$rpcClient35=_context80.sent;call=_yield$this$rpcClient35.request;_context80.next=6;return this.wallet.writeContract(call);case 6:return _context80.abrupt("return",_context80.sent);case 7:case"end":return _context80.stop();}},_callee80,this);}));function registerGroup(_x45){return _registerGroup.apply(this,arguments);}return registerGroup;}()/**
   * method registerGroup for contract GroupingModule with only encode
   *
   * @param request GroupingModuleRegisterGroupRequest
   * @return EncodedTxData
   */)},{key:"registerGroupEncode",value:function registerGroupEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"registerGroup",args:[request.groupPool]})};}/**
   * method removeIp for contract GroupingModule
   *
   * @param request GroupingModuleRemoveIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"removeIp",value:(function(){var _removeIp2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee81(request){var _yield$this$rpcClient36,call;return _regeneratorRuntime().wrap(function _callee81$(_context81){while(1)switch(_context81.prev=_context81.next){case 0:_context81.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"removeIp",account:this.wallet.account,args:[request.groupIpId,request.ipIds]});case 2:_yield$this$rpcClient36=_context81.sent;call=_yield$this$rpcClient36.request;_context81.next=6;return this.wallet.writeContract(call);case 6:return _context81.abrupt("return",_context81.sent);case 7:case"end":return _context81.stop();}},_callee81,this);}));function removeIp(_x46){return _removeIp2.apply(this,arguments);}return removeIp;}()/**
   * method removeIp for contract GroupingModule with only encode
   *
   * @param request GroupingModuleRemoveIpRequest
   * @return EncodedTxData
   */)},{key:"removeIpEncode",value:function removeIpEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"removeIp",args:[request.groupIpId,request.ipIds]})};}/**
   * method setAuthority for contract GroupingModule
   *
   * @param request GroupingModuleSetAuthorityRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAuthority",value:(function(){var _setAuthority3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee82(request){var _yield$this$rpcClient37,call;return _regeneratorRuntime().wrap(function _callee82$(_context82){while(1)switch(_context82.prev=_context82.next){case 0:_context82.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"setAuthority",account:this.wallet.account,args:[request.newAuthority]});case 2:_yield$this$rpcClient37=_context82.sent;call=_yield$this$rpcClient37.request;_context82.next=6;return this.wallet.writeContract(call);case 6:return _context82.abrupt("return",_context82.sent);case 7:case"end":return _context82.stop();}},_callee82,this);}));function setAuthority(_x47){return _setAuthority3.apply(this,arguments);}return setAuthority;}()/**
   * method setAuthority for contract GroupingModule with only encode
   *
   * @param request GroupingModuleSetAuthorityRequest
   * @return EncodedTxData
   */)},{key:"setAuthorityEncode",value:function setAuthorityEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"setAuthority",args:[request.newAuthority]})};}/**
   * method unpause for contract GroupingModule
   *
   * @param request GroupingModuleUnpauseRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"unpause",value:(function(){var _unpause2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee83(){var _yield$this$rpcClient38,call;return _regeneratorRuntime().wrap(function _callee83$(_context83){while(1)switch(_context83.prev=_context83.next){case 0:_context83.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"unpause",account:this.wallet.account});case 2:_yield$this$rpcClient38=_context83.sent;call=_yield$this$rpcClient38.request;_context83.next=6;return this.wallet.writeContract(call);case 6:return _context83.abrupt("return",_context83.sent);case 7:case"end":return _context83.stop();}},_callee83,this);}));function unpause(){return _unpause2.apply(this,arguments);}return unpause;}()/**
   * method unpause for contract GroupingModule with only encode
   *
   * @param request GroupingModuleUnpauseRequest
   * @return EncodedTxData
   */)},{key:"unpauseEncode",value:function unpauseEncode(){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"unpause"})};}/**
   * method upgradeToAndCall for contract GroupingModule
   *
   * @param request GroupingModuleUpgradeToAndCallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"upgradeToAndCall",value:(function(){var _upgradeToAndCall3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee84(request){var _yield$this$rpcClient39,call;return _regeneratorRuntime().wrap(function _callee84$(_context84){while(1)switch(_context84.prev=_context84.next){case 0:_context84.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"upgradeToAndCall",account:this.wallet.account,args:[request.newImplementation,request.data]});case 2:_yield$this$rpcClient39=_context84.sent;call=_yield$this$rpcClient39.request;_context84.next=6;return this.wallet.writeContract(call);case 6:return _context84.abrupt("return",_context84.sent);case 7:case"end":return _context84.stop();}},_callee84,this);}));function upgradeToAndCall(_x48){return _upgradeToAndCall3.apply(this,arguments);}return upgradeToAndCall;}()/**
   * method upgradeToAndCall for contract GroupingModule with only encode
   *
   * @param request GroupingModuleUpgradeToAndCallRequest
   * @return EncodedTxData
   */)},{key:"upgradeToAndCallEncode",value:function upgradeToAndCallEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"upgradeToAndCall",args:[request.newImplementation,request.data]})};}/**
   * method whitelistGroupRewardPool for contract GroupingModule
   *
   * @param request GroupingModuleWhitelistGroupRewardPoolRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"whitelistGroupRewardPool",value:(function(){var _whitelistGroupRewardPool=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee85(request){var _yield$this$rpcClient40,call;return _regeneratorRuntime().wrap(function _callee85$(_context85){while(1)switch(_context85.prev=_context85.next){case 0:_context85.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"whitelistGroupRewardPool",account:this.wallet.account,args:[request.rewardPool,request.allowed]});case 2:_yield$this$rpcClient40=_context85.sent;call=_yield$this$rpcClient40.request;_context85.next=6;return this.wallet.writeContract(call);case 6:return _context85.abrupt("return",_context85.sent);case 7:case"end":return _context85.stop();}},_callee85,this);}));function whitelistGroupRewardPool(_x49){return _whitelistGroupRewardPool.apply(this,arguments);}return whitelistGroupRewardPool;}()/**
   * method whitelistGroupRewardPool for contract GroupingModule with only encode
   *
   * @param request GroupingModuleWhitelistGroupRewardPoolRequest
   * @return EncodedTxData
   */)},{key:"whitelistGroupRewardPoolEncode",value:function whitelistGroupRewardPoolEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"whitelistGroupRewardPool",args:[request.rewardPool,request.allowed]})};}}]);}(GroupingModuleReadOnlyClient);// Contract GroupingWorkflows =============================================================
/**
 * GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
 *
 * @param spgNftContract address
 * @param groupId address
 * @param recipient address
 * @param maxAllowedRewardShare uint256
 * @param licensesData tuple[]
 * @param ipMetadata tuple
 * @param sigAddToGroup tuple
 * @param allowDuplicates bool
 */ /**
 * GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
 *
 * @param groupPool address
 * @param licenseData tuple
 */ /**
 * GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
 *
 * @param groupPool address
 * @param ipIds address[]
 * @param maxAllowedRewardShare uint256
 * @param licenseData tuple
 */ /**
 * GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param groupId address
 * @param maxAllowedRewardShare uint256
 * @param licensesData tuple[]
 * @param ipMetadata tuple
 * @param sigMetadataAndAttachAndConfig tuple
 * @param sigAddToGroup tuple
 */ /**
 * contract GroupingWorkflows write method
 */var GroupingWorkflowsClient=/*#__PURE__*/function(){function GroupingWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain8;_classCallCheck(this,GroupingWorkflowsClient);this.address=address||getAddress(groupingWorkflowsAddress,(_rpcClient$chain8=rpcClient.chain)===null||_rpcClient$chain8===void 0?void 0:_rpcClient$chain8.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method mintAndRegisterIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(GroupingWorkflowsClient,[{key:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",value:(function(){var _mintAndRegisterIpAndAttachLicenseAndAddToGroup=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee86(request){var _yield$this$rpcClient41,call;return _regeneratorRuntime().wrap(function _callee86$(_context86){while(1)switch(_context86.prev=_context86.next){case 0:_context86.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",account:this.wallet.account,args:[request.spgNftContract,request.groupId,request.recipient,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigAddToGroup,request.allowDuplicates]});case 2:_yield$this$rpcClient41=_context86.sent;call=_yield$this$rpcClient41.request;_context86.next=6;return this.wallet.writeContract(call);case 6:return _context86.abrupt("return",_context86.sent);case 7:case"end":return _context86.stop();}},_callee86,this);}));function mintAndRegisterIpAndAttachLicenseAndAddToGroup(_x50){return _mintAndRegisterIpAndAttachLicenseAndAddToGroup.apply(this,arguments);}return mintAndRegisterIpAndAttachLicenseAndAddToGroup;}()/**
   * method mintAndRegisterIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode",value:function mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",args:[request.spgNftContract,request.groupId,request.recipient,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigAddToGroup,request.allowDuplicates]})};}/**
   * method registerGroupAndAttachLicense for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroupAndAttachLicense",value:(function(){var _registerGroupAndAttachLicense=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee87(request){var _yield$this$rpcClient42,call;return _regeneratorRuntime().wrap(function _callee87$(_context87){while(1)switch(_context87.prev=_context87.next){case 0:_context87.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerGroupAndAttachLicense",account:this.wallet.account,args:[request.groupPool,request.licenseData]});case 2:_yield$this$rpcClient42=_context87.sent;call=_yield$this$rpcClient42.request;_context87.next=6;return this.wallet.writeContract(call);case 6:return _context87.abrupt("return",_context87.sent);case 7:case"end":return _context87.stop();}},_callee87,this);}));function registerGroupAndAttachLicense(_x51){return _registerGroupAndAttachLicense.apply(this,arguments);}return registerGroupAndAttachLicense;}()/**
   * method registerGroupAndAttachLicense for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
   * @return EncodedTxData
   */)},{key:"registerGroupAndAttachLicenseEncode",value:function registerGroupAndAttachLicenseEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerGroupAndAttachLicense",args:[request.groupPool,request.licenseData]})};}/**
   * method registerGroupAndAttachLicenseAndAddIps for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroupAndAttachLicenseAndAddIps",value:(function(){var _registerGroupAndAttachLicenseAndAddIps=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee88(request){var _yield$this$rpcClient43,call;return _regeneratorRuntime().wrap(function _callee88$(_context88){while(1)switch(_context88.prev=_context88.next){case 0:_context88.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerGroupAndAttachLicenseAndAddIps",account:this.wallet.account,args:[request.groupPool,request.ipIds,request.maxAllowedRewardShare,request.licenseData]});case 2:_yield$this$rpcClient43=_context88.sent;call=_yield$this$rpcClient43.request;_context88.next=6;return this.wallet.writeContract(call);case 6:return _context88.abrupt("return",_context88.sent);case 7:case"end":return _context88.stop();}},_callee88,this);}));function registerGroupAndAttachLicenseAndAddIps(_x52){return _registerGroupAndAttachLicenseAndAddIps.apply(this,arguments);}return registerGroupAndAttachLicenseAndAddIps;}()/**
   * method registerGroupAndAttachLicenseAndAddIps for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
   * @return EncodedTxData
   */)},{key:"registerGroupAndAttachLicenseAndAddIpsEncode",value:function registerGroupAndAttachLicenseAndAddIpsEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerGroupAndAttachLicenseAndAddIps",args:[request.groupPool,request.ipIds,request.maxAllowedRewardShare,request.licenseData]})};}/**
   * method registerIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachLicenseAndAddToGroup",value:(function(){var _registerIpAndAttachLicenseAndAddToGroup=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee89(request){var _yield$this$rpcClient44,call;return _regeneratorRuntime().wrap(function _callee89$(_context89){while(1)switch(_context89.prev=_context89.next){case 0:_context89.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachLicenseAndAddToGroup",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.groupId,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigMetadataAndAttachAndConfig,request.sigAddToGroup]});case 2:_yield$this$rpcClient44=_context89.sent;call=_yield$this$rpcClient44.request;_context89.next=6;return this.wallet.writeContract(call);case 6:return _context89.abrupt("return",_context89.sent);case 7:case"end":return _context89.stop();}},_callee89,this);}));function registerIpAndAttachLicenseAndAddToGroup(_x53){return _registerIpAndAttachLicenseAndAddToGroup.apply(this,arguments);}return registerIpAndAttachLicenseAndAddToGroup;}()/**
   * method registerIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachLicenseAndAddToGroupEncode",value:function registerIpAndAttachLicenseAndAddToGroupEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerIpAndAttachLicenseAndAddToGroup",args:[request.nftContract,request.tokenId,request.groupId,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigMetadataAndAttachAndConfig,request.sigAddToGroup]})};}}]);}();// Contract IPAccountImpl =============================================================
/**
 * IpAccountImplStateResponse
 *
 * @param result bytes32
 */ /**
 * IpAccountImplTokenResponse
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 uint256
 */ /**
 * IpAccountImplExecuteRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param operation uint8
 */ /**
 * IpAccountImplExecute2Request
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 */ /**
 * IpAccountImplExecuteWithSigRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param signer address
 * @param deadline uint256
 * @param signature bytes
 */ /**
 * contract IPAccountImpl readonly method
 */var IpAccountImplReadOnlyClient=/*#__PURE__*/function(){function IpAccountImplReadOnlyClient(rpcClient,address){var _rpcClient$chain9;_classCallCheck(this,IpAccountImplReadOnlyClient);this.address=address||getAddress(ipAccountImplAddress,(_rpcClient$chain9=rpcClient.chain)===null||_rpcClient$chain9===void 0?void 0:_rpcClient$chain9.id);this.rpcClient=rpcClient;}/**
   * method owner for contract IPAccountImpl
   *
   * @param request IpAccountImplOwnerRequest
   * @return Promise<IpAccountImplOwnerResponse>
   */return _createClass(IpAccountImplReadOnlyClient,[{key:"owner",value:(function(){var _owner=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee90(){return _regeneratorRuntime().wrap(function _callee90$(_context90){while(1)switch(_context90.prev=_context90.next){case 0:_context90.next=2;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"owner"});case 2:return _context90.abrupt("return",_context90.sent);case 3:case"end":return _context90.stop();}},_callee90,this);}));function owner(){return _owner.apply(this,arguments);}return owner;}()/**
   * method state for contract IPAccountImpl
   *
   * @param request IpAccountImplStateRequest
   * @return Promise<IpAccountImplStateResponse>
   */)},{key:"state",value:(function(){var _state=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee91(){var result;return _regeneratorRuntime().wrap(function _callee91$(_context91){while(1)switch(_context91.prev=_context91.next){case 0:_context91.next=2;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"state"});case 2:result=_context91.sent;return _context91.abrupt("return",{result:result});case 4:case"end":return _context91.stop();}},_callee91,this);}));function state(){return _state.apply(this,arguments);}return state;}()/**
   * method token for contract IPAccountImpl
   *
   * @param request IpAccountImplTokenRequest
   * @return Promise<IpAccountImplTokenResponse>
   */)},{key:"token",value:(function(){var _token=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee92(){return _regeneratorRuntime().wrap(function _callee92$(_context92){while(1)switch(_context92.prev=_context92.next){case 0:_context92.next=2;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"token"});case 2:return _context92.abrupt("return",_context92.sent);case 3:case"end":return _context92.stop();}},_callee92,this);}));function token(){return _token.apply(this,arguments);}return token;}())}]);}();/**
 * contract IPAccountImpl write method
 */var IpAccountImplClient=/*#__PURE__*/function(_IpAccountImplReadOnl){function IpAccountImplClient(rpcClient,wallet,address){var _this6;_classCallCheck(this,IpAccountImplClient);_this6=_callSuper(this,IpAccountImplClient,[rpcClient,address]);_this6.wallet=wallet;return _this6;}/**
   * method execute for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(IpAccountImplClient,_IpAccountImplReadOnl);return _createClass(IpAccountImplClient,[{key:"execute",value:(function(){var _execute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee93(request){var _yield$this$rpcClient45,call;return _regeneratorRuntime().wrap(function _callee93$(_context93){while(1)switch(_context93.prev=_context93.next){case 0:_context93.next=2;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"execute",account:this.wallet.account,args:[request.to,request.value,request.data,request.operation]});case 2:_yield$this$rpcClient45=_context93.sent;call=_yield$this$rpcClient45.request;_context93.next=6;return this.wallet.writeContract(call);case 6:return _context93.abrupt("return",_context93.sent);case 7:case"end":return _context93.stop();}},_callee93,this);}));function execute(_x54){return _execute.apply(this,arguments);}return execute;}()/**
   * method execute for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecuteRequest
   * @return EncodedTxData
   */)},{key:"executeEncode",value:function executeEncode(request){return {to:this.address,data:encodeFunctionData({abi:ipAccountImplAbi,functionName:"execute",args:[request.to,request.value,request.data,request.operation]})};}/**
   * method execute for contract IPAccountImpl
   *
   * @param request IpAccountImplExecute2Request
   * @return Promise<WriteContractReturnType>
   */},{key:"execute2",value:(function(){var _execute2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee94(request){var _yield$this$rpcClient46,call;return _regeneratorRuntime().wrap(function _callee94$(_context94){while(1)switch(_context94.prev=_context94.next){case 0:_context94.next=2;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"execute",account:this.wallet.account,args:[request.to,request.value,request.data]});case 2:_yield$this$rpcClient46=_context94.sent;call=_yield$this$rpcClient46.request;_context94.next=6;return this.wallet.writeContract(call);case 6:return _context94.abrupt("return",_context94.sent);case 7:case"end":return _context94.stop();}},_callee94,this);}));function execute2(_x55){return _execute2.apply(this,arguments);}return execute2;}()/**
   * method execute for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecute2Request
   * @return EncodedTxData
   */)},{key:"execute2Encode",value:function execute2Encode(request){return {to:this.address,data:encodeFunctionData({abi:ipAccountImplAbi,functionName:"execute",args:[request.to,request.value,request.data]})};}/**
   * method executeWithSig for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteWithSigRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"executeWithSig",value:(function(){var _executeWithSig=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee95(request){var _yield$this$rpcClient47,call;return _regeneratorRuntime().wrap(function _callee95$(_context95){while(1)switch(_context95.prev=_context95.next){case 0:_context95.next=2;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"executeWithSig",account:this.wallet.account,args:[request.to,request.value,request.data,request.signer,request.deadline,request.signature]});case 2:_yield$this$rpcClient47=_context95.sent;call=_yield$this$rpcClient47.request;_context95.next=6;return this.wallet.writeContract(call);case 6:return _context95.abrupt("return",_context95.sent);case 7:case"end":return _context95.stop();}},_callee95,this);}));function executeWithSig(_x56){return _executeWithSig.apply(this,arguments);}return executeWithSig;}()/**
   * method executeWithSig for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecuteWithSigRequest
   * @return EncodedTxData
   */)},{key:"executeWithSigEncode",value:function executeWithSigEncode(request){return {to:this.address,data:encodeFunctionData({abi:ipAccountImplAbi,functionName:"executeWithSig",args:[request.to,request.value,request.data,request.signer,request.deadline,request.signature]})};}}]);}(IpAccountImplReadOnlyClient);// Contract IPAssetRegistry =============================================================
/**
 * IpAssetRegistryIpAccountRegisteredEvent
 *
 * @param account address
 * @param implementation address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 */ /**
 * IpAssetRegistryIpRegisteredEvent
 *
 * @param ipId address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 * @param name string
 * @param uri string
 * @param registrationDate uint256
 */ /**
 * IpAssetRegistryIpIdRequest
 *
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 */ /**
 * IpAssetRegistryIsRegisteredRequest
 *
 * @param id address
 */ /**
 * IpAssetRegistryRegisterRequest
 *
 * @param chainid uint256
 * @param tokenContract address
 * @param tokenId uint256
 */ /**
 * contract IPAssetRegistry event
 */var IpAssetRegistryEventClient=/*#__PURE__*/function(){function IpAssetRegistryEventClient(rpcClient,address){var _rpcClient$chain10;_classCallCheck(this,IpAssetRegistryEventClient);this.address=address||getAddress(ipAssetRegistryAddress,(_rpcClient$chain10=rpcClient.chain)===null||_rpcClient$chain10===void 0?void 0:_rpcClient$chain10.id);this.rpcClient=rpcClient;}/**
   * event IPAccountRegistered for contract IPAssetRegistry
   */return _createClass(IpAssetRegistryEventClient,[{key:"watchIpAccountRegisteredEvent",value:function watchIpAccountRegisteredEvent(_onLogs26){return this.rpcClient.watchContractEvent({abi:ipAssetRegistryAbi,address:this.address,eventName:"IPAccountRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs26(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPAccountRegistered for contract IPAssetRegistry
   */},{key:"parseTxIpAccountRegisteredEvent",value:function parseTxIpAccountRegisteredEvent(txReceipt){var targetLogs=[];var _iterator26=_createForOfIteratorHelper(txReceipt.logs),_step26;try{for(_iterator26.s();!(_step26=_iterator26.n()).done;){var log=_step26.value;try{var event=decodeEventLog({abi:ipAssetRegistryAbi,eventName:"IPAccountRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPAccountRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator26.e(err);}finally{_iterator26.f();}return targetLogs;}/**
   * event IPRegistered for contract IPAssetRegistry
   */},{key:"watchIpRegisteredEvent",value:function watchIpRegisteredEvent(_onLogs27){return this.rpcClient.watchContractEvent({abi:ipAssetRegistryAbi,address:this.address,eventName:"IPRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs27(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPRegistered for contract IPAssetRegistry
   */},{key:"parseTxIpRegisteredEvent",value:function parseTxIpRegisteredEvent(txReceipt){var targetLogs=[];var _iterator27=_createForOfIteratorHelper(txReceipt.logs),_step27;try{for(_iterator27.s();!(_step27=_iterator27.n()).done;){var log=_step27.value;try{var event=decodeEventLog({abi:ipAssetRegistryAbi,eventName:"IPRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator27.e(err);}finally{_iterator27.f();}return targetLogs;}}]);}();/**
 * contract IPAssetRegistry readonly method
 */var IpAssetRegistryReadOnlyClient=/*#__PURE__*/function(_IpAssetRegistryEvent){function IpAssetRegistryReadOnlyClient(rpcClient,address){_classCallCheck(this,IpAssetRegistryReadOnlyClient);return _callSuper(this,IpAssetRegistryReadOnlyClient,[rpcClient,address]);}/**
   * method ipId for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryIpIdRequest
   * @return Promise<IpAssetRegistryIpIdResponse>
   */_inherits(IpAssetRegistryReadOnlyClient,_IpAssetRegistryEvent);return _createClass(IpAssetRegistryReadOnlyClient,[{key:"ipId",value:(function(){var _ipId=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee96(request){return _regeneratorRuntime().wrap(function _callee96$(_context96){while(1)switch(_context96.prev=_context96.next){case 0:_context96.next=2;return this.rpcClient.readContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"ipId",args:[request.chainId,request.tokenContract,request.tokenId]});case 2:return _context96.abrupt("return",_context96.sent);case 3:case"end":return _context96.stop();}},_callee96,this);}));function ipId(_x57){return _ipId.apply(this,arguments);}return ipId;}()/**
   * method isRegistered for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryIsRegisteredRequest
   * @return Promise<IpAssetRegistryIsRegisteredResponse>
   */)},{key:"isRegistered",value:(function(){var _isRegistered=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee97(request){return _regeneratorRuntime().wrap(function _callee97$(_context97){while(1)switch(_context97.prev=_context97.next){case 0:_context97.next=2;return this.rpcClient.readContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"isRegistered",args:[request.id]});case 2:return _context97.abrupt("return",_context97.sent);case 3:case"end":return _context97.stop();}},_callee97,this);}));function isRegistered(_x58){return _isRegistered.apply(this,arguments);}return isRegistered;}())}]);}(IpAssetRegistryEventClient);/**
 * contract IPAssetRegistry write method
 */var IpAssetRegistryClient=/*#__PURE__*/function(_IpAssetRegistryReadO){function IpAssetRegistryClient(rpcClient,wallet,address){var _this7;_classCallCheck(this,IpAssetRegistryClient);_this7=_callSuper(this,IpAssetRegistryClient,[rpcClient,address]);_this7.wallet=wallet;return _this7;}/**
   * method register for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryRegisterRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(IpAssetRegistryClient,_IpAssetRegistryReadO);return _createClass(IpAssetRegistryClient,[{key:"register",value:(function(){var _register=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee98(request){var _yield$this$rpcClient48,call;return _regeneratorRuntime().wrap(function _callee98$(_context98){while(1)switch(_context98.prev=_context98.next){case 0:_context98.next=2;return this.rpcClient.simulateContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"register",account:this.wallet.account,args:[request.chainid,request.tokenContract,request.tokenId]});case 2:_yield$this$rpcClient48=_context98.sent;call=_yield$this$rpcClient48.request;_context98.next=6;return this.wallet.writeContract(call);case 6:return _context98.abrupt("return",_context98.sent);case 7:case"end":return _context98.stop();}},_callee98,this);}));function register(_x59){return _register.apply(this,arguments);}return register;}()/**
   * method register for contract IPAssetRegistry with only encode
   *
   * @param request IpAssetRegistryRegisterRequest
   * @return EncodedTxData
   */)},{key:"registerEncode",value:function registerEncode(request){return {to:this.address,data:encodeFunctionData({abi:ipAssetRegistryAbi,functionName:"register",args:[request.chainid,request.tokenContract,request.tokenId]})};}}]);}(IpAssetRegistryReadOnlyClient);// Contract IpRoyaltyVaultImpl =============================================================
/**
 * IpRoyaltyVaultImplRevenueTokenClaimedEvent
 *
 * @param claimer address
 * @param token address
 * @param amount uint256
 */ /**
 * IpRoyaltyVaultImplBalanceOfRequest
 *
 * @param account address
 */ /**
 * IpRoyaltyVaultImplClaimableRevenueRequest
 *
 * @param claimer address
 * @param token address
 */ /**
 * contract IpRoyaltyVaultImpl event
 */var IpRoyaltyVaultImplEventClient=/*#__PURE__*/function(){function IpRoyaltyVaultImplEventClient(rpcClient,address){var _rpcClient$chain11;_classCallCheck(this,IpRoyaltyVaultImplEventClient);this.address=address||getAddress(ipRoyaltyVaultImplAddress,(_rpcClient$chain11=rpcClient.chain)===null||_rpcClient$chain11===void 0?void 0:_rpcClient$chain11.id);this.rpcClient=rpcClient;}/**
   * event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
   */return _createClass(IpRoyaltyVaultImplEventClient,[{key:"watchRevenueTokenClaimedEvent",value:function watchRevenueTokenClaimedEvent(_onLogs28){return this.rpcClient.watchContractEvent({abi:ipRoyaltyVaultImplAbi,address:this.address,eventName:"RevenueTokenClaimed",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs28(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
   */},{key:"parseTxRevenueTokenClaimedEvent",value:function parseTxRevenueTokenClaimedEvent(txReceipt){var targetLogs=[];var _iterator28=_createForOfIteratorHelper(txReceipt.logs),_step28;try{for(_iterator28.s();!(_step28=_iterator28.n()).done;){var log=_step28.value;try{var event=decodeEventLog({abi:ipRoyaltyVaultImplAbi,eventName:"RevenueTokenClaimed",data:log.data,topics:log.topics});if(event.eventName==="RevenueTokenClaimed"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator28.e(err);}finally{_iterator28.f();}return targetLogs;}}]);}();/**
 * contract IpRoyaltyVaultImpl readonly method
 */var IpRoyaltyVaultImplReadOnlyClient=/*#__PURE__*/function(_IpRoyaltyVaultImplEv){function IpRoyaltyVaultImplReadOnlyClient(rpcClient,address){_classCallCheck(this,IpRoyaltyVaultImplReadOnlyClient);return _callSuper(this,IpRoyaltyVaultImplReadOnlyClient,[rpcClient,address]);}/**
   * method balanceOf for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplBalanceOfRequest
   * @return Promise<IpRoyaltyVaultImplBalanceOfResponse>
   */_inherits(IpRoyaltyVaultImplReadOnlyClient,_IpRoyaltyVaultImplEv);return _createClass(IpRoyaltyVaultImplReadOnlyClient,[{key:"balanceOf",value:(function(){var _balanceOf=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee99(request){return _regeneratorRuntime().wrap(function _callee99$(_context99){while(1)switch(_context99.prev=_context99.next){case 0:_context99.next=2;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"balanceOf",args:[request.account]});case 2:return _context99.abrupt("return",_context99.sent);case 3:case"end":return _context99.stop();}},_callee99,this);}));function balanceOf(_x60){return _balanceOf.apply(this,arguments);}return balanceOf;}()/**
   * method claimableRevenue for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplClaimableRevenueRequest
   * @return Promise<IpRoyaltyVaultImplClaimableRevenueResponse>
   */)},{key:"claimableRevenue",value:(function(){var _claimableRevenue=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee100(request){return _regeneratorRuntime().wrap(function _callee100$(_context100){while(1)switch(_context100.prev=_context100.next){case 0:_context100.next=2;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"claimableRevenue",args:[request.claimer,request.token]});case 2:return _context100.abrupt("return",_context100.sent);case 3:case"end":return _context100.stop();}},_callee100,this);}));function claimableRevenue(_x61){return _claimableRevenue.apply(this,arguments);}return claimableRevenue;}()/**
   * method ipId for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplIpIdRequest
   * @return Promise<IpRoyaltyVaultImplIpIdResponse>
   */)},{key:"ipId",value:(function(){var _ipId2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee101(){return _regeneratorRuntime().wrap(function _callee101$(_context101){while(1)switch(_context101.prev=_context101.next){case 0:_context101.next=2;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"ipId"});case 2:return _context101.abrupt("return",_context101.sent);case 3:case"end":return _context101.stop();}},_callee101,this);}));function ipId(){return _ipId2.apply(this,arguments);}return ipId;}())}]);}(IpRoyaltyVaultImplEventClient);// Contract LicenseAttachmentWorkflows =============================================================
/**
 * LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param allowDuplicates bool
 */ /**
 * LicenseAttachmentWorkflowsMulticallRequest
 *
 * @param data bytes[]
 */ /**
 * LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param sigMetadataAndAttachAndConfig tuple
 */ /**
 * LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
 *
 * @param ipId address
 * @param licenseTermsData tuple[]
 * @param sigAttachAndConfig tuple
 */ /**
 * contract LicenseAttachmentWorkflows write method
 */var LicenseAttachmentWorkflowsClient=/*#__PURE__*/function(){function LicenseAttachmentWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain12;_classCallCheck(this,LicenseAttachmentWorkflowsClient);this.address=address||getAddress(licenseAttachmentWorkflowsAddress,(_rpcClient$chain12=rpcClient.chain)===null||_rpcClient$chain12===void 0?void 0:_rpcClient$chain12.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method mintAndRegisterIpAndAttachPILTerms for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(LicenseAttachmentWorkflowsClient,[{key:"mintAndRegisterIpAndAttachPilTerms",value:(function(){var _mintAndRegisterIpAndAttachPilTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee102(request){var _yield$this$rpcClient49,call;return _regeneratorRuntime().wrap(function _callee102$(_context102){while(1)switch(_context102.prev=_context102.next){case 0:_context102.next=2;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachPILTerms",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.allowDuplicates]});case 2:_yield$this$rpcClient49=_context102.sent;call=_yield$this$rpcClient49.request;_context102.next=6;return this.wallet.writeContract(call);case 6:return _context102.abrupt("return",_context102.sent);case 7:case"end":return _context102.stop();}},_callee102,this);}));function mintAndRegisterIpAndAttachPilTerms(_x62){return _mintAndRegisterIpAndAttachPilTerms.apply(this,arguments);}return mintAndRegisterIpAndAttachPilTerms;}()/**
   * method mintAndRegisterIpAndAttachPILTerms for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachPilTermsEncode",value:function mintAndRegisterIpAndAttachPilTermsEncode(request){return {to:this.address,data:encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachPILTerms",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.allowDuplicates]})};}/**
   * method multicall for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee103(request){var _yield$this$rpcClient50,call;return _regeneratorRuntime().wrap(function _callee103$(_context103){while(1)switch(_context103.prev=_context103.next){case 0:_context103.next=2;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 2:_yield$this$rpcClient50=_context103.sent;call=_yield$this$rpcClient50.request;_context103.next=6;return this.wallet.writeContract(call);case 6:return _context103.abrupt("return",_context103.sent);case 7:case"end":return _context103.stop();}},_callee103,this);}));function multicall(_x63){return _multicall2.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIpAndAttachPILTerms for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachPilTerms",value:(function(){var _registerIpAndAttachPilTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee104(request){var _yield$this$rpcClient51,call;return _regeneratorRuntime().wrap(function _callee104$(_context104){while(1)switch(_context104.prev=_context104.next){case 0:_context104.next=2;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachPILTerms",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]});case 2:_yield$this$rpcClient51=_context104.sent;call=_yield$this$rpcClient51.request;_context104.next=6;return this.wallet.writeContract(call);case 6:return _context104.abrupt("return",_context104.sent);case 7:case"end":return _context104.stop();}},_callee104,this);}));function registerIpAndAttachPilTerms(_x64){return _registerIpAndAttachPilTerms.apply(this,arguments);}return registerIpAndAttachPilTerms;}()/**
   * method registerIpAndAttachPILTerms for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachPilTermsEncode",value:function registerIpAndAttachPilTermsEncode(request){return {to:this.address,data:encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"registerIpAndAttachPILTerms",args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]})};}/**
   * method registerPILTermsAndAttach for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerPilTermsAndAttach",value:(function(){var _registerPilTermsAndAttach=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee105(request){var _yield$this$rpcClient52,call;return _regeneratorRuntime().wrap(function _callee105$(_context105){while(1)switch(_context105.prev=_context105.next){case 0:_context105.next=2;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"registerPILTermsAndAttach",account:this.wallet.account,args:[request.ipId,request.licenseTermsData,request.sigAttachAndConfig]});case 2:_yield$this$rpcClient52=_context105.sent;call=_yield$this$rpcClient52.request;_context105.next=6;return this.wallet.writeContract(call);case 6:return _context105.abrupt("return",_context105.sent);case 7:case"end":return _context105.stop();}},_callee105,this);}));function registerPilTermsAndAttach(_x65){return _registerPilTermsAndAttach.apply(this,arguments);}return registerPilTermsAndAttach;}()/**
   * method registerPILTermsAndAttach for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
   * @return EncodedTxData
   */)},{key:"registerPilTermsAndAttachEncode",value:function registerPilTermsAndAttachEncode(request){return {to:this.address,data:encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"registerPILTermsAndAttach",args:[request.ipId,request.licenseTermsData,request.sigAttachAndConfig]})};}}]);}();// Contract LicenseRegistry =============================================================
/**
 * LicenseRegistryAuthorityUpdatedEvent
 *
 * @param authority address
 */ /**
 * LicenseRegistryDefaultLicenseTermsSetEvent
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryExpirationTimeSetEvent
 *
 * @param ipId address
 * @param expireTime uint256
 */ /**
 * LicenseRegistryInitializedEvent
 *
 * @param version uint64
 */ /**
 * LicenseRegistryLicenseTemplateRegisteredEvent
 *
 * @param licenseTemplate address
 */ /**
 * LicenseRegistryLicensingConfigSetForLicenseEvent
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param licensingConfig tuple
 */ /**
 * LicenseRegistryUpgradedEvent
 *
 * @param implementation address
 */ /**
 * LicenseRegistryExistsRequest
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryGetAttachedLicenseTermsRequest
 *
 * @param ipId address
 * @param index uint256
 */ /**
 * LicenseRegistryGetAttachedLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryGetAttachedLicenseTermsCountRequest
 *
 * @param ipId address
 */ /**
 * LicenseRegistryGetDefaultLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryGetDerivativeIpRequest
 *
 * @param parentIpId address
 * @param index uint256
 */ /**
 * LicenseRegistryGetDerivativeIpResponse
 *
 * @param childIpId address
 */ /**
 * LicenseRegistryGetDerivativeIpCountRequest
 *
 * @param parentIpId address
 */ /**
 * LicenseRegistryGetExpireTimeRequest
 *
 * @param ipId address
 */ /**
 * LicenseRegistryGetLicensingConfigRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryGetParentIpRequest
 *
 * @param childIpId address
 * @param index uint256
 */ /**
 * LicenseRegistryGetParentIpResponse
 *
 * @param parentIpId address
 */ /**
 * LicenseRegistryGetParentIpCountRequest
 *
 * @param childIpId address
 */ /**
 * LicenseRegistryGetParentLicenseTermsRequest
 *
 * @param childIpId address
 * @param parentIpId address
 */ /**
 * LicenseRegistryGetParentLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryGetRoyaltyPercentRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryGetRoyaltyPercentResponse
 *
 * @param royaltyPercent uint32
 */ /**
 * LicenseRegistryHasDerivativeIpsRequest
 *
 * @param parentIpId address
 */ /**
 * LicenseRegistryHasIpAttachedLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryIsDefaultLicenseRequest
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryIsDerivativeIpRequest
 *
 * @param childIpId address
 */ /**
 * LicenseRegistryIsExpiredNowRequest
 *
 * @param ipId address
 */ /**
 * LicenseRegistryIsParentIpRequest
 *
 * @param parentIpId address
 * @param childIpId address
 */ /**
 * LicenseRegistryIsRegisteredLicenseTemplateRequest
 *
 * @param licenseTemplate address
 */ /**
 * LicenseRegistryVerifyGroupAddIpRequest
 *
 * @param groupId address
 * @param groupRewardPool address
 * @param ipId address
 * @param groupLicenseTemplate address
 * @param groupLicenseTermsId uint256
 */ /**
 * LicenseRegistryVerifyGroupAddIpResponse
 *
 * @param ipLicensingConfig tuple
 */ /**
 * LicenseRegistryVerifyMintLicenseTokenRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param isMintedByIpOwner bool
 */ /**
 * LicenseRegistryAttachLicenseTermsToIpRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicenseRegistryGetAncestorsCountRequest
 *
 * @param ipId address
 */ /**
 * LicenseRegistryInitializeRequest
 *
 * @param accessManager address
 */ /**
 * LicenseRegistryRegisterDerivativeIpRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTemplate address
 * @param licenseTermsIds uint256[]
 * @param isUsingLicenseToken bool
 */ /**
 * LicenseRegistryRegisterLicenseTemplateRequest
 *
 * @param licenseTemplate address
 */ /**
 * LicenseRegistrySetAuthorityRequest
 *
 * @param newAuthority address
 */ /**
 * LicenseRegistrySetDefaultLicenseTermsRequest
 *
 * @param newLicenseTemplate address
 * @param newLicenseTermsId uint256
 */ /**
 * LicenseRegistrySetLicensingConfigForLicenseRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param licensingConfig tuple
 */ /**
 * LicenseRegistryUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */ /**
 * contract LicenseRegistry event
 */var LicenseRegistryEventClient=/*#__PURE__*/function(){function LicenseRegistryEventClient(rpcClient,address){var _rpcClient$chain13;_classCallCheck(this,LicenseRegistryEventClient);this.address=address||getAddress(licenseRegistryAddress,(_rpcClient$chain13=rpcClient.chain)===null||_rpcClient$chain13===void 0?void 0:_rpcClient$chain13.id);this.rpcClient=rpcClient;}/**
   * event AuthorityUpdated for contract LicenseRegistry
   */return _createClass(LicenseRegistryEventClient,[{key:"watchAuthorityUpdatedEvent",value:function watchAuthorityUpdatedEvent(_onLogs29){return this.rpcClient.watchContractEvent({abi:licenseRegistryAbi,address:this.address,eventName:"AuthorityUpdated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs29(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AuthorityUpdated for contract LicenseRegistry
   */},{key:"parseTxAuthorityUpdatedEvent",value:function parseTxAuthorityUpdatedEvent(txReceipt){var targetLogs=[];var _iterator29=_createForOfIteratorHelper(txReceipt.logs),_step29;try{for(_iterator29.s();!(_step29=_iterator29.n()).done;){var log=_step29.value;try{var event=decodeEventLog({abi:licenseRegistryAbi,eventName:"AuthorityUpdated",data:log.data,topics:log.topics});if(event.eventName==="AuthorityUpdated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator29.e(err);}finally{_iterator29.f();}return targetLogs;}/**
   * event DefaultLicenseTermsSet for contract LicenseRegistry
   */},{key:"watchDefaultLicenseTermsSetEvent",value:function watchDefaultLicenseTermsSetEvent(_onLogs30){return this.rpcClient.watchContractEvent({abi:licenseRegistryAbi,address:this.address,eventName:"DefaultLicenseTermsSet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs30(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DefaultLicenseTermsSet for contract LicenseRegistry
   */},{key:"parseTxDefaultLicenseTermsSetEvent",value:function parseTxDefaultLicenseTermsSetEvent(txReceipt){var targetLogs=[];var _iterator30=_createForOfIteratorHelper(txReceipt.logs),_step30;try{for(_iterator30.s();!(_step30=_iterator30.n()).done;){var log=_step30.value;try{var event=decodeEventLog({abi:licenseRegistryAbi,eventName:"DefaultLicenseTermsSet",data:log.data,topics:log.topics});if(event.eventName==="DefaultLicenseTermsSet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator30.e(err);}finally{_iterator30.f();}return targetLogs;}/**
   * event ExpirationTimeSet for contract LicenseRegistry
   */},{key:"watchExpirationTimeSetEvent",value:function watchExpirationTimeSetEvent(_onLogs31){return this.rpcClient.watchContractEvent({abi:licenseRegistryAbi,address:this.address,eventName:"ExpirationTimeSet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs31(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event ExpirationTimeSet for contract LicenseRegistry
   */},{key:"parseTxExpirationTimeSetEvent",value:function parseTxExpirationTimeSetEvent(txReceipt){var targetLogs=[];var _iterator31=_createForOfIteratorHelper(txReceipt.logs),_step31;try{for(_iterator31.s();!(_step31=_iterator31.n()).done;){var log=_step31.value;try{var event=decodeEventLog({abi:licenseRegistryAbi,eventName:"ExpirationTimeSet",data:log.data,topics:log.topics});if(event.eventName==="ExpirationTimeSet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator31.e(err);}finally{_iterator31.f();}return targetLogs;}/**
   * event Initialized for contract LicenseRegistry
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs32){return this.rpcClient.watchContractEvent({abi:licenseRegistryAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs32(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract LicenseRegistry
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator32=_createForOfIteratorHelper(txReceipt.logs),_step32;try{for(_iterator32.s();!(_step32=_iterator32.n()).done;){var log=_step32.value;try{var event=decodeEventLog({abi:licenseRegistryAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator32.e(err);}finally{_iterator32.f();}return targetLogs;}/**
   * event LicenseTemplateRegistered for contract LicenseRegistry
   */},{key:"watchLicenseTemplateRegisteredEvent",value:function watchLicenseTemplateRegisteredEvent(_onLogs33){return this.rpcClient.watchContractEvent({abi:licenseRegistryAbi,address:this.address,eventName:"LicenseTemplateRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs33(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTemplateRegistered for contract LicenseRegistry
   */},{key:"parseTxLicenseTemplateRegisteredEvent",value:function parseTxLicenseTemplateRegisteredEvent(txReceipt){var targetLogs=[];var _iterator33=_createForOfIteratorHelper(txReceipt.logs),_step33;try{for(_iterator33.s();!(_step33=_iterator33.n()).done;){var log=_step33.value;try{var event=decodeEventLog({abi:licenseRegistryAbi,eventName:"LicenseTemplateRegistered",data:log.data,topics:log.topics});if(event.eventName==="LicenseTemplateRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator33.e(err);}finally{_iterator33.f();}return targetLogs;}/**
   * event LicensingConfigSetForLicense for contract LicenseRegistry
   */},{key:"watchLicensingConfigSetForLicenseEvent",value:function watchLicensingConfigSetForLicenseEvent(_onLogs34){return this.rpcClient.watchContractEvent({abi:licenseRegistryAbi,address:this.address,eventName:"LicensingConfigSetForLicense",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs34(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicensingConfigSetForLicense for contract LicenseRegistry
   */},{key:"parseTxLicensingConfigSetForLicenseEvent",value:function parseTxLicensingConfigSetForLicenseEvent(txReceipt){var targetLogs=[];var _iterator34=_createForOfIteratorHelper(txReceipt.logs),_step34;try{for(_iterator34.s();!(_step34=_iterator34.n()).done;){var log=_step34.value;try{var event=decodeEventLog({abi:licenseRegistryAbi,eventName:"LicensingConfigSetForLicense",data:log.data,topics:log.topics});if(event.eventName==="LicensingConfigSetForLicense"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator34.e(err);}finally{_iterator34.f();}return targetLogs;}/**
   * event Upgraded for contract LicenseRegistry
   */},{key:"watchUpgradedEvent",value:function watchUpgradedEvent(_onLogs35){return this.rpcClient.watchContractEvent({abi:licenseRegistryAbi,address:this.address,eventName:"Upgraded",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs35(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Upgraded for contract LicenseRegistry
   */},{key:"parseTxUpgradedEvent",value:function parseTxUpgradedEvent(txReceipt){var targetLogs=[];var _iterator35=_createForOfIteratorHelper(txReceipt.logs),_step35;try{for(_iterator35.s();!(_step35=_iterator35.n()).done;){var log=_step35.value;try{var event=decodeEventLog({abi:licenseRegistryAbi,eventName:"Upgraded",data:log.data,topics:log.topics});if(event.eventName==="Upgraded"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator35.e(err);}finally{_iterator35.f();}return targetLogs;}}]);}();/**
 * contract LicenseRegistry readonly method
 */var LicenseRegistryReadOnlyClient=/*#__PURE__*/function(_LicenseRegistryEvent){function LicenseRegistryReadOnlyClient(rpcClient,address){_classCallCheck(this,LicenseRegistryReadOnlyClient);return _callSuper(this,LicenseRegistryReadOnlyClient,[rpcClient,address]);}/**
   * method DISPUTE_MODULE for contract LicenseRegistry
   *
   * @param request LicenseRegistryDisputeModuleRequest
   * @return Promise<LicenseRegistryDisputeModuleResponse>
   */_inherits(LicenseRegistryReadOnlyClient,_LicenseRegistryEvent);return _createClass(LicenseRegistryReadOnlyClient,[{key:"disputeModule",value:(function(){var _disputeModule2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee106(){return _regeneratorRuntime().wrap(function _callee106$(_context106){while(1)switch(_context106.prev=_context106.next){case 0:_context106.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"DISPUTE_MODULE"});case 2:return _context106.abrupt("return",_context106.sent);case 3:case"end":return _context106.stop();}},_callee106,this);}));function disputeModule(){return _disputeModule2.apply(this,arguments);}return disputeModule;}()/**
   * method EXPIRATION_TIME for contract LicenseRegistry
   *
   * @param request LicenseRegistryExpirationTimeRequest
   * @return Promise<LicenseRegistryExpirationTimeResponse>
   */)},{key:"expirationTime",value:(function(){var _expirationTime=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee107(){return _regeneratorRuntime().wrap(function _callee107$(_context107){while(1)switch(_context107.prev=_context107.next){case 0:_context107.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"EXPIRATION_TIME"});case 2:return _context107.abrupt("return",_context107.sent);case 3:case"end":return _context107.stop();}},_callee107,this);}));function expirationTime(){return _expirationTime.apply(this,arguments);}return expirationTime;}()/**
   * method GROUP_IP_ASSET_REGISTRY for contract LicenseRegistry
   *
   * @param request LicenseRegistryGroupIpAssetRegistryRequest
   * @return Promise<LicenseRegistryGroupIpAssetRegistryResponse>
   */)},{key:"groupIpAssetRegistry",value:(function(){var _groupIpAssetRegistry3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee108(){return _regeneratorRuntime().wrap(function _callee108$(_context108){while(1)switch(_context108.prev=_context108.next){case 0:_context108.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"GROUP_IP_ASSET_REGISTRY"});case 2:return _context108.abrupt("return",_context108.sent);case 3:case"end":return _context108.stop();}},_callee108,this);}));function groupIpAssetRegistry(){return _groupIpAssetRegistry3.apply(this,arguments);}return groupIpAssetRegistry;}()/**
   * method IP_GRAPH for contract LicenseRegistry
   *
   * @param request LicenseRegistryIpGraphRequest
   * @return Promise<LicenseRegistryIpGraphResponse>
   */)},{key:"ipGraph",value:(function(){var _ipGraph=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee109(){return _regeneratorRuntime().wrap(function _callee109$(_context109){while(1)switch(_context109.prev=_context109.next){case 0:_context109.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"IP_GRAPH"});case 2:return _context109.abrupt("return",_context109.sent);case 3:case"end":return _context109.stop();}},_callee109,this);}));function ipGraph(){return _ipGraph.apply(this,arguments);}return ipGraph;}()/**
   * method IP_GRAPH_ACL for contract LicenseRegistry
   *
   * @param request LicenseRegistryIpGraphAclRequest
   * @return Promise<LicenseRegistryIpGraphAclResponse>
   */)},{key:"ipGraphAcl",value:(function(){var _ipGraphAcl=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee110(){return _regeneratorRuntime().wrap(function _callee110$(_context110){while(1)switch(_context110.prev=_context110.next){case 0:_context110.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"IP_GRAPH_ACL"});case 2:return _context110.abrupt("return",_context110.sent);case 3:case"end":return _context110.stop();}},_callee110,this);}));function ipGraphAcl(){return _ipGraphAcl.apply(this,arguments);}return ipGraphAcl;}()/**
   * method LICENSING_MODULE for contract LicenseRegistry
   *
   * @param request LicenseRegistryLicensingModuleRequest
   * @return Promise<LicenseRegistryLicensingModuleResponse>
   */)},{key:"licensingModule",value:(function(){var _licensingModule=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee111(){return _regeneratorRuntime().wrap(function _callee111$(_context111){while(1)switch(_context111.prev=_context111.next){case 0:_context111.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"LICENSING_MODULE"});case 2:return _context111.abrupt("return",_context111.sent);case 3:case"end":return _context111.stop();}},_callee111,this);}));function licensingModule(){return _licensingModule.apply(this,arguments);}return licensingModule;}()/**
   * method MAX_ANCESTORS for contract LicenseRegistry
   *
   * @param request LicenseRegistryMaxAncestorsRequest
   * @return Promise<LicenseRegistryMaxAncestorsResponse>
   */)},{key:"maxAncestors",value:(function(){var _maxAncestors=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee112(){return _regeneratorRuntime().wrap(function _callee112$(_context112){while(1)switch(_context112.prev=_context112.next){case 0:_context112.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"MAX_ANCESTORS"});case 2:return _context112.abrupt("return",_context112.sent);case 3:case"end":return _context112.stop();}},_callee112,this);}));function maxAncestors(){return _maxAncestors.apply(this,arguments);}return maxAncestors;}()/**
   * method MAX_PARENTS for contract LicenseRegistry
   *
   * @param request LicenseRegistryMaxParentsRequest
   * @return Promise<LicenseRegistryMaxParentsResponse>
   */)},{key:"maxParents",value:(function(){var _maxParents=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee113(){return _regeneratorRuntime().wrap(function _callee113$(_context113){while(1)switch(_context113.prev=_context113.next){case 0:_context113.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"MAX_PARENTS"});case 2:return _context113.abrupt("return",_context113.sent);case 3:case"end":return _context113.stop();}},_callee113,this);}));function maxParents(){return _maxParents.apply(this,arguments);}return maxParents;}()/**
   * method UPGRADE_INTERFACE_VERSION for contract LicenseRegistry
   *
   * @param request LicenseRegistryUpgradeInterfaceVersionRequest
   * @return Promise<LicenseRegistryUpgradeInterfaceVersionResponse>
   */)},{key:"upgradeInterfaceVersion",value:(function(){var _upgradeInterfaceVersion4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee114(){return _regeneratorRuntime().wrap(function _callee114$(_context114){while(1)switch(_context114.prev=_context114.next){case 0:_context114.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"UPGRADE_INTERFACE_VERSION"});case 2:return _context114.abrupt("return",_context114.sent);case 3:case"end":return _context114.stop();}},_callee114,this);}));function upgradeInterfaceVersion(){return _upgradeInterfaceVersion4.apply(this,arguments);}return upgradeInterfaceVersion;}()/**
   * method authority for contract LicenseRegistry
   *
   * @param request LicenseRegistryAuthorityRequest
   * @return Promise<LicenseRegistryAuthorityResponse>
   */)},{key:"authority",value:(function(){var _authority4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee115(){return _regeneratorRuntime().wrap(function _callee115$(_context115){while(1)switch(_context115.prev=_context115.next){case 0:_context115.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"authority"});case 2:return _context115.abrupt("return",_context115.sent);case 3:case"end":return _context115.stop();}},_callee115,this);}));function authority(){return _authority4.apply(this,arguments);}return authority;}()/**
   * method exists for contract LicenseRegistry
   *
   * @param request LicenseRegistryExistsRequest
   * @return Promise<LicenseRegistryExistsResponse>
   */)},{key:"exists",value:(function(){var _exists=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee116(request){return _regeneratorRuntime().wrap(function _callee116$(_context116){while(1)switch(_context116.prev=_context116.next){case 0:_context116.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"exists",args:[request.licenseTemplate,request.licenseTermsId]});case 2:return _context116.abrupt("return",_context116.sent);case 3:case"end":return _context116.stop();}},_callee116,this);}));function exists(_x66){return _exists.apply(this,arguments);}return exists;}()/**
   * method getAttachedLicenseTerms for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetAttachedLicenseTermsRequest
   * @return Promise<LicenseRegistryGetAttachedLicenseTermsResponse>
   */)},{key:"getAttachedLicenseTerms",value:(function(){var _getAttachedLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee117(request){var result;return _regeneratorRuntime().wrap(function _callee117$(_context117){while(1)switch(_context117.prev=_context117.next){case 0:_context117.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getAttachedLicenseTerms",args:[request.ipId,request.index]});case 2:result=_context117.sent;return _context117.abrupt("return",{licenseTemplate:result[0],licenseTermsId:result[1]});case 4:case"end":return _context117.stop();}},_callee117,this);}));function getAttachedLicenseTerms(_x67){return _getAttachedLicenseTerms.apply(this,arguments);}return getAttachedLicenseTerms;}()/**
   * method getAttachedLicenseTermsCount for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetAttachedLicenseTermsCountRequest
   * @return Promise<LicenseRegistryGetAttachedLicenseTermsCountResponse>
   */)},{key:"getAttachedLicenseTermsCount",value:(function(){var _getAttachedLicenseTermsCount=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee118(request){return _regeneratorRuntime().wrap(function _callee118$(_context118){while(1)switch(_context118.prev=_context118.next){case 0:_context118.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getAttachedLicenseTermsCount",args:[request.ipId]});case 2:return _context118.abrupt("return",_context118.sent);case 3:case"end":return _context118.stop();}},_callee118,this);}));function getAttachedLicenseTermsCount(_x68){return _getAttachedLicenseTermsCount.apply(this,arguments);}return getAttachedLicenseTermsCount;}()/**
   * method getDefaultLicenseTerms for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetDefaultLicenseTermsRequest
   * @return Promise<LicenseRegistryGetDefaultLicenseTermsResponse>
   */)},{key:"getDefaultLicenseTerms",value:(function(){var _getDefaultLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee119(){var result;return _regeneratorRuntime().wrap(function _callee119$(_context119){while(1)switch(_context119.prev=_context119.next){case 0:_context119.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getDefaultLicenseTerms"});case 2:result=_context119.sent;return _context119.abrupt("return",{licenseTemplate:result[0],licenseTermsId:result[1]});case 4:case"end":return _context119.stop();}},_callee119,this);}));function getDefaultLicenseTerms(){return _getDefaultLicenseTerms.apply(this,arguments);}return getDefaultLicenseTerms;}()/**
   * method getDerivativeIp for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetDerivativeIpRequest
   * @return Promise<LicenseRegistryGetDerivativeIpResponse>
   */)},{key:"getDerivativeIp",value:(function(){var _getDerivativeIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee120(request){var result;return _regeneratorRuntime().wrap(function _callee120$(_context120){while(1)switch(_context120.prev=_context120.next){case 0:_context120.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getDerivativeIp",args:[request.parentIpId,request.index]});case 2:result=_context120.sent;return _context120.abrupt("return",{childIpId:result});case 4:case"end":return _context120.stop();}},_callee120,this);}));function getDerivativeIp(_x69){return _getDerivativeIp.apply(this,arguments);}return getDerivativeIp;}()/**
   * method getDerivativeIpCount for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetDerivativeIpCountRequest
   * @return Promise<LicenseRegistryGetDerivativeIpCountResponse>
   */)},{key:"getDerivativeIpCount",value:(function(){var _getDerivativeIpCount=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee121(request){return _regeneratorRuntime().wrap(function _callee121$(_context121){while(1)switch(_context121.prev=_context121.next){case 0:_context121.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getDerivativeIpCount",args:[request.parentIpId]});case 2:return _context121.abrupt("return",_context121.sent);case 3:case"end":return _context121.stop();}},_callee121,this);}));function getDerivativeIpCount(_x70){return _getDerivativeIpCount.apply(this,arguments);}return getDerivativeIpCount;}()/**
   * method getExpireTime for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetExpireTimeRequest
   * @return Promise<LicenseRegistryGetExpireTimeResponse>
   */)},{key:"getExpireTime",value:(function(){var _getExpireTime=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee122(request){return _regeneratorRuntime().wrap(function _callee122$(_context122){while(1)switch(_context122.prev=_context122.next){case 0:_context122.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getExpireTime",args:[request.ipId]});case 2:return _context122.abrupt("return",_context122.sent);case 3:case"end":return _context122.stop();}},_callee122,this);}));function getExpireTime(_x71){return _getExpireTime.apply(this,arguments);}return getExpireTime;}()/**
   * method getLicensingConfig for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetLicensingConfigRequest
   * @return Promise<LicenseRegistryGetLicensingConfigResponse>
   */)},{key:"getLicensingConfig",value:(function(){var _getLicensingConfig=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee123(request){return _regeneratorRuntime().wrap(function _callee123$(_context123){while(1)switch(_context123.prev=_context123.next){case 0:_context123.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getLicensingConfig",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 2:return _context123.abrupt("return",_context123.sent);case 3:case"end":return _context123.stop();}},_callee123,this);}));function getLicensingConfig(_x72){return _getLicensingConfig.apply(this,arguments);}return getLicensingConfig;}()/**
   * method getParentIp for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetParentIpRequest
   * @return Promise<LicenseRegistryGetParentIpResponse>
   */)},{key:"getParentIp",value:(function(){var _getParentIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee124(request){var result;return _regeneratorRuntime().wrap(function _callee124$(_context124){while(1)switch(_context124.prev=_context124.next){case 0:_context124.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getParentIp",args:[request.childIpId,request.index]});case 2:result=_context124.sent;return _context124.abrupt("return",{parentIpId:result});case 4:case"end":return _context124.stop();}},_callee124,this);}));function getParentIp(_x73){return _getParentIp.apply(this,arguments);}return getParentIp;}()/**
   * method getParentIpCount for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetParentIpCountRequest
   * @return Promise<LicenseRegistryGetParentIpCountResponse>
   */)},{key:"getParentIpCount",value:(function(){var _getParentIpCount=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee125(request){return _regeneratorRuntime().wrap(function _callee125$(_context125){while(1)switch(_context125.prev=_context125.next){case 0:_context125.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getParentIpCount",args:[request.childIpId]});case 2:return _context125.abrupt("return",_context125.sent);case 3:case"end":return _context125.stop();}},_callee125,this);}));function getParentIpCount(_x74){return _getParentIpCount.apply(this,arguments);}return getParentIpCount;}()/**
   * method getParentLicenseTerms for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetParentLicenseTermsRequest
   * @return Promise<LicenseRegistryGetParentLicenseTermsResponse>
   */)},{key:"getParentLicenseTerms",value:(function(){var _getParentLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee126(request){var result;return _regeneratorRuntime().wrap(function _callee126$(_context126){while(1)switch(_context126.prev=_context126.next){case 0:_context126.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getParentLicenseTerms",args:[request.childIpId,request.parentIpId]});case 2:result=_context126.sent;return _context126.abrupt("return",{licenseTemplate:result[0],licenseTermsId:result[1]});case 4:case"end":return _context126.stop();}},_callee126,this);}));function getParentLicenseTerms(_x75){return _getParentLicenseTerms.apply(this,arguments);}return getParentLicenseTerms;}()/**
   * method getRoyaltyPercent for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetRoyaltyPercentRequest
   * @return Promise<LicenseRegistryGetRoyaltyPercentResponse>
   */)},{key:"getRoyaltyPercent",value:(function(){var _getRoyaltyPercent=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee127(request){var result;return _regeneratorRuntime().wrap(function _callee127$(_context127){while(1)switch(_context127.prev=_context127.next){case 0:_context127.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getRoyaltyPercent",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 2:result=_context127.sent;return _context127.abrupt("return",{royaltyPercent:result});case 4:case"end":return _context127.stop();}},_callee127,this);}));function getRoyaltyPercent(_x76){return _getRoyaltyPercent.apply(this,arguments);}return getRoyaltyPercent;}()/**
   * method hasDerivativeIps for contract LicenseRegistry
   *
   * @param request LicenseRegistryHasDerivativeIpsRequest
   * @return Promise<LicenseRegistryHasDerivativeIpsResponse>
   */)},{key:"hasDerivativeIps",value:(function(){var _hasDerivativeIps=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee128(request){return _regeneratorRuntime().wrap(function _callee128$(_context128){while(1)switch(_context128.prev=_context128.next){case 0:_context128.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"hasDerivativeIps",args:[request.parentIpId]});case 2:return _context128.abrupt("return",_context128.sent);case 3:case"end":return _context128.stop();}},_callee128,this);}));function hasDerivativeIps(_x77){return _hasDerivativeIps.apply(this,arguments);}return hasDerivativeIps;}()/**
   * method hasIpAttachedLicenseTerms for contract LicenseRegistry
   *
   * @param request LicenseRegistryHasIpAttachedLicenseTermsRequest
   * @return Promise<LicenseRegistryHasIpAttachedLicenseTermsResponse>
   */)},{key:"hasIpAttachedLicenseTerms",value:(function(){var _hasIpAttachedLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee129(request){return _regeneratorRuntime().wrap(function _callee129$(_context129){while(1)switch(_context129.prev=_context129.next){case 0:_context129.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"hasIpAttachedLicenseTerms",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 2:return _context129.abrupt("return",_context129.sent);case 3:case"end":return _context129.stop();}},_callee129,this);}));function hasIpAttachedLicenseTerms(_x78){return _hasIpAttachedLicenseTerms.apply(this,arguments);}return hasIpAttachedLicenseTerms;}()/**
   * method isConsumingScheduledOp for contract LicenseRegistry
   *
   * @param request LicenseRegistryIsConsumingScheduledOpRequest
   * @return Promise<LicenseRegistryIsConsumingScheduledOpResponse>
   */)},{key:"isConsumingScheduledOp",value:(function(){var _isConsumingScheduledOp4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee130(){return _regeneratorRuntime().wrap(function _callee130$(_context130){while(1)switch(_context130.prev=_context130.next){case 0:_context130.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"isConsumingScheduledOp"});case 2:return _context130.abrupt("return",_context130.sent);case 3:case"end":return _context130.stop();}},_callee130,this);}));function isConsumingScheduledOp(){return _isConsumingScheduledOp4.apply(this,arguments);}return isConsumingScheduledOp;}()/**
   * method isDefaultLicense for contract LicenseRegistry
   *
   * @param request LicenseRegistryIsDefaultLicenseRequest
   * @return Promise<LicenseRegistryIsDefaultLicenseResponse>
   */)},{key:"isDefaultLicense",value:(function(){var _isDefaultLicense=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee131(request){return _regeneratorRuntime().wrap(function _callee131$(_context131){while(1)switch(_context131.prev=_context131.next){case 0:_context131.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"isDefaultLicense",args:[request.licenseTemplate,request.licenseTermsId]});case 2:return _context131.abrupt("return",_context131.sent);case 3:case"end":return _context131.stop();}},_callee131,this);}));function isDefaultLicense(_x79){return _isDefaultLicense.apply(this,arguments);}return isDefaultLicense;}()/**
   * method isDerivativeIp for contract LicenseRegistry
   *
   * @param request LicenseRegistryIsDerivativeIpRequest
   * @return Promise<LicenseRegistryIsDerivativeIpResponse>
   */)},{key:"isDerivativeIp",value:(function(){var _isDerivativeIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee132(request){return _regeneratorRuntime().wrap(function _callee132$(_context132){while(1)switch(_context132.prev=_context132.next){case 0:_context132.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"isDerivativeIp",args:[request.childIpId]});case 2:return _context132.abrupt("return",_context132.sent);case 3:case"end":return _context132.stop();}},_callee132,this);}));function isDerivativeIp(_x80){return _isDerivativeIp.apply(this,arguments);}return isDerivativeIp;}()/**
   * method isExpiredNow for contract LicenseRegistry
   *
   * @param request LicenseRegistryIsExpiredNowRequest
   * @return Promise<LicenseRegistryIsExpiredNowResponse>
   */)},{key:"isExpiredNow",value:(function(){var _isExpiredNow=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee133(request){return _regeneratorRuntime().wrap(function _callee133$(_context133){while(1)switch(_context133.prev=_context133.next){case 0:_context133.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"isExpiredNow",args:[request.ipId]});case 2:return _context133.abrupt("return",_context133.sent);case 3:case"end":return _context133.stop();}},_callee133,this);}));function isExpiredNow(_x81){return _isExpiredNow.apply(this,arguments);}return isExpiredNow;}()/**
   * method isParentIp for contract LicenseRegistry
   *
   * @param request LicenseRegistryIsParentIpRequest
   * @return Promise<LicenseRegistryIsParentIpResponse>
   */)},{key:"isParentIp",value:(function(){var _isParentIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee134(request){return _regeneratorRuntime().wrap(function _callee134$(_context134){while(1)switch(_context134.prev=_context134.next){case 0:_context134.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"isParentIp",args:[request.parentIpId,request.childIpId]});case 2:return _context134.abrupt("return",_context134.sent);case 3:case"end":return _context134.stop();}},_callee134,this);}));function isParentIp(_x82){return _isParentIp.apply(this,arguments);}return isParentIp;}()/**
   * method isRegisteredLicenseTemplate for contract LicenseRegistry
   *
   * @param request LicenseRegistryIsRegisteredLicenseTemplateRequest
   * @return Promise<LicenseRegistryIsRegisteredLicenseTemplateResponse>
   */)},{key:"isRegisteredLicenseTemplate",value:(function(){var _isRegisteredLicenseTemplate=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee135(request){return _regeneratorRuntime().wrap(function _callee135$(_context135){while(1)switch(_context135.prev=_context135.next){case 0:_context135.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"isRegisteredLicenseTemplate",args:[request.licenseTemplate]});case 2:return _context135.abrupt("return",_context135.sent);case 3:case"end":return _context135.stop();}},_callee135,this);}));function isRegisteredLicenseTemplate(_x83){return _isRegisteredLicenseTemplate.apply(this,arguments);}return isRegisteredLicenseTemplate;}()/**
   * method proxiableUUID for contract LicenseRegistry
   *
   * @param request LicenseRegistryProxiableUuidRequest
   * @return Promise<LicenseRegistryProxiableUuidResponse>
   */)},{key:"proxiableUuid",value:(function(){var _proxiableUuid4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee136(){return _regeneratorRuntime().wrap(function _callee136$(_context136){while(1)switch(_context136.prev=_context136.next){case 0:_context136.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"proxiableUUID"});case 2:return _context136.abrupt("return",_context136.sent);case 3:case"end":return _context136.stop();}},_callee136,this);}));function proxiableUuid(){return _proxiableUuid4.apply(this,arguments);}return proxiableUuid;}()/**
   * method verifyGroupAddIp for contract LicenseRegistry
   *
   * @param request LicenseRegistryVerifyGroupAddIpRequest
   * @return Promise<LicenseRegistryVerifyGroupAddIpResponse>
   */)},{key:"verifyGroupAddIp",value:(function(){var _verifyGroupAddIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee137(request){var result;return _regeneratorRuntime().wrap(function _callee137$(_context137){while(1)switch(_context137.prev=_context137.next){case 0:_context137.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"verifyGroupAddIp",args:[request.groupId,request.groupRewardPool,request.ipId,request.groupLicenseTemplate,request.groupLicenseTermsId]});case 2:result=_context137.sent;return _context137.abrupt("return",{ipLicensingConfig:result});case 4:case"end":return _context137.stop();}},_callee137,this);}));function verifyGroupAddIp(_x84){return _verifyGroupAddIp.apply(this,arguments);}return verifyGroupAddIp;}()/**
   * method verifyMintLicenseToken for contract LicenseRegistry
   *
   * @param request LicenseRegistryVerifyMintLicenseTokenRequest
   * @return Promise<LicenseRegistryVerifyMintLicenseTokenResponse>
   */)},{key:"verifyMintLicenseToken",value:(function(){var _verifyMintLicenseToken=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee138(request){return _regeneratorRuntime().wrap(function _callee138$(_context138){while(1)switch(_context138.prev=_context138.next){case 0:_context138.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"verifyMintLicenseToken",args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.isMintedByIpOwner]});case 2:return _context138.abrupt("return",_context138.sent);case 3:case"end":return _context138.stop();}},_callee138,this);}));function verifyMintLicenseToken(_x85){return _verifyMintLicenseToken.apply(this,arguments);}return verifyMintLicenseToken;}())}]);}(LicenseRegistryEventClient);/**
 * LicenseTokenOwnerOfRequest
 *
 * @param tokenId uint256
 */ /**
 * contract LicenseToken readonly method
 */var LicenseTokenReadOnlyClient=/*#__PURE__*/function(){function LicenseTokenReadOnlyClient(rpcClient,address){var _rpcClient$chain14;_classCallCheck(this,LicenseTokenReadOnlyClient);this.address=address||getAddress(licenseTokenAddress,(_rpcClient$chain14=rpcClient.chain)===null||_rpcClient$chain14===void 0?void 0:_rpcClient$chain14.id);this.rpcClient=rpcClient;}/**
   * method ownerOf for contract LicenseToken
   *
   * @param request LicenseTokenOwnerOfRequest
   * @return Promise<LicenseTokenOwnerOfResponse>
   */return _createClass(LicenseTokenReadOnlyClient,[{key:"ownerOf",value:(function(){var _ownerOf=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee148(request){return _regeneratorRuntime().wrap(function _callee148$(_context148){while(1)switch(_context148.prev=_context148.next){case 0:_context148.next=2;return this.rpcClient.readContract({abi:licenseTokenAbi,address:this.address,functionName:"ownerOf",args:[request.tokenId]});case 2:return _context148.abrupt("return",_context148.sent);case 3:case"end":return _context148.stop();}},_callee148,this);}));function ownerOf(_x95){return _ownerOf.apply(this,arguments);}return ownerOf;}())}]);}();// Contract LicensingModule =============================================================
/**
 * LicensingModuleLicenseTermsAttachedEvent
 *
 * @param caller address
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicensingModuleLicenseTokensMintedEvent
 *
 * @param caller address
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param startLicenseTokenId uint256
 */ /**
 * LicensingModulePredictMintingLicenseFeeRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param royaltyContext bytes
 */ /**
 * LicensingModulePredictMintingLicenseFeeResponse
 *
 * @param currencyToken address
 * @param tokenAmount uint256
 */ /**
 * LicensingModuleAttachLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */ /**
 * LicensingModuleMintLicenseTokensRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param royaltyContext bytes
 * @param maxMintingFee uint256
 * @param maxRevenueShare uint32
 */ /**
 * LicensingModuleRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param licenseTemplate address
 * @param royaltyContext bytes
 * @param maxMintingFee uint256
 * @param maxRts uint32
 * @param maxRevenueShare uint32
 */ /**
 * LicensingModuleRegisterDerivativeWithLicenseTokensRequest
 *
 * @param childIpId address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 */ /**
 * LicensingModuleSetLicensingConfigRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param licensingConfig tuple
 */ /**
 * contract LicensingModule event
 */var LicensingModuleEventClient=/*#__PURE__*/function(){function LicensingModuleEventClient(rpcClient,address){var _rpcClient$chain15;_classCallCheck(this,LicensingModuleEventClient);this.address=address||getAddress(licensingModuleAddress,(_rpcClient$chain15=rpcClient.chain)===null||_rpcClient$chain15===void 0?void 0:_rpcClient$chain15.id);this.rpcClient=rpcClient;}/**
   * event LicenseTermsAttached for contract LicensingModule
   */return _createClass(LicensingModuleEventClient,[{key:"watchLicenseTermsAttachedEvent",value:function watchLicenseTermsAttachedEvent(_onLogs36){return this.rpcClient.watchContractEvent({abi:licensingModuleAbi,address:this.address,eventName:"LicenseTermsAttached",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs36(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTermsAttached for contract LicensingModule
   */},{key:"parseTxLicenseTermsAttachedEvent",value:function parseTxLicenseTermsAttachedEvent(txReceipt){var targetLogs=[];var _iterator36=_createForOfIteratorHelper(txReceipt.logs),_step36;try{for(_iterator36.s();!(_step36=_iterator36.n()).done;){var log=_step36.value;try{var event=decodeEventLog({abi:licensingModuleAbi,eventName:"LicenseTermsAttached",data:log.data,topics:log.topics});if(event.eventName==="LicenseTermsAttached"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator36.e(err);}finally{_iterator36.f();}return targetLogs;}/**
   * event LicenseTokensMinted for contract LicensingModule
   */},{key:"watchLicenseTokensMintedEvent",value:function watchLicenseTokensMintedEvent(_onLogs37){return this.rpcClient.watchContractEvent({abi:licensingModuleAbi,address:this.address,eventName:"LicenseTokensMinted",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs37(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTokensMinted for contract LicensingModule
   */},{key:"parseTxLicenseTokensMintedEvent",value:function parseTxLicenseTokensMintedEvent(txReceipt){var targetLogs=[];var _iterator37=_createForOfIteratorHelper(txReceipt.logs),_step37;try{for(_iterator37.s();!(_step37=_iterator37.n()).done;){var log=_step37.value;try{var event=decodeEventLog({abi:licensingModuleAbi,eventName:"LicenseTokensMinted",data:log.data,topics:log.topics});if(event.eventName==="LicenseTokensMinted"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator37.e(err);}finally{_iterator37.f();}return targetLogs;}}]);}();/**
 * contract LicensingModule readonly method
 */var LicensingModuleReadOnlyClient=/*#__PURE__*/function(_LicensingModuleEvent){function LicensingModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,LicensingModuleReadOnlyClient);return _callSuper(this,LicensingModuleReadOnlyClient,[rpcClient,address]);}/**
   * method predictMintingLicenseFee for contract LicensingModule
   *
   * @param request LicensingModulePredictMintingLicenseFeeRequest
   * @return Promise<LicensingModulePredictMintingLicenseFeeResponse>
   */_inherits(LicensingModuleReadOnlyClient,_LicensingModuleEvent);return _createClass(LicensingModuleReadOnlyClient,[{key:"predictMintingLicenseFee",value:(function(){var _predictMintingLicenseFee=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee149(request){var result;return _regeneratorRuntime().wrap(function _callee149$(_context149){while(1)switch(_context149.prev=_context149.next){case 0:_context149.next=2;return this.rpcClient.readContract({abi:licensingModuleAbi,address:this.address,functionName:"predictMintingLicenseFee",args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext]});case 2:result=_context149.sent;return _context149.abrupt("return",{currencyToken:result[0],tokenAmount:result[1]});case 4:case"end":return _context149.stop();}},_callee149,this);}));function predictMintingLicenseFee(_x96){return _predictMintingLicenseFee.apply(this,arguments);}return predictMintingLicenseFee;}())}]);}(LicensingModuleEventClient);/**
 * contract LicensingModule write method
 */var LicensingModuleClient=/*#__PURE__*/function(_LicensingModuleReadO){function LicensingModuleClient(rpcClient,wallet,address){var _this9;_classCallCheck(this,LicensingModuleClient);_this9=_callSuper(this,LicensingModuleClient,[rpcClient,address]);_this9.wallet=wallet;return _this9;}/**
   * method attachLicenseTerms for contract LicensingModule
   *
   * @param request LicensingModuleAttachLicenseTermsRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(LicensingModuleClient,_LicensingModuleReadO);return _createClass(LicensingModuleClient,[{key:"attachLicenseTerms",value:(function(){var _attachLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee150(request){var _yield$this$rpcClient62,call;return _regeneratorRuntime().wrap(function _callee150$(_context150){while(1)switch(_context150.prev=_context150.next){case 0:_context150.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"attachLicenseTerms",account:this.wallet.account,args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 2:_yield$this$rpcClient62=_context150.sent;call=_yield$this$rpcClient62.request;_context150.next=6;return this.wallet.writeContract(call);case 6:return _context150.abrupt("return",_context150.sent);case 7:case"end":return _context150.stop();}},_callee150,this);}));function attachLicenseTerms(_x97){return _attachLicenseTerms.apply(this,arguments);}return attachLicenseTerms;}()/**
   * method attachLicenseTerms for contract LicensingModule with only encode
   *
   * @param request LicensingModuleAttachLicenseTermsRequest
   * @return EncodedTxData
   */)},{key:"attachLicenseTermsEncode",value:function attachLicenseTermsEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"attachLicenseTerms",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]})};}/**
   * method mintLicenseTokens for contract LicensingModule
   *
   * @param request LicensingModuleMintLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintLicenseTokens",value:(function(){var _mintLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee151(request){var _yield$this$rpcClient63,call;return _regeneratorRuntime().wrap(function _callee151$(_context151){while(1)switch(_context151.prev=_context151.next){case 0:_context151.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"mintLicenseTokens",account:this.wallet.account,args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext,request.maxMintingFee,request.maxRevenueShare]});case 2:_yield$this$rpcClient63=_context151.sent;call=_yield$this$rpcClient63.request;_context151.next=6;return this.wallet.writeContract(call);case 6:return _context151.abrupt("return",_context151.sent);case 7:case"end":return _context151.stop();}},_callee151,this);}));function mintLicenseTokens(_x98){return _mintLicenseTokens.apply(this,arguments);}return mintLicenseTokens;}()/**
   * method mintLicenseTokens for contract LicensingModule with only encode
   *
   * @param request LicensingModuleMintLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"mintLicenseTokensEncode",value:function mintLicenseTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"mintLicenseTokens",args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext,request.maxMintingFee,request.maxRevenueShare]})};}/**
   * method registerDerivative for contract LicensingModule
   *
   * @param request LicensingModuleRegisterDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerDerivative",value:(function(){var _registerDerivative=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee152(request){var _yield$this$rpcClient64,call;return _regeneratorRuntime().wrap(function _callee152$(_context152){while(1)switch(_context152.prev=_context152.next){case 0:_context152.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"registerDerivative",account:this.wallet.account,args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.licenseTemplate,request.royaltyContext,request.maxMintingFee,request.maxRts,request.maxRevenueShare]});case 2:_yield$this$rpcClient64=_context152.sent;call=_yield$this$rpcClient64.request;_context152.next=6;return this.wallet.writeContract(call);case 6:return _context152.abrupt("return",_context152.sent);case 7:case"end":return _context152.stop();}},_callee152,this);}));function registerDerivative(_x99){return _registerDerivative.apply(this,arguments);}return registerDerivative;}()/**
   * method registerDerivative for contract LicensingModule with only encode
   *
   * @param request LicensingModuleRegisterDerivativeRequest
   * @return EncodedTxData
   */)},{key:"registerDerivativeEncode",value:function registerDerivativeEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"registerDerivative",args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.licenseTemplate,request.royaltyContext,request.maxMintingFee,request.maxRts,request.maxRevenueShare]})};}/**
   * method registerDerivativeWithLicenseTokens for contract LicensingModule
   *
   * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerDerivativeWithLicenseTokens",value:(function(){var _registerDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee153(request){var _yield$this$rpcClient65,call;return _regeneratorRuntime().wrap(function _callee153$(_context153){while(1)switch(_context153.prev=_context153.next){case 0:_context153.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"registerDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.childIpId,request.licenseTokenIds,request.royaltyContext,request.maxRts]});case 2:_yield$this$rpcClient65=_context153.sent;call=_yield$this$rpcClient65.request;_context153.next=6;return this.wallet.writeContract(call);case 6:return _context153.abrupt("return",_context153.sent);case 7:case"end":return _context153.stop();}},_callee153,this);}));function registerDerivativeWithLicenseTokens(_x100){return _registerDerivativeWithLicenseTokens.apply(this,arguments);}return registerDerivativeWithLicenseTokens;}()/**
   * method registerDerivativeWithLicenseTokens for contract LicensingModule with only encode
   *
   * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"registerDerivativeWithLicenseTokensEncode",value:function registerDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"registerDerivativeWithLicenseTokens",args:[request.childIpId,request.licenseTokenIds,request.royaltyContext,request.maxRts]})};}/**
   * method setLicensingConfig for contract LicensingModule
   *
   * @param request LicensingModuleSetLicensingConfigRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setLicensingConfig",value:(function(){var _setLicensingConfig=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee154(request){var _yield$this$rpcClient66,call;return _regeneratorRuntime().wrap(function _callee154$(_context154){while(1)switch(_context154.prev=_context154.next){case 0:_context154.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"setLicensingConfig",account:this.wallet.account,args:[request.ipId,request.licenseTemplate,request.licenseTermsId,request.licensingConfig]});case 2:_yield$this$rpcClient66=_context154.sent;call=_yield$this$rpcClient66.request;_context154.next=6;return this.wallet.writeContract(call);case 6:return _context154.abrupt("return",_context154.sent);case 7:case"end":return _context154.stop();}},_callee154,this);}));function setLicensingConfig(_x101){return _setLicensingConfig.apply(this,arguments);}return setLicensingConfig;}()/**
   * method setLicensingConfig for contract LicensingModule with only encode
   *
   * @param request LicensingModuleSetLicensingConfigRequest
   * @return EncodedTxData
   */)},{key:"setLicensingConfigEncode",value:function setLicensingConfigEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"setLicensingConfig",args:[request.ipId,request.licenseTemplate,request.licenseTermsId,request.licensingConfig]})};}}]);}(LicensingModuleReadOnlyClient);// Contract MockERC20 =============================================================
/**
 * ModuleRegistryIsRegisteredRequest
 *
 * @param moduleAddress address
 */ /**
 * contract ModuleRegistry readonly method
 */var ModuleRegistryReadOnlyClient=/*#__PURE__*/function(){function ModuleRegistryReadOnlyClient(rpcClient,address){var _rpcClient$chain17;_classCallCheck(this,ModuleRegistryReadOnlyClient);this.address=address||getAddress(moduleRegistryAddress,(_rpcClient$chain17=rpcClient.chain)===null||_rpcClient$chain17===void 0?void 0:_rpcClient$chain17.id);this.rpcClient=rpcClient;}/**
   * method isRegistered for contract ModuleRegistry
   *
   * @param request ModuleRegistryIsRegisteredRequest
   * @return Promise<ModuleRegistryIsRegisteredResponse>
   */return _createClass(ModuleRegistryReadOnlyClient,[{key:"isRegistered",value:(function(){var _isRegistered2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee166(request){return _regeneratorRuntime().wrap(function _callee166$(_context166){while(1)switch(_context166.prev=_context166.next){case 0:_context166.next=2;return this.rpcClient.readContract({abi:moduleRegistryAbi,address:this.address,functionName:"isRegistered",args:[request.moduleAddress]});case 2:return _context166.abrupt("return",_context166.sent);case 3:case"end":return _context166.stop();}},_callee166,this);}));function isRegistered(_x109){return _isRegistered2.apply(this,arguments);}return isRegistered;}())}]);}();// Contract Multicall3 =============================================================
/**
 * Multicall3Aggregate3Request
 *
 * @param calls tuple[]
 */ /**
 * contract Multicall3 write method
 */var Multicall3Client=/*#__PURE__*/function(){function Multicall3Client(rpcClient,wallet,address){var _rpcClient$chain18;_classCallCheck(this,Multicall3Client);this.address=address||getAddress(multicall3Address,(_rpcClient$chain18=rpcClient.chain)===null||_rpcClient$chain18===void 0?void 0:_rpcClient$chain18.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method aggregate3 for contract Multicall3
   *
   * @param request Multicall3Aggregate3Request
   * @return Promise<WriteContractReturnType>
   */return _createClass(Multicall3Client,[{key:"aggregate3",value:(function(){var _aggregate=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee167(request){var _yield$this$rpcClient72,call;return _regeneratorRuntime().wrap(function _callee167$(_context167){while(1)switch(_context167.prev=_context167.next){case 0:_context167.next=2;return this.rpcClient.simulateContract({abi:multicall3Abi,address:this.address,functionName:"aggregate3",account:this.wallet.account,args:[request.calls]});case 2:_yield$this$rpcClient72=_context167.sent;call=_yield$this$rpcClient72.request;_context167.next=6;return this.wallet.writeContract(call);case 6:return _context167.abrupt("return",_context167.sent);case 7:case"end":return _context167.stop();}},_callee167,this);}));function aggregate3(_x110){return _aggregate.apply(this,arguments);}return aggregate3;}()/**
   * method aggregate3 for contract Multicall3 with only encode
   *
   * @param request Multicall3Aggregate3Request
   * @return EncodedTxData
   */)},{key:"aggregate3Encode",value:function aggregate3Encode(request){return {to:this.address,data:encodeFunctionData({abi:multicall3Abi,functionName:"aggregate3",args:[request.calls]})};}}]);}();// Contract PILicenseTemplate =============================================================
/**
 * PiLicenseTemplateAuthorityUpdatedEvent
 *
 * @param authority address
 */ /**
 * PiLicenseTemplateDerivativeApprovedEvent
 *
 * @param licenseTermsId uint256
 * @param ipId address
 * @param caller address
 * @param approved bool
 */ /**
 * PiLicenseTemplateInitializedEvent
 *
 * @param version uint64
 */ /**
 * PiLicenseTemplateLicenseTermsRegisteredEvent
 *
 * @param licenseTermsId uint256
 * @param licenseTemplate address
 * @param licenseTerms bytes
 */ /**
 * PiLicenseTemplateUpgradedEvent
 *
 * @param implementation address
 */ /**
 * PiLicenseTemplateAllowDerivativeRegistrationRequest
 *
 * @param licenseTermsId uint256
 */ /**
 * PiLicenseTemplateCanAttachToGroupIpRequest
 *
 * @param licenseTermsId uint256
 */ /**
 * PiLicenseTemplateCanOverrideRoyaltyPercentRequest
 *
 * @param licenseTermsId uint256
 * @param newRoyaltyPercent uint32
 */ /**
 * PiLicenseTemplateExistsRequest
 *
 * @param licenseTermsId uint256
 */ /**
 * PiLicenseTemplateGetEarlierExpireTimeRequest
 *
 * @param licenseTermsIds uint256[]
 * @param start uint256
 */ /**
 * PiLicenseTemplateGetExpireTimeRequest
 *
 * @param licenseTermsId uint256
 * @param start uint256
 */ /**
 * PiLicenseTemplateGetLicenseTermsRequest
 *
 * @param selectedLicenseTermsId uint256
 */ /**
 * PiLicenseTemplateGetLicenseTermsResponse
 *
 * @param terms tuple
 */ /**
 * PiLicenseTemplateGetLicenseTermsIdRequest
 *
 * @param terms tuple
 */ /**
 * PiLicenseTemplateGetLicenseTermsIdResponse
 *
 * @param selectedLicenseTermsId uint256
 */ /**
 * PiLicenseTemplateGetLicenseTermsUriRequest
 *
 * @param licenseTermsId uint256
 */ /**
 * PiLicenseTemplateGetRoyaltyPolicyRequest
 *
 * @param licenseTermsId uint256
 */ /**
 * PiLicenseTemplateGetRoyaltyPolicyResponse
 *
 * @param royaltyPolicy address
 * @param royaltyPercent uint32
 * @param mintingFee uint256
 * @param currency address
 */ /**
 * PiLicenseTemplateIsDerivativeApprovedRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 */ /**
 * PiLicenseTemplateIsLicenseTransferableRequest
 *
 * @param licenseTermsId uint256
 */ /**
 * PiLicenseTemplateSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 */ /**
 * PiLicenseTemplateToJsonRequest
 *
 * @param licenseTermsId uint256
 */ /**
 * PiLicenseTemplateVerifyCompatibleLicensesRequest
 *
 * @param licenseTermsIds uint256[]
 */ /**
 * PiLicenseTemplateInitializeRequest
 *
 * @param accessManager address
 * @param name string
 * @param metadataURI string
 */ /**
 * PiLicenseTemplateRegisterLicenseTermsRequest
 *
 * @param terms tuple
 */ /**
 * PiLicenseTemplateSetApprovalRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 * @param approved bool
 */ /**
 * PiLicenseTemplateSetAuthorityRequest
 *
 * @param newAuthority address
 */ /**
 * PiLicenseTemplateUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */ /**
 * PiLicenseTemplateVerifyMintLicenseTokenRequest
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 address
 * @param 3 uint256
 */ /**
 * PiLicenseTemplateVerifyRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param licensee address
 */ /**
 * PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param caller address
 */ /**
 * contract PILicenseTemplate event
 */var PiLicenseTemplateEventClient=/*#__PURE__*/function(){function PiLicenseTemplateEventClient(rpcClient,address){var _rpcClient$chain19;_classCallCheck(this,PiLicenseTemplateEventClient);this.address=address||getAddress(piLicenseTemplateAddress,(_rpcClient$chain19=rpcClient.chain)===null||_rpcClient$chain19===void 0?void 0:_rpcClient$chain19.id);this.rpcClient=rpcClient;}/**
   * event AuthorityUpdated for contract PILicenseTemplate
   */return _createClass(PiLicenseTemplateEventClient,[{key:"watchAuthorityUpdatedEvent",value:function watchAuthorityUpdatedEvent(_onLogs40){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"AuthorityUpdated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs40(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AuthorityUpdated for contract PILicenseTemplate
   */},{key:"parseTxAuthorityUpdatedEvent",value:function parseTxAuthorityUpdatedEvent(txReceipt){var targetLogs=[];var _iterator40=_createForOfIteratorHelper(txReceipt.logs),_step40;try{for(_iterator40.s();!(_step40=_iterator40.n()).done;){var log=_step40.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"AuthorityUpdated",data:log.data,topics:log.topics});if(event.eventName==="AuthorityUpdated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator40.e(err);}finally{_iterator40.f();}return targetLogs;}/**
   * event DerivativeApproved for contract PILicenseTemplate
   */},{key:"watchDerivativeApprovedEvent",value:function watchDerivativeApprovedEvent(_onLogs41){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"DerivativeApproved",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs41(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DerivativeApproved for contract PILicenseTemplate
   */},{key:"parseTxDerivativeApprovedEvent",value:function parseTxDerivativeApprovedEvent(txReceipt){var targetLogs=[];var _iterator41=_createForOfIteratorHelper(txReceipt.logs),_step41;try{for(_iterator41.s();!(_step41=_iterator41.n()).done;){var log=_step41.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"DerivativeApproved",data:log.data,topics:log.topics});if(event.eventName==="DerivativeApproved"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator41.e(err);}finally{_iterator41.f();}return targetLogs;}/**
   * event Initialized for contract PILicenseTemplate
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs42){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs42(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract PILicenseTemplate
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator42=_createForOfIteratorHelper(txReceipt.logs),_step42;try{for(_iterator42.s();!(_step42=_iterator42.n()).done;){var log=_step42.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator42.e(err);}finally{_iterator42.f();}return targetLogs;}/**
   * event LicenseTermsRegistered for contract PILicenseTemplate
   */},{key:"watchLicenseTermsRegisteredEvent",value:function watchLicenseTermsRegisteredEvent(_onLogs43){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"LicenseTermsRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs43(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTermsRegistered for contract PILicenseTemplate
   */},{key:"parseTxLicenseTermsRegisteredEvent",value:function parseTxLicenseTermsRegisteredEvent(txReceipt){var targetLogs=[];var _iterator43=_createForOfIteratorHelper(txReceipt.logs),_step43;try{for(_iterator43.s();!(_step43=_iterator43.n()).done;){var log=_step43.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"LicenseTermsRegistered",data:log.data,topics:log.topics});if(event.eventName==="LicenseTermsRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator43.e(err);}finally{_iterator43.f();}return targetLogs;}/**
   * event Upgraded for contract PILicenseTemplate
   */},{key:"watchUpgradedEvent",value:function watchUpgradedEvent(_onLogs44){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"Upgraded",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs44(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Upgraded for contract PILicenseTemplate
   */},{key:"parseTxUpgradedEvent",value:function parseTxUpgradedEvent(txReceipt){var targetLogs=[];var _iterator44=_createForOfIteratorHelper(txReceipt.logs),_step44;try{for(_iterator44.s();!(_step44=_iterator44.n()).done;){var log=_step44.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"Upgraded",data:log.data,topics:log.topics});if(event.eventName==="Upgraded"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator44.e(err);}finally{_iterator44.f();}return targetLogs;}}]);}();/**
 * contract PILicenseTemplate readonly method
 */var PiLicenseTemplateReadOnlyClient=/*#__PURE__*/function(_PiLicenseTemplateEve){function PiLicenseTemplateReadOnlyClient(rpcClient,address){_classCallCheck(this,PiLicenseTemplateReadOnlyClient);return _callSuper(this,PiLicenseTemplateReadOnlyClient,[rpcClient,address]);}/**
   * method ACCESS_CONTROLLER for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAccessControllerRequest
   * @return Promise<PiLicenseTemplateAccessControllerResponse>
   */_inherits(PiLicenseTemplateReadOnlyClient,_PiLicenseTemplateEve);return _createClass(PiLicenseTemplateReadOnlyClient,[{key:"accessController",value:(function(){var _accessController3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee168(){return _regeneratorRuntime().wrap(function _callee168$(_context168){while(1)switch(_context168.prev=_context168.next){case 0:_context168.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"ACCESS_CONTROLLER"});case 2:return _context168.abrupt("return",_context168.sent);case 3:case"end":return _context168.stop();}},_callee168,this);}));function accessController(){return _accessController3.apply(this,arguments);}return accessController;}()/**
   * method IP_ASSET_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIpAssetRegistryRequest
   * @return Promise<PiLicenseTemplateIpAssetRegistryResponse>
   */)},{key:"ipAssetRegistry",value:(function(){var _ipAssetRegistry3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee169(){return _regeneratorRuntime().wrap(function _callee169$(_context169){while(1)switch(_context169.prev=_context169.next){case 0:_context169.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"IP_ASSET_REGISTRY"});case 2:return _context169.abrupt("return",_context169.sent);case 3:case"end":return _context169.stop();}},_callee169,this);}));function ipAssetRegistry(){return _ipAssetRegistry3.apply(this,arguments);}return ipAssetRegistry;}()/**
   * method LICENSE_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateLicenseRegistryRequest
   * @return Promise<PiLicenseTemplateLicenseRegistryResponse>
   */)},{key:"licenseRegistry",value:(function(){var _licenseRegistry2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee170(){return _regeneratorRuntime().wrap(function _callee170$(_context170){while(1)switch(_context170.prev=_context170.next){case 0:_context170.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"LICENSE_REGISTRY"});case 2:return _context170.abrupt("return",_context170.sent);case 3:case"end":return _context170.stop();}},_callee170,this);}));function licenseRegistry(){return _licenseRegistry2.apply(this,arguments);}return licenseRegistry;}()/**
   * method MODULE_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateModuleRegistryRequest
   * @return Promise<PiLicenseTemplateModuleRegistryResponse>
   */)},{key:"moduleRegistry",value:(function(){var _moduleRegistry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee171(){return _regeneratorRuntime().wrap(function _callee171$(_context171){while(1)switch(_context171.prev=_context171.next){case 0:_context171.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"MODULE_REGISTRY"});case 2:return _context171.abrupt("return",_context171.sent);case 3:case"end":return _context171.stop();}},_callee171,this);}));function moduleRegistry(){return _moduleRegistry.apply(this,arguments);}return moduleRegistry;}()/**
   * method ROYALTY_MODULE for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateRoyaltyModuleRequest
   * @return Promise<PiLicenseTemplateRoyaltyModuleResponse>
   */)},{key:"royaltyModule",value:(function(){var _royaltyModule3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee172(){return _regeneratorRuntime().wrap(function _callee172$(_context172){while(1)switch(_context172.prev=_context172.next){case 0:_context172.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"ROYALTY_MODULE"});case 2:return _context172.abrupt("return",_context172.sent);case 3:case"end":return _context172.stop();}},_callee172,this);}));function royaltyModule(){return _royaltyModule3.apply(this,arguments);}return royaltyModule;}()/**
   * method TERMS_RENDERER for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateTermsRendererRequest
   * @return Promise<PiLicenseTemplateTermsRendererResponse>
   */)},{key:"termsRenderer",value:(function(){var _termsRenderer=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee173(){return _regeneratorRuntime().wrap(function _callee173$(_context173){while(1)switch(_context173.prev=_context173.next){case 0:_context173.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"TERMS_RENDERER"});case 2:return _context173.abrupt("return",_context173.sent);case 3:case"end":return _context173.stop();}},_callee173,this);}));function termsRenderer(){return _termsRenderer.apply(this,arguments);}return termsRenderer;}()/**
   * method UPGRADE_INTERFACE_VERSION for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateUpgradeInterfaceVersionRequest
   * @return Promise<PiLicenseTemplateUpgradeInterfaceVersionResponse>
   */)},{key:"upgradeInterfaceVersion",value:(function(){var _upgradeInterfaceVersion5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee174(){return _regeneratorRuntime().wrap(function _callee174$(_context174){while(1)switch(_context174.prev=_context174.next){case 0:_context174.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"UPGRADE_INTERFACE_VERSION"});case 2:return _context174.abrupt("return",_context174.sent);case 3:case"end":return _context174.stop();}},_callee174,this);}));function upgradeInterfaceVersion(){return _upgradeInterfaceVersion5.apply(this,arguments);}return upgradeInterfaceVersion;}()/**
   * method allowDerivativeRegistration for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAllowDerivativeRegistrationRequest
   * @return Promise<PiLicenseTemplateAllowDerivativeRegistrationResponse>
   */)},{key:"allowDerivativeRegistration",value:(function(){var _allowDerivativeRegistration=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee175(request){return _regeneratorRuntime().wrap(function _callee175$(_context175){while(1)switch(_context175.prev=_context175.next){case 0:_context175.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"allowDerivativeRegistration",args:[request.licenseTermsId]});case 2:return _context175.abrupt("return",_context175.sent);case 3:case"end":return _context175.stop();}},_callee175,this);}));function allowDerivativeRegistration(_x111){return _allowDerivativeRegistration.apply(this,arguments);}return allowDerivativeRegistration;}()/**
   * method authority for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAuthorityRequest
   * @return Promise<PiLicenseTemplateAuthorityResponse>
   */)},{key:"authority",value:(function(){var _authority5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee176(){return _regeneratorRuntime().wrap(function _callee176$(_context176){while(1)switch(_context176.prev=_context176.next){case 0:_context176.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"authority"});case 2:return _context176.abrupt("return",_context176.sent);case 3:case"end":return _context176.stop();}},_callee176,this);}));function authority(){return _authority5.apply(this,arguments);}return authority;}()/**
   * method canAttachToGroupIp for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateCanAttachToGroupIpRequest
   * @return Promise<PiLicenseTemplateCanAttachToGroupIpResponse>
   */)},{key:"canAttachToGroupIp",value:(function(){var _canAttachToGroupIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee177(request){return _regeneratorRuntime().wrap(function _callee177$(_context177){while(1)switch(_context177.prev=_context177.next){case 0:_context177.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"canAttachToGroupIp",args:[request.licenseTermsId]});case 2:return _context177.abrupt("return",_context177.sent);case 3:case"end":return _context177.stop();}},_callee177,this);}));function canAttachToGroupIp(_x112){return _canAttachToGroupIp.apply(this,arguments);}return canAttachToGroupIp;}()/**
   * method canOverrideRoyaltyPercent for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateCanOverrideRoyaltyPercentRequest
   * @return Promise<PiLicenseTemplateCanOverrideRoyaltyPercentResponse>
   */)},{key:"canOverrideRoyaltyPercent",value:(function(){var _canOverrideRoyaltyPercent=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee178(request){return _regeneratorRuntime().wrap(function _callee178$(_context178){while(1)switch(_context178.prev=_context178.next){case 0:_context178.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"canOverrideRoyaltyPercent",args:[request.licenseTermsId,request.newRoyaltyPercent]});case 2:return _context178.abrupt("return",_context178.sent);case 3:case"end":return _context178.stop();}},_callee178,this);}));function canOverrideRoyaltyPercent(_x113){return _canOverrideRoyaltyPercent.apply(this,arguments);}return canOverrideRoyaltyPercent;}()/**
   * method exists for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateExistsRequest
   * @return Promise<PiLicenseTemplateExistsResponse>
   */)},{key:"exists",value:(function(){var _exists2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee179(request){return _regeneratorRuntime().wrap(function _callee179$(_context179){while(1)switch(_context179.prev=_context179.next){case 0:_context179.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"exists",args:[request.licenseTermsId]});case 2:return _context179.abrupt("return",_context179.sent);case 3:case"end":return _context179.stop();}},_callee179,this);}));function exists(_x114){return _exists2.apply(this,arguments);}return exists;}()/**
   * method getEarlierExpireTime for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetEarlierExpireTimeRequest
   * @return Promise<PiLicenseTemplateGetEarlierExpireTimeResponse>
   */)},{key:"getEarlierExpireTime",value:(function(){var _getEarlierExpireTime=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee180(request){return _regeneratorRuntime().wrap(function _callee180$(_context180){while(1)switch(_context180.prev=_context180.next){case 0:_context180.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getEarlierExpireTime",args:[request.licenseTermsIds,request.start]});case 2:return _context180.abrupt("return",_context180.sent);case 3:case"end":return _context180.stop();}},_callee180,this);}));function getEarlierExpireTime(_x115){return _getEarlierExpireTime.apply(this,arguments);}return getEarlierExpireTime;}()/**
   * method getExpireTime for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetExpireTimeRequest
   * @return Promise<PiLicenseTemplateGetExpireTimeResponse>
   */)},{key:"getExpireTime",value:(function(){var _getExpireTime2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee181(request){return _regeneratorRuntime().wrap(function _callee181$(_context181){while(1)switch(_context181.prev=_context181.next){case 0:_context181.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getExpireTime",args:[request.licenseTermsId,request.start]});case 2:return _context181.abrupt("return",_context181.sent);case 3:case"end":return _context181.stop();}},_callee181,this);}));function getExpireTime(_x116){return _getExpireTime2.apply(this,arguments);}return getExpireTime;}()/**
   * method getLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsResponse>
   */)},{key:"getLicenseTerms",value:(function(){var _getLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee182(request){var result;return _regeneratorRuntime().wrap(function _callee182$(_context182){while(1)switch(_context182.prev=_context182.next){case 0:_context182.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTerms",args:[request.selectedLicenseTermsId]});case 2:result=_context182.sent;return _context182.abrupt("return",{terms:result});case 4:case"end":return _context182.stop();}},_callee182,this);}));function getLicenseTerms(_x117){return _getLicenseTerms.apply(this,arguments);}return getLicenseTerms;}()/**
   * method getLicenseTermsId for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsIdRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsIdResponse>
   */)},{key:"getLicenseTermsId",value:(function(){var _getLicenseTermsId=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee183(request){var result;return _regeneratorRuntime().wrap(function _callee183$(_context183){while(1)switch(_context183.prev=_context183.next){case 0:_context183.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTermsId",args:[request.terms]});case 2:result=_context183.sent;return _context183.abrupt("return",{selectedLicenseTermsId:result});case 4:case"end":return _context183.stop();}},_callee183,this);}));function getLicenseTermsId(_x118){return _getLicenseTermsId.apply(this,arguments);}return getLicenseTermsId;}()/**
   * method getLicenseTermsURI for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsUriRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsUriResponse>
   */)},{key:"getLicenseTermsUri",value:(function(){var _getLicenseTermsUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee184(request){return _regeneratorRuntime().wrap(function _callee184$(_context184){while(1)switch(_context184.prev=_context184.next){case 0:_context184.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTermsURI",args:[request.licenseTermsId]});case 2:return _context184.abrupt("return",_context184.sent);case 3:case"end":return _context184.stop();}},_callee184,this);}));function getLicenseTermsUri(_x119){return _getLicenseTermsUri.apply(this,arguments);}return getLicenseTermsUri;}()/**
   * method getMetadataURI for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetMetadataUriRequest
   * @return Promise<PiLicenseTemplateGetMetadataUriResponse>
   */)},{key:"getMetadataUri",value:(function(){var _getMetadataUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee185(){return _regeneratorRuntime().wrap(function _callee185$(_context185){while(1)switch(_context185.prev=_context185.next){case 0:_context185.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getMetadataURI"});case 2:return _context185.abrupt("return",_context185.sent);case 3:case"end":return _context185.stop();}},_callee185,this);}));function getMetadataUri(){return _getMetadataUri.apply(this,arguments);}return getMetadataUri;}()/**
   * method getRoyaltyPolicy for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetRoyaltyPolicyRequest
   * @return Promise<PiLicenseTemplateGetRoyaltyPolicyResponse>
   */)},{key:"getRoyaltyPolicy",value:(function(){var _getRoyaltyPolicy=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee186(request){var result;return _regeneratorRuntime().wrap(function _callee186$(_context186){while(1)switch(_context186.prev=_context186.next){case 0:_context186.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getRoyaltyPolicy",args:[request.licenseTermsId]});case 2:result=_context186.sent;return _context186.abrupt("return",{royaltyPolicy:result[0],royaltyPercent:result[1],mintingFee:result[2],currency:result[3]});case 4:case"end":return _context186.stop();}},_callee186,this);}));function getRoyaltyPolicy(_x120){return _getRoyaltyPolicy.apply(this,arguments);}return getRoyaltyPolicy;}()/**
   * method isConsumingScheduledOp for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsConsumingScheduledOpRequest
   * @return Promise<PiLicenseTemplateIsConsumingScheduledOpResponse>
   */)},{key:"isConsumingScheduledOp",value:(function(){var _isConsumingScheduledOp5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee187(){return _regeneratorRuntime().wrap(function _callee187$(_context187){while(1)switch(_context187.prev=_context187.next){case 0:_context187.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isConsumingScheduledOp"});case 2:return _context187.abrupt("return",_context187.sent);case 3:case"end":return _context187.stop();}},_callee187,this);}));function isConsumingScheduledOp(){return _isConsumingScheduledOp5.apply(this,arguments);}return isConsumingScheduledOp;}()/**
   * method isDerivativeApproved for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsDerivativeApprovedRequest
   * @return Promise<PiLicenseTemplateIsDerivativeApprovedResponse>
   */)},{key:"isDerivativeApproved",value:(function(){var _isDerivativeApproved=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee188(request){return _regeneratorRuntime().wrap(function _callee188$(_context188){while(1)switch(_context188.prev=_context188.next){case 0:_context188.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isDerivativeApproved",args:[request.parentIpId,request.licenseTermsId,request.childIpId]});case 2:return _context188.abrupt("return",_context188.sent);case 3:case"end":return _context188.stop();}},_callee188,this);}));function isDerivativeApproved(_x121){return _isDerivativeApproved.apply(this,arguments);}return isDerivativeApproved;}()/**
   * method isLicenseTransferable for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsLicenseTransferableRequest
   * @return Promise<PiLicenseTemplateIsLicenseTransferableResponse>
   */)},{key:"isLicenseTransferable",value:(function(){var _isLicenseTransferable=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee189(request){return _regeneratorRuntime().wrap(function _callee189$(_context189){while(1)switch(_context189.prev=_context189.next){case 0:_context189.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isLicenseTransferable",args:[request.licenseTermsId]});case 2:return _context189.abrupt("return",_context189.sent);case 3:case"end":return _context189.stop();}},_callee189,this);}));function isLicenseTransferable(_x122){return _isLicenseTransferable.apply(this,arguments);}return isLicenseTransferable;}()/**
   * method name for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateNameRequest
   * @return Promise<PiLicenseTemplateNameResponse>
   */)},{key:"name",value:(function(){var _name4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee190(){return _regeneratorRuntime().wrap(function _callee190$(_context190){while(1)switch(_context190.prev=_context190.next){case 0:_context190.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"name"});case 2:return _context190.abrupt("return",_context190.sent);case 3:case"end":return _context190.stop();}},_callee190,this);}));function name(){return _name4.apply(this,arguments);}return name;}()/**
   * method proxiableUUID for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateProxiableUuidRequest
   * @return Promise<PiLicenseTemplateProxiableUuidResponse>
   */)},{key:"proxiableUuid",value:(function(){var _proxiableUuid5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee191(){return _regeneratorRuntime().wrap(function _callee191$(_context191){while(1)switch(_context191.prev=_context191.next){case 0:_context191.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"proxiableUUID"});case 2:return _context191.abrupt("return",_context191.sent);case 3:case"end":return _context191.stop();}},_callee191,this);}));function proxiableUuid(){return _proxiableUuid5.apply(this,arguments);}return proxiableUuid;}()/**
   * method supportsInterface for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSupportsInterfaceRequest
   * @return Promise<PiLicenseTemplateSupportsInterfaceResponse>
   */)},{key:"supportsInterface",value:(function(){var _supportsInterface3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee192(request){return _regeneratorRuntime().wrap(function _callee192$(_context192){while(1)switch(_context192.prev=_context192.next){case 0:_context192.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"supportsInterface",args:[request.interfaceId]});case 2:return _context192.abrupt("return",_context192.sent);case 3:case"end":return _context192.stop();}},_callee192,this);}));function supportsInterface(_x123){return _supportsInterface3.apply(this,arguments);}return supportsInterface;}()/**
   * method toJson for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateToJsonRequest
   * @return Promise<PiLicenseTemplateToJsonResponse>
   */)},{key:"toJson",value:(function(){var _toJson=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee193(request){return _regeneratorRuntime().wrap(function _callee193$(_context193){while(1)switch(_context193.prev=_context193.next){case 0:_context193.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"toJson",args:[request.licenseTermsId]});case 2:return _context193.abrupt("return",_context193.sent);case 3:case"end":return _context193.stop();}},_callee193,this);}));function toJson(_x124){return _toJson.apply(this,arguments);}return toJson;}()/**
   * method totalRegisteredLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateTotalRegisteredLicenseTermsRequest
   * @return Promise<PiLicenseTemplateTotalRegisteredLicenseTermsResponse>
   */)},{key:"totalRegisteredLicenseTerms",value:(function(){var _totalRegisteredLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee194(){return _regeneratorRuntime().wrap(function _callee194$(_context194){while(1)switch(_context194.prev=_context194.next){case 0:_context194.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"totalRegisteredLicenseTerms"});case 2:return _context194.abrupt("return",_context194.sent);case 3:case"end":return _context194.stop();}},_callee194,this);}));function totalRegisteredLicenseTerms(){return _totalRegisteredLicenseTerms.apply(this,arguments);}return totalRegisteredLicenseTerms;}()/**
   * method verifyCompatibleLicenses for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyCompatibleLicensesRequest
   * @return Promise<PiLicenseTemplateVerifyCompatibleLicensesResponse>
   */)},{key:"verifyCompatibleLicenses",value:(function(){var _verifyCompatibleLicenses=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee195(request){return _regeneratorRuntime().wrap(function _callee195$(_context195){while(1)switch(_context195.prev=_context195.next){case 0:_context195.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyCompatibleLicenses",args:[request.licenseTermsIds]});case 2:return _context195.abrupt("return",_context195.sent);case 3:case"end":return _context195.stop();}},_callee195,this);}));function verifyCompatibleLicenses(_x125){return _verifyCompatibleLicenses.apply(this,arguments);}return verifyCompatibleLicenses;}())}]);}(PiLicenseTemplateEventClient);/**
 * contract PILicenseTemplate write method
 */var PiLicenseTemplateClient=/*#__PURE__*/function(_PiLicenseTemplateRea){function PiLicenseTemplateClient(rpcClient,wallet,address){var _this11;_classCallCheck(this,PiLicenseTemplateClient);_this11=_callSuper(this,PiLicenseTemplateClient,[rpcClient,address]);_this11.wallet=wallet;return _this11;}/**
   * method initialize for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateInitializeRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(PiLicenseTemplateClient,_PiLicenseTemplateRea);return _createClass(PiLicenseTemplateClient,[{key:"initialize",value:(function(){var _initialize5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee196(request){var _yield$this$rpcClient73,call;return _regeneratorRuntime().wrap(function _callee196$(_context196){while(1)switch(_context196.prev=_context196.next){case 0:_context196.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"initialize",account:this.wallet.account,args:[request.accessManager,request.name,request.metadataURI]});case 2:_yield$this$rpcClient73=_context196.sent;call=_yield$this$rpcClient73.request;_context196.next=6;return this.wallet.writeContract(call);case 6:return _context196.abrupt("return",_context196.sent);case 7:case"end":return _context196.stop();}},_callee196,this);}));function initialize(_x126){return _initialize5.apply(this,arguments);}return initialize;}()/**
   * method initialize for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateInitializeRequest
   * @return EncodedTxData
   */)},{key:"initializeEncode",value:function initializeEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"initialize",args:[request.accessManager,request.name,request.metadataURI]})};}/**
   * method registerLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateRegisterLicenseTermsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerLicenseTerms",value:(function(){var _registerLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee197(request){var _yield$this$rpcClient74,call;return _regeneratorRuntime().wrap(function _callee197$(_context197){while(1)switch(_context197.prev=_context197.next){case 0:_context197.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"registerLicenseTerms",account:this.wallet.account,args:[request.terms]});case 2:_yield$this$rpcClient74=_context197.sent;call=_yield$this$rpcClient74.request;_context197.next=6;return this.wallet.writeContract(call);case 6:return _context197.abrupt("return",_context197.sent);case 7:case"end":return _context197.stop();}},_callee197,this);}));function registerLicenseTerms(_x127){return _registerLicenseTerms.apply(this,arguments);}return registerLicenseTerms;}()/**
   * method registerLicenseTerms for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateRegisterLicenseTermsRequest
   * @return EncodedTxData
   */)},{key:"registerLicenseTermsEncode",value:function registerLicenseTermsEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"registerLicenseTerms",args:[request.terms]})};}/**
   * method setApproval for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSetApprovalRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setApproval",value:(function(){var _setApproval=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee198(request){var _yield$this$rpcClient75,call;return _regeneratorRuntime().wrap(function _callee198$(_context198){while(1)switch(_context198.prev=_context198.next){case 0:_context198.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"setApproval",account:this.wallet.account,args:[request.parentIpId,request.licenseTermsId,request.childIpId,request.approved]});case 2:_yield$this$rpcClient75=_context198.sent;call=_yield$this$rpcClient75.request;_context198.next=6;return this.wallet.writeContract(call);case 6:return _context198.abrupt("return",_context198.sent);case 7:case"end":return _context198.stop();}},_callee198,this);}));function setApproval(_x128){return _setApproval.apply(this,arguments);}return setApproval;}()/**
   * method setApproval for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateSetApprovalRequest
   * @return EncodedTxData
   */)},{key:"setApprovalEncode",value:function setApprovalEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"setApproval",args:[request.parentIpId,request.licenseTermsId,request.childIpId,request.approved]})};}/**
   * method setAuthority for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSetAuthorityRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAuthority",value:(function(){var _setAuthority5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee199(request){var _yield$this$rpcClient76,call;return _regeneratorRuntime().wrap(function _callee199$(_context199){while(1)switch(_context199.prev=_context199.next){case 0:_context199.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"setAuthority",account:this.wallet.account,args:[request.newAuthority]});case 2:_yield$this$rpcClient76=_context199.sent;call=_yield$this$rpcClient76.request;_context199.next=6;return this.wallet.writeContract(call);case 6:return _context199.abrupt("return",_context199.sent);case 7:case"end":return _context199.stop();}},_callee199,this);}));function setAuthority(_x129){return _setAuthority5.apply(this,arguments);}return setAuthority;}()/**
   * method setAuthority for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateSetAuthorityRequest
   * @return EncodedTxData
   */)},{key:"setAuthorityEncode",value:function setAuthorityEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"setAuthority",args:[request.newAuthority]})};}/**
   * method upgradeToAndCall for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateUpgradeToAndCallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"upgradeToAndCall",value:(function(){var _upgradeToAndCall5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee200(request){var _yield$this$rpcClient77,call;return _regeneratorRuntime().wrap(function _callee200$(_context200){while(1)switch(_context200.prev=_context200.next){case 0:_context200.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"upgradeToAndCall",account:this.wallet.account,args:[request.newImplementation,request.data]});case 2:_yield$this$rpcClient77=_context200.sent;call=_yield$this$rpcClient77.request;_context200.next=6;return this.wallet.writeContract(call);case 6:return _context200.abrupt("return",_context200.sent);case 7:case"end":return _context200.stop();}},_callee200,this);}));function upgradeToAndCall(_x130){return _upgradeToAndCall5.apply(this,arguments);}return upgradeToAndCall;}()/**
   * method upgradeToAndCall for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateUpgradeToAndCallRequest
   * @return EncodedTxData
   */)},{key:"upgradeToAndCallEncode",value:function upgradeToAndCallEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"upgradeToAndCall",args:[request.newImplementation,request.data]})};}/**
   * method verifyMintLicenseToken for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyMintLicenseToken",value:(function(){var _verifyMintLicenseToken2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee201(request){var _yield$this$rpcClient78,call;return _regeneratorRuntime().wrap(function _callee201$(_context201){while(1)switch(_context201.prev=_context201.next){case 0:_context201.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyMintLicenseToken",account:this.wallet.account,args:[request[0],request[1],request[2],request[3]]});case 2:_yield$this$rpcClient78=_context201.sent;call=_yield$this$rpcClient78.request;_context201.next=6;return this.wallet.writeContract(call);case 6:return _context201.abrupt("return",_context201.sent);case 7:case"end":return _context201.stop();}},_callee201,this);}));function verifyMintLicenseToken(_x131){return _verifyMintLicenseToken2.apply(this,arguments);}return verifyMintLicenseToken;}()/**
   * method verifyMintLicenseToken for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
   * @return EncodedTxData
   */)},{key:"verifyMintLicenseTokenEncode",value:function verifyMintLicenseTokenEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyMintLicenseToken",args:[request[0],request[1],request[2],request[3]]})};}/**
   * method verifyRegisterDerivative for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyRegisterDerivative",value:(function(){var _verifyRegisterDerivative=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee202(request){var _yield$this$rpcClient79,call;return _regeneratorRuntime().wrap(function _callee202$(_context202){while(1)switch(_context202.prev=_context202.next){case 0:_context202.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyRegisterDerivative",account:this.wallet.account,args:[request.childIpId,request.parentIpId,request.licenseTermsId,request.licensee]});case 2:_yield$this$rpcClient79=_context202.sent;call=_yield$this$rpcClient79.request;_context202.next=6;return this.wallet.writeContract(call);case 6:return _context202.abrupt("return",_context202.sent);case 7:case"end":return _context202.stop();}},_callee202,this);}));function verifyRegisterDerivative(_x132){return _verifyRegisterDerivative.apply(this,arguments);}return verifyRegisterDerivative;}()/**
   * method verifyRegisterDerivative for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
   * @return EncodedTxData
   */)},{key:"verifyRegisterDerivativeEncode",value:function verifyRegisterDerivativeEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyRegisterDerivative",args:[request.childIpId,request.parentIpId,request.licenseTermsId,request.licensee]})};}/**
   * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyRegisterDerivativeForAllParents",value:(function(){var _verifyRegisterDerivativeForAllParents=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee203(request){var _yield$this$rpcClient80,call;return _regeneratorRuntime().wrap(function _callee203$(_context203){while(1)switch(_context203.prev=_context203.next){case 0:_context203.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyRegisterDerivativeForAllParents",account:this.wallet.account,args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.caller]});case 2:_yield$this$rpcClient80=_context203.sent;call=_yield$this$rpcClient80.request;_context203.next=6;return this.wallet.writeContract(call);case 6:return _context203.abrupt("return",_context203.sent);case 7:case"end":return _context203.stop();}},_callee203,this);}));function verifyRegisterDerivativeForAllParents(_x133){return _verifyRegisterDerivativeForAllParents.apply(this,arguments);}return verifyRegisterDerivativeForAllParents;}()/**
   * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
   * @return EncodedTxData
   */)},{key:"verifyRegisterDerivativeForAllParentsEncode",value:function verifyRegisterDerivativeForAllParentsEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyRegisterDerivativeForAllParents",args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.caller]})};}}]);}(PiLicenseTemplateReadOnlyClient);// Contract RegistrationWorkflows =============================================================
/**
 * RegistrationWorkflowsCollectionCreatedEvent
 *
 * @param spgNftContract address
 */ /**
 * RegistrationWorkflowsCreateCollectionRequest
 *
 * @param spgNftInitParams tuple
 */ /**
 * RegistrationWorkflowsMintAndRegisterIpRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param allowDuplicates bool
 */ /**
 * RegistrationWorkflowsMulticallRequest
 *
 * @param data bytes[]
 */ /**
 * RegistrationWorkflowsRegisterIpRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param sigMetadata tuple
 */ /**
 * contract RegistrationWorkflows event
 */var RegistrationWorkflowsEventClient=/*#__PURE__*/function(){function RegistrationWorkflowsEventClient(rpcClient,address){var _rpcClient$chain20;_classCallCheck(this,RegistrationWorkflowsEventClient);this.address=address||getAddress(registrationWorkflowsAddress,(_rpcClient$chain20=rpcClient.chain)===null||_rpcClient$chain20===void 0?void 0:_rpcClient$chain20.id);this.rpcClient=rpcClient;}/**
   * event CollectionCreated for contract RegistrationWorkflows
   */return _createClass(RegistrationWorkflowsEventClient,[{key:"watchCollectionCreatedEvent",value:function watchCollectionCreatedEvent(_onLogs45){return this.rpcClient.watchContractEvent({abi:registrationWorkflowsAbi,address:this.address,eventName:"CollectionCreated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs45(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event CollectionCreated for contract RegistrationWorkflows
   */},{key:"parseTxCollectionCreatedEvent",value:function parseTxCollectionCreatedEvent(txReceipt){var targetLogs=[];var _iterator45=_createForOfIteratorHelper(txReceipt.logs),_step45;try{for(_iterator45.s();!(_step45=_iterator45.n()).done;){var log=_step45.value;try{var event=decodeEventLog({abi:registrationWorkflowsAbi,eventName:"CollectionCreated",data:log.data,topics:log.topics});if(event.eventName==="CollectionCreated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator45.e(err);}finally{_iterator45.f();}return targetLogs;}}]);}();/**
 * contract RegistrationWorkflows write method
 */var RegistrationWorkflowsClient=/*#__PURE__*/function(_RegistrationWorkflow){function RegistrationWorkflowsClient(rpcClient,wallet,address){var _this12;_classCallCheck(this,RegistrationWorkflowsClient);_this12=_callSuper(this,RegistrationWorkflowsClient,[rpcClient,address]);_this12.wallet=wallet;return _this12;}/**
   * method createCollection for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsCreateCollectionRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(RegistrationWorkflowsClient,_RegistrationWorkflow);return _createClass(RegistrationWorkflowsClient,[{key:"createCollection",value:(function(){var _createCollection=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee204(request){var _yield$this$rpcClient81,call;return _regeneratorRuntime().wrap(function _callee204$(_context204){while(1)switch(_context204.prev=_context204.next){case 0:_context204.next=2;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"createCollection",account:this.wallet.account,args:[request.spgNftInitParams]});case 2:_yield$this$rpcClient81=_context204.sent;call=_yield$this$rpcClient81.request;_context204.next=6;return this.wallet.writeContract(call);case 6:return _context204.abrupt("return",_context204.sent);case 7:case"end":return _context204.stop();}},_callee204,this);}));function createCollection(_x134){return _createCollection.apply(this,arguments);}return createCollection;}()/**
   * method createCollection for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsCreateCollectionRequest
   * @return EncodedTxData
   */)},{key:"createCollectionEncode",value:function createCollectionEncode(request){return {to:this.address,data:encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"createCollection",args:[request.spgNftInitParams]})};}/**
   * method mintAndRegisterIp for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsMintAndRegisterIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIp",value:(function(){var _mintAndRegisterIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee205(request){var _yield$this$rpcClient82,call;return _regeneratorRuntime().wrap(function _callee205$(_context205){while(1)switch(_context205.prev=_context205.next){case 0:_context205.next=2;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIp",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.allowDuplicates]});case 2:_yield$this$rpcClient82=_context205.sent;call=_yield$this$rpcClient82.request;_context205.next=6;return this.wallet.writeContract(call);case 6:return _context205.abrupt("return",_context205.sent);case 7:case"end":return _context205.stop();}},_callee205,this);}));function mintAndRegisterIp(_x135){return _mintAndRegisterIp.apply(this,arguments);}return mintAndRegisterIp;}()/**
   * method mintAndRegisterIp for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsMintAndRegisterIpRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpEncode",value:function mintAndRegisterIpEncode(request){return {to:this.address,data:encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"mintAndRegisterIp",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.allowDuplicates]})};}/**
   * method multicall for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee206(request){var _yield$this$rpcClient83,call;return _regeneratorRuntime().wrap(function _callee206$(_context206){while(1)switch(_context206.prev=_context206.next){case 0:_context206.next=2;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 2:_yield$this$rpcClient83=_context206.sent;call=_yield$this$rpcClient83.request;_context206.next=6;return this.wallet.writeContract(call);case 6:return _context206.abrupt("return",_context206.sent);case 7:case"end":return _context206.stop();}},_callee206,this);}));function multicall(_x136){return _multicall3.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIp for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsRegisterIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIp",value:(function(){var _registerIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee207(request){var _yield$this$rpcClient84,call;return _regeneratorRuntime().wrap(function _callee207$(_context207){while(1)switch(_context207.prev=_context207.next){case 0:_context207.next=2;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"registerIp",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.sigMetadata]});case 2:_yield$this$rpcClient84=_context207.sent;call=_yield$this$rpcClient84.request;_context207.next=6;return this.wallet.writeContract(call);case 6:return _context207.abrupt("return",_context207.sent);case 7:case"end":return _context207.stop();}},_callee207,this);}));function registerIp(_x137){return _registerIp.apply(this,arguments);}return registerIp;}()/**
   * method registerIp for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsRegisterIpRequest
   * @return EncodedTxData
   */)},{key:"registerIpEncode",value:function registerIpEncode(request){return {to:this.address,data:encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"registerIp",args:[request.nftContract,request.tokenId,request.ipMetadata,request.sigMetadata]})};}}]);}(RegistrationWorkflowsEventClient);// Contract RoyaltyModule =============================================================
/**
 * RoyaltyModuleIpRoyaltyVaultDeployedEvent
 *
 * @param ipId address
 * @param ipRoyaltyVault address
 */ /**
 * RoyaltyModuleIpRoyaltyVaultsRequest
 *
 * @param ipId address
 */ /**
 * RoyaltyModuleIsWhitelistedRoyaltyPolicyRequest
 *
 * @param royaltyPolicy address
 */ /**
 * RoyaltyModuleIsWhitelistedRoyaltyTokenRequest
 *
 * @param token address
 */ /**
 * RoyaltyModulePayRoyaltyOnBehalfRequest
 *
 * @param receiverIpId address
 * @param payerIpId address
 * @param token address
 * @param amount uint256
 */ /**
 * contract RoyaltyModule event
 */var RoyaltyModuleEventClient=/*#__PURE__*/function(){function RoyaltyModuleEventClient(rpcClient,address){var _rpcClient$chain21;_classCallCheck(this,RoyaltyModuleEventClient);this.address=address||getAddress(royaltyModuleAddress,(_rpcClient$chain21=rpcClient.chain)===null||_rpcClient$chain21===void 0?void 0:_rpcClient$chain21.id);this.rpcClient=rpcClient;}/**
   * event IpRoyaltyVaultDeployed for contract RoyaltyModule
   */return _createClass(RoyaltyModuleEventClient,[{key:"watchIpRoyaltyVaultDeployedEvent",value:function watchIpRoyaltyVaultDeployedEvent(_onLogs46){return this.rpcClient.watchContractEvent({abi:royaltyModuleAbi,address:this.address,eventName:"IpRoyaltyVaultDeployed",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs46(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IpRoyaltyVaultDeployed for contract RoyaltyModule
   */},{key:"parseTxIpRoyaltyVaultDeployedEvent",value:function parseTxIpRoyaltyVaultDeployedEvent(txReceipt){var targetLogs=[];var _iterator46=_createForOfIteratorHelper(txReceipt.logs),_step46;try{for(_iterator46.s();!(_step46=_iterator46.n()).done;){var log=_step46.value;try{var event=decodeEventLog({abi:royaltyModuleAbi,eventName:"IpRoyaltyVaultDeployed",data:log.data,topics:log.topics});if(event.eventName==="IpRoyaltyVaultDeployed"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator46.e(err);}finally{_iterator46.f();}return targetLogs;}}]);}();/**
 * contract RoyaltyModule readonly method
 */var RoyaltyModuleReadOnlyClient=/*#__PURE__*/function(_RoyaltyModuleEventCl){function RoyaltyModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,RoyaltyModuleReadOnlyClient);return _callSuper(this,RoyaltyModuleReadOnlyClient,[rpcClient,address]);}/**
   * method ipRoyaltyVaults for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIpRoyaltyVaultsRequest
   * @return Promise<RoyaltyModuleIpRoyaltyVaultsResponse>
   */_inherits(RoyaltyModuleReadOnlyClient,_RoyaltyModuleEventCl);return _createClass(RoyaltyModuleReadOnlyClient,[{key:"ipRoyaltyVaults",value:(function(){var _ipRoyaltyVaults=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee208(request){return _regeneratorRuntime().wrap(function _callee208$(_context208){while(1)switch(_context208.prev=_context208.next){case 0:_context208.next=2;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"ipRoyaltyVaults",args:[request.ipId]});case 2:return _context208.abrupt("return",_context208.sent);case 3:case"end":return _context208.stop();}},_callee208,this);}));function ipRoyaltyVaults(_x138){return _ipRoyaltyVaults.apply(this,arguments);}return ipRoyaltyVaults;}()/**
   * method isWhitelistedRoyaltyPolicy for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIsWhitelistedRoyaltyPolicyRequest
   * @return Promise<RoyaltyModuleIsWhitelistedRoyaltyPolicyResponse>
   */)},{key:"isWhitelistedRoyaltyPolicy",value:(function(){var _isWhitelistedRoyaltyPolicy=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee209(request){return _regeneratorRuntime().wrap(function _callee209$(_context209){while(1)switch(_context209.prev=_context209.next){case 0:_context209.next=2;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"isWhitelistedRoyaltyPolicy",args:[request.royaltyPolicy]});case 2:return _context209.abrupt("return",_context209.sent);case 3:case"end":return _context209.stop();}},_callee209,this);}));function isWhitelistedRoyaltyPolicy(_x139){return _isWhitelistedRoyaltyPolicy.apply(this,arguments);}return isWhitelistedRoyaltyPolicy;}()/**
   * method isWhitelistedRoyaltyToken for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIsWhitelistedRoyaltyTokenRequest
   * @return Promise<RoyaltyModuleIsWhitelistedRoyaltyTokenResponse>
   */)},{key:"isWhitelistedRoyaltyToken",value:(function(){var _isWhitelistedRoyaltyToken=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee210(request){return _regeneratorRuntime().wrap(function _callee210$(_context210){while(1)switch(_context210.prev=_context210.next){case 0:_context210.next=2;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"isWhitelistedRoyaltyToken",args:[request.token]});case 2:return _context210.abrupt("return",_context210.sent);case 3:case"end":return _context210.stop();}},_callee210,this);}));function isWhitelistedRoyaltyToken(_x140){return _isWhitelistedRoyaltyToken.apply(this,arguments);}return isWhitelistedRoyaltyToken;}())}]);}(RoyaltyModuleEventClient);/**
 * contract RoyaltyModule write method
 */var RoyaltyModuleClient=/*#__PURE__*/function(_RoyaltyModuleReadOnl){function RoyaltyModuleClient(rpcClient,wallet,address){var _this13;_classCallCheck(this,RoyaltyModuleClient);_this13=_callSuper(this,RoyaltyModuleClient,[rpcClient,address]);_this13.wallet=wallet;return _this13;}/**
   * method payRoyaltyOnBehalf for contract RoyaltyModule
   *
   * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(RoyaltyModuleClient,_RoyaltyModuleReadOnl);return _createClass(RoyaltyModuleClient,[{key:"payRoyaltyOnBehalf",value:(function(){var _payRoyaltyOnBehalf=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee211(request){var _yield$this$rpcClient85,call;return _regeneratorRuntime().wrap(function _callee211$(_context211){while(1)switch(_context211.prev=_context211.next){case 0:_context211.next=2;return this.rpcClient.simulateContract({abi:royaltyModuleAbi,address:this.address,functionName:"payRoyaltyOnBehalf",account:this.wallet.account,args:[request.receiverIpId,request.payerIpId,request.token,request.amount]});case 2:_yield$this$rpcClient85=_context211.sent;call=_yield$this$rpcClient85.request;_context211.next=6;return this.wallet.writeContract(call);case 6:return _context211.abrupt("return",_context211.sent);case 7:case"end":return _context211.stop();}},_callee211,this);}));function payRoyaltyOnBehalf(_x141){return _payRoyaltyOnBehalf.apply(this,arguments);}return payRoyaltyOnBehalf;}()/**
   * method payRoyaltyOnBehalf for contract RoyaltyModule with only encode
   *
   * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
   * @return EncodedTxData
   */)},{key:"payRoyaltyOnBehalfEncode",value:function payRoyaltyOnBehalfEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyModuleAbi,functionName:"payRoyaltyOnBehalf",args:[request.receiverIpId,request.payerIpId,request.token,request.amount]})};}}]);}(RoyaltyModuleReadOnlyClient);// Contract RoyaltyPolicyLAP =============================================================
/**
 * RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
 *
 * @param ipId address
 * @param royaltyShares tuple[]
 * @param sigApproveRoyaltyTokens tuple
 */ /**
 * RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param royaltyShares tuple[]
 * @param allowDuplicates bool
 */ /**
 * RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param derivData tuple
 * @param royaltyShares tuple[]
 * @param allowDuplicates bool
 */ /**
 * RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param sigMetadataAndAttachAndConfig tuple
 */ /**
 * RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param derivData tuple
 * @param sigMetadataAndRegister tuple
 */ /**
 * contract RoyaltyTokenDistributionWorkflows write method
 */var RoyaltyTokenDistributionWorkflowsClient=/*#__PURE__*/function(){function RoyaltyTokenDistributionWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain23;_classCallCheck(this,RoyaltyTokenDistributionWorkflowsClient);this.address=address||getAddress(royaltyTokenDistributionWorkflowsAddress,(_rpcClient$chain23=rpcClient.chain)===null||_rpcClient$chain23===void 0?void 0:_rpcClient$chain23.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method distributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(RoyaltyTokenDistributionWorkflowsClient,[{key:"distributeRoyaltyTokens",value:(function(){var _distributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee235(request){var _yield$this$rpcClient96,call;return _regeneratorRuntime().wrap(function _callee235$(_context235){while(1)switch(_context235.prev=_context235.next){case 0:_context235.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"distributeRoyaltyTokens",account:this.wallet.account,args:[request.ipId,request.royaltyShares,request.sigApproveRoyaltyTokens]});case 2:_yield$this$rpcClient96=_context235.sent;call=_yield$this$rpcClient96.request;_context235.next=6;return this.wallet.writeContract(call);case 6:return _context235.abrupt("return",_context235.sent);case 7:case"end":return _context235.stop();}},_callee235,this);}));function distributeRoyaltyTokens(_x153){return _distributeRoyaltyTokens.apply(this,arguments);}return distributeRoyaltyTokens;}()/**
   * method distributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"distributeRoyaltyTokensEncode",value:function distributeRoyaltyTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"distributeRoyaltyTokens",args:[request.ipId,request.royaltyShares,request.sigApproveRoyaltyTokens]})};}/**
   * method mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens",value:(function(){var _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee236(request){var _yield$this$rpcClient97,call;return _regeneratorRuntime().wrap(function _callee236$(_context236){while(1)switch(_context236.prev=_context236.next){case 0:_context236.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.royaltyShares,request.allowDuplicates]});case 2:_yield$this$rpcClient97=_context236.sent;call=_yield$this$rpcClient97.request;_context236.next=6;return this.wallet.writeContract(call);case 6:return _context236.abrupt("return",_context236.sent);case 7:case"end":return _context236.stop();}},_callee236,this);}));function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_x154){return _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens.apply(this,arguments);}return mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens;}()/**
   * method mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode",value:function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.royaltyShares,request.allowDuplicates]})};}/**
   * method mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",value:(function(){var _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee237(request){var _yield$this$rpcClient98,call;return _regeneratorRuntime().wrap(function _callee237$(_context237){while(1)switch(_context237.prev=_context237.next){case 0:_context237.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.derivData,request.royaltyShares,request.allowDuplicates]});case 2:_yield$this$rpcClient98=_context237.sent;call=_yield$this$rpcClient98.request;_context237.next=6;return this.wallet.writeContract(call);case 6:return _context237.abrupt("return",_context237.sent);case 7:case"end":return _context237.stop();}},_callee237,this);}));function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_x155){return _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens;}()/**
   * method mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode",value:function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.derivData,request.royaltyShares,request.allowDuplicates]})};}/**
   * method registerIpAndAttachPILTermsAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachPilTermsAndDeployRoyaltyVault",value:(function(){var _registerIpAndAttachPilTermsAndDeployRoyaltyVault=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee238(request){var _yield$this$rpcClient99,call;return _regeneratorRuntime().wrap(function _callee238$(_context238){while(1)switch(_context238.prev=_context238.next){case 0:_context238.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]});case 2:_yield$this$rpcClient99=_context238.sent;call=_yield$this$rpcClient99.request;_context238.next=6;return this.wallet.writeContract(call);case 6:return _context238.abrupt("return",_context238.sent);case 7:case"end":return _context238.stop();}},_callee238,this);}));function registerIpAndAttachPilTermsAndDeployRoyaltyVault(_x156){return _registerIpAndAttachPilTermsAndDeployRoyaltyVault.apply(this,arguments);}return registerIpAndAttachPilTermsAndDeployRoyaltyVault;}()/**
   * method registerIpAndAttachPILTermsAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachPilTermsAndDeployRoyaltyVaultEncode",value:function registerIpAndAttachPilTermsAndDeployRoyaltyVaultEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]})};}/**
   * method registerIpAndMakeDerivativeAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",value:(function(){var _registerIpAndMakeDerivativeAndDeployRoyaltyVault=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee239(request){var _yield$this$rpcClient100,call;return _regeneratorRuntime().wrap(function _callee239$(_context239){while(1)switch(_context239.prev=_context239.next){case 0:_context239.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.derivData,request.sigMetadataAndRegister]});case 2:_yield$this$rpcClient100=_context239.sent;call=_yield$this$rpcClient100.request;_context239.next=6;return this.wallet.writeContract(call);case 6:return _context239.abrupt("return",_context239.sent);case 7:case"end":return _context239.stop();}},_callee239,this);}));function registerIpAndMakeDerivativeAndDeployRoyaltyVault(_x157){return _registerIpAndMakeDerivativeAndDeployRoyaltyVault.apply(this,arguments);}return registerIpAndMakeDerivativeAndDeployRoyaltyVault;}()/**
   * method registerIpAndMakeDerivativeAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode",value:function registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",args:[request.nftContract,request.tokenId,request.ipMetadata,request.derivData,request.sigMetadataAndRegister]})};}}]);}();// Contract RoyaltyWorkflows =============================================================
/**
 * SpgnftImplApprovalEvent
 *
 * @param owner address
 * @param approved address
 * @param tokenId uint256
 */ /**
 * SpgnftImplApprovalForAllEvent
 *
 * @param owner address
 * @param operator address
 * @param approved bool
 */ /**
 * SpgnftImplBatchMetadataUpdateEvent
 *
 * @param _fromTokenId uint256
 * @param _toTokenId uint256
 */ /**
 * SpgnftImplInitializedEvent
 *
 * @param version uint64
 */ /**
 * SpgnftImplMetadataUpdateEvent
 *
 * @param _tokenId uint256
 */ /**
 * SpgnftImplRoleAdminChangedEvent
 *
 * @param role bytes32
 * @param previousAdminRole bytes32
 * @param newAdminRole bytes32
 */ /**
 * SpgnftImplRoleGrantedEvent
 *
 * @param role bytes32
 * @param account address
 * @param sender address
 */ /**
 * SpgnftImplRoleRevokedEvent
 *
 * @param role bytes32
 * @param account address
 * @param sender address
 */ /**
 * SpgnftImplTransferEvent
 *
 * @param from address
 * @param to address
 * @param tokenId uint256
 */ /**
 * SpgnftImplBalanceOfRequest
 *
 * @param owner address
 */ /**
 * SpgnftImplGetApprovedRequest
 *
 * @param tokenId uint256
 */ /**
 * SpgnftImplGetRoleAdminRequest
 *
 * @param role bytes32
 */ /**
 * SpgnftImplGetTokenIdByMetadataHashRequest
 *
 * @param nftMetadataHash bytes32
 */ /**
 * SpgnftImplHasRoleRequest
 *
 * @param role bytes32
 * @param account address
 */ /**
 * SpgnftImplIsApprovedForAllRequest
 *
 * @param owner address
 * @param operator address
 */ /**
 * SpgnftImplOwnerOfRequest
 *
 * @param tokenId uint256
 */ /**
 * SpgnftImplSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 */ /**
 * SpgnftImplTokenUriRequest
 *
 * @param tokenId uint256
 */ /**
 * SpgnftImplApproveRequest
 *
 * @param to address
 * @param tokenId uint256
 */ /**
 * SpgnftImplGrantRoleRequest
 *
 * @param role bytes32
 * @param account address
 */ /**
 * SpgnftImplInitializeRequest
 *
 * @param initParams tuple
 */ /**
 * SpgnftImplMintRequest
 *
 * @param to address
 * @param nftMetadataURI string
 * @param nftMetadataHash bytes32
 * @param allowDuplicates bool
 */ /**
 * SpgnftImplMintByPeripheryRequest
 *
 * @param to address
 * @param payer address
 * @param nftMetadataURI string
 * @param nftMetadataHash bytes32
 * @param allowDuplicates bool
 */ /**
 * SpgnftImplRenounceRoleRequest
 *
 * @param role bytes32
 * @param callerConfirmation address
 */ /**
 * SpgnftImplRevokeRoleRequest
 *
 * @param role bytes32
 * @param account address
 */ /**
 * SpgnftImplSafeTransferFromRequest
 *
 * @param from address
 * @param to address
 * @param tokenId uint256
 */ /**
 * SpgnftImplSafeTransferFrom2Request
 *
 * @param from address
 * @param to address
 * @param tokenId uint256
 * @param data bytes
 */ /**
 * SpgnftImplSetApprovalForAllRequest
 *
 * @param operator address
 * @param approved bool
 */ /**
 * SpgnftImplSetBaseUriRequest
 *
 * @param baseURI string
 */ /**
 * SpgnftImplSetContractUriRequest
 *
 * @param contractURI string
 */ /**
 * SpgnftImplSetMintFeeRequest
 *
 * @param fee uint256
 */ /**
 * SpgnftImplSetMintFeeRecipientRequest
 *
 * @param newFeeRecipient address
 */ /**
 * SpgnftImplSetMintFeeTokenRequest
 *
 * @param token address
 */ /**
 * SpgnftImplSetMintOpenRequest
 *
 * @param mintOpen bool
 */ /**
 * SpgnftImplSetPublicMintingRequest
 *
 * @param isPublicMinting bool
 */ /**
 * SpgnftImplTransferFromRequest
 *
 * @param from address
 * @param to address
 * @param tokenId uint256
 */ /**
 * SpgnftImplWithdrawTokenRequest
 *
 * @param token address
 */ /**
 * contract SPGNFTImpl event
 */var SpgnftImplEventClient=/*#__PURE__*/function(){function SpgnftImplEventClient(rpcClient,address){var _rpcClient$chain26;_classCallCheck(this,SpgnftImplEventClient);this.address=address||getAddress(spgnftImplAddress,(_rpcClient$chain26=rpcClient.chain)===null||_rpcClient$chain26===void 0?void 0:_rpcClient$chain26.id);this.rpcClient=rpcClient;}/**
   * event Approval for contract SPGNFTImpl
   */return _createClass(SpgnftImplEventClient,[{key:"watchApprovalEvent",value:function watchApprovalEvent(_onLogs55){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"Approval",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs55(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Approval for contract SPGNFTImpl
   */},{key:"parseTxApprovalEvent",value:function parseTxApprovalEvent(txReceipt){var targetLogs=[];var _iterator55=_createForOfIteratorHelper(txReceipt.logs),_step55;try{for(_iterator55.s();!(_step55=_iterator55.n()).done;){var log=_step55.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"Approval",data:log.data,topics:log.topics});if(event.eventName==="Approval"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator55.e(err);}finally{_iterator55.f();}return targetLogs;}/**
   * event ApprovalForAll for contract SPGNFTImpl
   */},{key:"watchApprovalForAllEvent",value:function watchApprovalForAllEvent(_onLogs56){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"ApprovalForAll",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs56(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event ApprovalForAll for contract SPGNFTImpl
   */},{key:"parseTxApprovalForAllEvent",value:function parseTxApprovalForAllEvent(txReceipt){var targetLogs=[];var _iterator56=_createForOfIteratorHelper(txReceipt.logs),_step56;try{for(_iterator56.s();!(_step56=_iterator56.n()).done;){var log=_step56.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"ApprovalForAll",data:log.data,topics:log.topics});if(event.eventName==="ApprovalForAll"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator56.e(err);}finally{_iterator56.f();}return targetLogs;}/**
   * event BatchMetadataUpdate for contract SPGNFTImpl
   */},{key:"watchBatchMetadataUpdateEvent",value:function watchBatchMetadataUpdateEvent(_onLogs57){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"BatchMetadataUpdate",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs57(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event BatchMetadataUpdate for contract SPGNFTImpl
   */},{key:"parseTxBatchMetadataUpdateEvent",value:function parseTxBatchMetadataUpdateEvent(txReceipt){var targetLogs=[];var _iterator57=_createForOfIteratorHelper(txReceipt.logs),_step57;try{for(_iterator57.s();!(_step57=_iterator57.n()).done;){var log=_step57.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"BatchMetadataUpdate",data:log.data,topics:log.topics});if(event.eventName==="BatchMetadataUpdate"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator57.e(err);}finally{_iterator57.f();}return targetLogs;}/**
   * event Initialized for contract SPGNFTImpl
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs58){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs58(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract SPGNFTImpl
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator58=_createForOfIteratorHelper(txReceipt.logs),_step58;try{for(_iterator58.s();!(_step58=_iterator58.n()).done;){var log=_step58.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator58.e(err);}finally{_iterator58.f();}return targetLogs;}/**
   * event MetadataUpdate for contract SPGNFTImpl
   */},{key:"watchMetadataUpdateEvent",value:function watchMetadataUpdateEvent(_onLogs59){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"MetadataUpdate",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs59(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event MetadataUpdate for contract SPGNFTImpl
   */},{key:"parseTxMetadataUpdateEvent",value:function parseTxMetadataUpdateEvent(txReceipt){var targetLogs=[];var _iterator59=_createForOfIteratorHelper(txReceipt.logs),_step59;try{for(_iterator59.s();!(_step59=_iterator59.n()).done;){var log=_step59.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"MetadataUpdate",data:log.data,topics:log.topics});if(event.eventName==="MetadataUpdate"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator59.e(err);}finally{_iterator59.f();}return targetLogs;}/**
   * event RoleAdminChanged for contract SPGNFTImpl
   */},{key:"watchRoleAdminChangedEvent",value:function watchRoleAdminChangedEvent(_onLogs60){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"RoleAdminChanged",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs60(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RoleAdminChanged for contract SPGNFTImpl
   */},{key:"parseTxRoleAdminChangedEvent",value:function parseTxRoleAdminChangedEvent(txReceipt){var targetLogs=[];var _iterator60=_createForOfIteratorHelper(txReceipt.logs),_step60;try{for(_iterator60.s();!(_step60=_iterator60.n()).done;){var log=_step60.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"RoleAdminChanged",data:log.data,topics:log.topics});if(event.eventName==="RoleAdminChanged"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator60.e(err);}finally{_iterator60.f();}return targetLogs;}/**
   * event RoleGranted for contract SPGNFTImpl
   */},{key:"watchRoleGrantedEvent",value:function watchRoleGrantedEvent(_onLogs61){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"RoleGranted",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs61(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RoleGranted for contract SPGNFTImpl
   */},{key:"parseTxRoleGrantedEvent",value:function parseTxRoleGrantedEvent(txReceipt){var targetLogs=[];var _iterator61=_createForOfIteratorHelper(txReceipt.logs),_step61;try{for(_iterator61.s();!(_step61=_iterator61.n()).done;){var log=_step61.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"RoleGranted",data:log.data,topics:log.topics});if(event.eventName==="RoleGranted"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator61.e(err);}finally{_iterator61.f();}return targetLogs;}/**
   * event RoleRevoked for contract SPGNFTImpl
   */},{key:"watchRoleRevokedEvent",value:function watchRoleRevokedEvent(_onLogs62){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"RoleRevoked",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs62(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RoleRevoked for contract SPGNFTImpl
   */},{key:"parseTxRoleRevokedEvent",value:function parseTxRoleRevokedEvent(txReceipt){var targetLogs=[];var _iterator62=_createForOfIteratorHelper(txReceipt.logs),_step62;try{for(_iterator62.s();!(_step62=_iterator62.n()).done;){var log=_step62.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"RoleRevoked",data:log.data,topics:log.topics});if(event.eventName==="RoleRevoked"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator62.e(err);}finally{_iterator62.f();}return targetLogs;}/**
   * event Transfer for contract SPGNFTImpl
   */},{key:"watchTransferEvent",value:function watchTransferEvent(_onLogs63){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"Transfer",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs63(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Transfer for contract SPGNFTImpl
   */},{key:"parseTxTransferEvent",value:function parseTxTransferEvent(txReceipt){var targetLogs=[];var _iterator63=_createForOfIteratorHelper(txReceipt.logs),_step63;try{for(_iterator63.s();!(_step63=_iterator63.n()).done;){var log=_step63.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"Transfer",data:log.data,topics:log.topics});if(event.eventName==="Transfer"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator63.e(err);}finally{_iterator63.f();}return targetLogs;}}]);}();/**
 * contract SPGNFTImpl readonly method
 */var SpgnftImplReadOnlyClient=/*#__PURE__*/function(_SpgnftImplEventClien){function SpgnftImplReadOnlyClient(rpcClient,address){_classCallCheck(this,SpgnftImplReadOnlyClient);return _callSuper(this,SpgnftImplReadOnlyClient,[rpcClient,address]);}/**
   * method DEFAULT_ADMIN_ROLE for contract SPGNFTImpl
   *
   * @param request SpgnftImplDefaultAdminRoleRequest
   * @return Promise<SpgnftImplDefaultAdminRoleResponse>
   */_inherits(SpgnftImplReadOnlyClient,_SpgnftImplEventClien);return _createClass(SpgnftImplReadOnlyClient,[{key:"defaultAdminRole",value:(function(){var _defaultAdminRole=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee246(){return _regeneratorRuntime().wrap(function _callee246$(_context246){while(1)switch(_context246.prev=_context246.next){case 0:_context246.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"DEFAULT_ADMIN_ROLE"});case 2:return _context246.abrupt("return",_context246.sent);case 3:case"end":return _context246.stop();}},_callee246,this);}));function defaultAdminRole(){return _defaultAdminRole.apply(this,arguments);}return defaultAdminRole;}()/**
   * method DERIVATIVE_WORKFLOWS_ADDRESS for contract SPGNFTImpl
   *
   * @param request SpgnftImplDerivativeWorkflowsAddressRequest
   * @return Promise<SpgnftImplDerivativeWorkflowsAddressResponse>
   */)},{key:"derivativeWorkflowsAddress",value:(function(){var _derivativeWorkflowsAddress=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee247(){return _regeneratorRuntime().wrap(function _callee247$(_context247){while(1)switch(_context247.prev=_context247.next){case 0:_context247.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"DERIVATIVE_WORKFLOWS_ADDRESS"});case 2:return _context247.abrupt("return",_context247.sent);case 3:case"end":return _context247.stop();}},_callee247,this);}));function derivativeWorkflowsAddress(){return _derivativeWorkflowsAddress.apply(this,arguments);}return derivativeWorkflowsAddress;}()/**
   * method GROUPING_WORKFLOWS_ADDRESS for contract SPGNFTImpl
   *
   * @param request SpgnftImplGroupingWorkflowsAddressRequest
   * @return Promise<SpgnftImplGroupingWorkflowsAddressResponse>
   */)},{key:"groupingWorkflowsAddress",value:(function(){var _groupingWorkflowsAddress=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee248(){return _regeneratorRuntime().wrap(function _callee248$(_context248){while(1)switch(_context248.prev=_context248.next){case 0:_context248.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"GROUPING_WORKFLOWS_ADDRESS"});case 2:return _context248.abrupt("return",_context248.sent);case 3:case"end":return _context248.stop();}},_callee248,this);}));function groupingWorkflowsAddress(){return _groupingWorkflowsAddress.apply(this,arguments);}return groupingWorkflowsAddress;}()/**
   * method LICENSE_ATTACHMENT_WORKFLOWS_ADDRESS for contract SPGNFTImpl
   *
   * @param request SpgnftImplLicenseAttachmentWorkflowsAddressRequest
   * @return Promise<SpgnftImplLicenseAttachmentWorkflowsAddressResponse>
   */)},{key:"licenseAttachmentWorkflowsAddress",value:(function(){var _licenseAttachmentWorkflowsAddress=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee249(){return _regeneratorRuntime().wrap(function _callee249$(_context249){while(1)switch(_context249.prev=_context249.next){case 0:_context249.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"LICENSE_ATTACHMENT_WORKFLOWS_ADDRESS"});case 2:return _context249.abrupt("return",_context249.sent);case 3:case"end":return _context249.stop();}},_callee249,this);}));function licenseAttachmentWorkflowsAddress(){return _licenseAttachmentWorkflowsAddress.apply(this,arguments);}return licenseAttachmentWorkflowsAddress;}()/**
   * method REGISTRATION_WORKFLOWS_ADDRESS for contract SPGNFTImpl
   *
   * @param request SpgnftImplRegistrationWorkflowsAddressRequest
   * @return Promise<SpgnftImplRegistrationWorkflowsAddressResponse>
   */)},{key:"registrationWorkflowsAddress",value:(function(){var _registrationWorkflowsAddress=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee250(){return _regeneratorRuntime().wrap(function _callee250$(_context250){while(1)switch(_context250.prev=_context250.next){case 0:_context250.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"REGISTRATION_WORKFLOWS_ADDRESS"});case 2:return _context250.abrupt("return",_context250.sent);case 3:case"end":return _context250.stop();}},_callee250,this);}));function registrationWorkflowsAddress(){return _registrationWorkflowsAddress.apply(this,arguments);}return registrationWorkflowsAddress;}()/**
   * method ROYALTY_TOKEN_DISTRIBUTION_WORKFLOWS_ADDRESS for contract SPGNFTImpl
   *
   * @param request SpgnftImplRoyaltyTokenDistributionWorkflowsAddressRequest
   * @return Promise<SpgnftImplRoyaltyTokenDistributionWorkflowsAddressResponse>
   */)},{key:"royaltyTokenDistributionWorkflowsAddress",value:(function(){var _royaltyTokenDistributionWorkflowsAddress=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee251(){return _regeneratorRuntime().wrap(function _callee251$(_context251){while(1)switch(_context251.prev=_context251.next){case 0:_context251.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"ROYALTY_TOKEN_DISTRIBUTION_WORKFLOWS_ADDRESS"});case 2:return _context251.abrupt("return",_context251.sent);case 3:case"end":return _context251.stop();}},_callee251,this);}));function royaltyTokenDistributionWorkflowsAddress(){return _royaltyTokenDistributionWorkflowsAddress.apply(this,arguments);}return royaltyTokenDistributionWorkflowsAddress;}()/**
   * method balanceOf for contract SPGNFTImpl
   *
   * @param request SpgnftImplBalanceOfRequest
   * @return Promise<SpgnftImplBalanceOfResponse>
   */)},{key:"balanceOf",value:(function(){var _balanceOf3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee252(request){return _regeneratorRuntime().wrap(function _callee252$(_context252){while(1)switch(_context252.prev=_context252.next){case 0:_context252.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"balanceOf",args:[request.owner]});case 2:return _context252.abrupt("return",_context252.sent);case 3:case"end":return _context252.stop();}},_callee252,this);}));function balanceOf(_x161){return _balanceOf3.apply(this,arguments);}return balanceOf;}()/**
   * method baseURI for contract SPGNFTImpl
   *
   * @param request SpgnftImplBaseUriRequest
   * @return Promise<SpgnftImplBaseUriResponse>
   */)},{key:"baseUri",value:(function(){var _baseUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee253(){return _regeneratorRuntime().wrap(function _callee253$(_context253){while(1)switch(_context253.prev=_context253.next){case 0:_context253.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"baseURI"});case 2:return _context253.abrupt("return",_context253.sent);case 3:case"end":return _context253.stop();}},_callee253,this);}));function baseUri(){return _baseUri.apply(this,arguments);}return baseUri;}()/**
   * method contractURI for contract SPGNFTImpl
   *
   * @param request SpgnftImplContractUriRequest
   * @return Promise<SpgnftImplContractUriResponse>
   */)},{key:"contractUri",value:(function(){var _contractUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee254(){return _regeneratorRuntime().wrap(function _callee254$(_context254){while(1)switch(_context254.prev=_context254.next){case 0:_context254.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"contractURI"});case 2:return _context254.abrupt("return",_context254.sent);case 3:case"end":return _context254.stop();}},_callee254,this);}));function contractUri(){return _contractUri.apply(this,arguments);}return contractUri;}()/**
   * method getApproved for contract SPGNFTImpl
   *
   * @param request SpgnftImplGetApprovedRequest
   * @return Promise<SpgnftImplGetApprovedResponse>
   */)},{key:"getApproved",value:(function(){var _getApproved=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee255(request){return _regeneratorRuntime().wrap(function _callee255$(_context255){while(1)switch(_context255.prev=_context255.next){case 0:_context255.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"getApproved",args:[request.tokenId]});case 2:return _context255.abrupt("return",_context255.sent);case 3:case"end":return _context255.stop();}},_callee255,this);}));function getApproved(_x162){return _getApproved.apply(this,arguments);}return getApproved;}()/**
   * method getRoleAdmin for contract SPGNFTImpl
   *
   * @param request SpgnftImplGetRoleAdminRequest
   * @return Promise<SpgnftImplGetRoleAdminResponse>
   */)},{key:"getRoleAdmin",value:(function(){var _getRoleAdmin=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee256(request){return _regeneratorRuntime().wrap(function _callee256$(_context256){while(1)switch(_context256.prev=_context256.next){case 0:_context256.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"getRoleAdmin",args:[request.role]});case 2:return _context256.abrupt("return",_context256.sent);case 3:case"end":return _context256.stop();}},_callee256,this);}));function getRoleAdmin(_x163){return _getRoleAdmin.apply(this,arguments);}return getRoleAdmin;}()/**
   * method getTokenIdByMetadataHash for contract SPGNFTImpl
   *
   * @param request SpgnftImplGetTokenIdByMetadataHashRequest
   * @return Promise<SpgnftImplGetTokenIdByMetadataHashResponse>
   */)},{key:"getTokenIdByMetadataHash",value:(function(){var _getTokenIdByMetadataHash=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee257(request){return _regeneratorRuntime().wrap(function _callee257$(_context257){while(1)switch(_context257.prev=_context257.next){case 0:_context257.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"getTokenIdByMetadataHash",args:[request.nftMetadataHash]});case 2:return _context257.abrupt("return",_context257.sent);case 3:case"end":return _context257.stop();}},_callee257,this);}));function getTokenIdByMetadataHash(_x164){return _getTokenIdByMetadataHash.apply(this,arguments);}return getTokenIdByMetadataHash;}()/**
   * method hasRole for contract SPGNFTImpl
   *
   * @param request SpgnftImplHasRoleRequest
   * @return Promise<SpgnftImplHasRoleResponse>
   */)},{key:"hasRole",value:(function(){var _hasRole=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee258(request){return _regeneratorRuntime().wrap(function _callee258$(_context258){while(1)switch(_context258.prev=_context258.next){case 0:_context258.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"hasRole",args:[request.role,request.account]});case 2:return _context258.abrupt("return",_context258.sent);case 3:case"end":return _context258.stop();}},_callee258,this);}));function hasRole(_x165){return _hasRole.apply(this,arguments);}return hasRole;}()/**
   * method isApprovedForAll for contract SPGNFTImpl
   *
   * @param request SpgnftImplIsApprovedForAllRequest
   * @return Promise<SpgnftImplIsApprovedForAllResponse>
   */)},{key:"isApprovedForAll",value:(function(){var _isApprovedForAll=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee259(request){return _regeneratorRuntime().wrap(function _callee259$(_context259){while(1)switch(_context259.prev=_context259.next){case 0:_context259.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"isApprovedForAll",args:[request.owner,request.operator]});case 2:return _context259.abrupt("return",_context259.sent);case 3:case"end":return _context259.stop();}},_callee259,this);}));function isApprovedForAll(_x166){return _isApprovedForAll.apply(this,arguments);}return isApprovedForAll;}()/**
   * method mintFee for contract SPGNFTImpl
   *
   * @param request SpgnftImplMintFeeRequest
   * @return Promise<SpgnftImplMintFeeResponse>
   */)},{key:"mintFee",value:(function(){var _mintFee=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee260(){return _regeneratorRuntime().wrap(function _callee260$(_context260){while(1)switch(_context260.prev=_context260.next){case 0:_context260.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"mintFee"});case 2:return _context260.abrupt("return",_context260.sent);case 3:case"end":return _context260.stop();}},_callee260,this);}));function mintFee(){return _mintFee.apply(this,arguments);}return mintFee;}()/**
   * method mintFeeRecipient for contract SPGNFTImpl
   *
   * @param request SpgnftImplMintFeeRecipientRequest
   * @return Promise<SpgnftImplMintFeeRecipientResponse>
   */)},{key:"mintFeeRecipient",value:(function(){var _mintFeeRecipient=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee261(){return _regeneratorRuntime().wrap(function _callee261$(_context261){while(1)switch(_context261.prev=_context261.next){case 0:_context261.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"mintFeeRecipient"});case 2:return _context261.abrupt("return",_context261.sent);case 3:case"end":return _context261.stop();}},_callee261,this);}));function mintFeeRecipient(){return _mintFeeRecipient.apply(this,arguments);}return mintFeeRecipient;}()/**
   * method mintFeeToken for contract SPGNFTImpl
   *
   * @param request SpgnftImplMintFeeTokenRequest
   * @return Promise<SpgnftImplMintFeeTokenResponse>
   */)},{key:"mintFeeToken",value:(function(){var _mintFeeToken=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee262(){return _regeneratorRuntime().wrap(function _callee262$(_context262){while(1)switch(_context262.prev=_context262.next){case 0:_context262.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"mintFeeToken"});case 2:return _context262.abrupt("return",_context262.sent);case 3:case"end":return _context262.stop();}},_callee262,this);}));function mintFeeToken(){return _mintFeeToken.apply(this,arguments);}return mintFeeToken;}()/**
   * method mintOpen for contract SPGNFTImpl
   *
   * @param request SpgnftImplMintOpenRequest
   * @return Promise<SpgnftImplMintOpenResponse>
   */)},{key:"mintOpen",value:(function(){var _mintOpen=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee263(){return _regeneratorRuntime().wrap(function _callee263$(_context263){while(1)switch(_context263.prev=_context263.next){case 0:_context263.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"mintOpen"});case 2:return _context263.abrupt("return",_context263.sent);case 3:case"end":return _context263.stop();}},_callee263,this);}));function mintOpen(){return _mintOpen.apply(this,arguments);}return mintOpen;}()/**
   * method name for contract SPGNFTImpl
   *
   * @param request SpgnftImplNameRequest
   * @return Promise<SpgnftImplNameResponse>
   */)},{key:"name",value:(function(){var _name5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee264(){return _regeneratorRuntime().wrap(function _callee264$(_context264){while(1)switch(_context264.prev=_context264.next){case 0:_context264.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"name"});case 2:return _context264.abrupt("return",_context264.sent);case 3:case"end":return _context264.stop();}},_callee264,this);}));function name(){return _name5.apply(this,arguments);}return name;}()/**
   * method ownerOf for contract SPGNFTImpl
   *
   * @param request SpgnftImplOwnerOfRequest
   * @return Promise<SpgnftImplOwnerOfResponse>
   */)},{key:"ownerOf",value:(function(){var _ownerOf2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee265(request){return _regeneratorRuntime().wrap(function _callee265$(_context265){while(1)switch(_context265.prev=_context265.next){case 0:_context265.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"ownerOf",args:[request.tokenId]});case 2:return _context265.abrupt("return",_context265.sent);case 3:case"end":return _context265.stop();}},_callee265,this);}));function ownerOf(_x167){return _ownerOf2.apply(this,arguments);}return ownerOf;}()/**
   * method publicMinting for contract SPGNFTImpl
   *
   * @param request SpgnftImplPublicMintingRequest
   * @return Promise<SpgnftImplPublicMintingResponse>
   */)},{key:"publicMinting",value:(function(){var _publicMinting=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee266(){return _regeneratorRuntime().wrap(function _callee266$(_context266){while(1)switch(_context266.prev=_context266.next){case 0:_context266.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"publicMinting"});case 2:return _context266.abrupt("return",_context266.sent);case 3:case"end":return _context266.stop();}},_callee266,this);}));function publicMinting(){return _publicMinting.apply(this,arguments);}return publicMinting;}()/**
   * method supportsInterface for contract SPGNFTImpl
   *
   * @param request SpgnftImplSupportsInterfaceRequest
   * @return Promise<SpgnftImplSupportsInterfaceResponse>
   */)},{key:"supportsInterface",value:(function(){var _supportsInterface4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee267(request){return _regeneratorRuntime().wrap(function _callee267$(_context267){while(1)switch(_context267.prev=_context267.next){case 0:_context267.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"supportsInterface",args:[request.interfaceId]});case 2:return _context267.abrupt("return",_context267.sent);case 3:case"end":return _context267.stop();}},_callee267,this);}));function supportsInterface(_x168){return _supportsInterface4.apply(this,arguments);}return supportsInterface;}()/**
   * method symbol for contract SPGNFTImpl
   *
   * @param request SpgnftImplSymbolRequest
   * @return Promise<SpgnftImplSymbolResponse>
   */)},{key:"symbol",value:(function(){var _symbol2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee268(){return _regeneratorRuntime().wrap(function _callee268$(_context268){while(1)switch(_context268.prev=_context268.next){case 0:_context268.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"symbol"});case 2:return _context268.abrupt("return",_context268.sent);case 3:case"end":return _context268.stop();}},_callee268,this);}));function symbol(){return _symbol2.apply(this,arguments);}return symbol;}()/**
   * method tokenURI for contract SPGNFTImpl
   *
   * @param request SpgnftImplTokenUriRequest
   * @return Promise<SpgnftImplTokenUriResponse>
   */)},{key:"tokenUri",value:(function(){var _tokenUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee269(request){return _regeneratorRuntime().wrap(function _callee269$(_context269){while(1)switch(_context269.prev=_context269.next){case 0:_context269.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"tokenURI",args:[request.tokenId]});case 2:return _context269.abrupt("return",_context269.sent);case 3:case"end":return _context269.stop();}},_callee269,this);}));function tokenUri(_x169){return _tokenUri.apply(this,arguments);}return tokenUri;}()/**
   * method totalSupply for contract SPGNFTImpl
   *
   * @param request SpgnftImplTotalSupplyRequest
   * @return Promise<SpgnftImplTotalSupplyResponse>
   */)},{key:"totalSupply",value:(function(){var _totalSupply2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee270(){return _regeneratorRuntime().wrap(function _callee270$(_context270){while(1)switch(_context270.prev=_context270.next){case 0:_context270.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"totalSupply"});case 2:return _context270.abrupt("return",_context270.sent);case 3:case"end":return _context270.stop();}},_callee270,this);}));function totalSupply(){return _totalSupply2.apply(this,arguments);}return totalSupply;}())}]);}(SpgnftImplEventClient);/**
 * WrappedIpApprovalEvent
 *
 * @param owner address
 * @param spender address
 * @param amount uint256
 */ /**
 * WrappedIpDepositEvent
 *
 * @param from address
 * @param amount uint256
 */ /**
 * WrappedIpTransferEvent
 *
 * @param from address
 * @param to address
 * @param amount uint256
 */ /**
 * WrappedIpWithdrawalEvent
 *
 * @param to address
 * @param amount uint256
 */ /**
 * WrappedIpDomainSeparatorResponse
 *
 * @param result bytes32
 */ /**
 * WrappedIpAllowanceRequest
 *
 * @param owner address
 * @param spender address
 */ /**
 * WrappedIpAllowanceResponse
 *
 * @param result uint256
 */ /**
 * WrappedIpBalanceOfRequest
 *
 * @param owner address
 */ /**
 * WrappedIpBalanceOfResponse
 *
 * @param result uint256
 */ /**
 * WrappedIpNoncesRequest
 *
 * @param owner address
 */ /**
 * WrappedIpNoncesResponse
 *
 * @param result uint256
 */ /**
 * WrappedIpTotalSupplyResponse
 *
 * @param result uint256
 */ /**
 * WrappedIpApproveRequest
 *
 * @param spender address
 * @param amount uint256
 */ /**
 * WrappedIpPermitRequest
 *
 * @param owner address
 * @param spender address
 * @param value uint256
 * @param deadline uint256
 * @param v uint8
 * @param r bytes32
 * @param s bytes32
 */ /**
 * WrappedIpTransferRequest
 *
 * @param to address
 * @param amount uint256
 */ /**
 * WrappedIpTransferFromRequest
 *
 * @param from address
 * @param to address
 * @param amount uint256
 */ /**
 * WrappedIpWithdrawRequest
 *
 * @param value uint256
 */ /**
 * contract WrappedIP event
 */var WrappedIpEventClient=/*#__PURE__*/function(){function WrappedIpEventClient(rpcClient,address){var _rpcClient$chain27;_classCallCheck(this,WrappedIpEventClient);this.address=address||getAddress(wrappedIpAddress,(_rpcClient$chain27=rpcClient.chain)===null||_rpcClient$chain27===void 0?void 0:_rpcClient$chain27.id);this.rpcClient=rpcClient;}/**
   * event Approval for contract WrappedIP
   */return _createClass(WrappedIpEventClient,[{key:"watchApprovalEvent",value:function watchApprovalEvent(_onLogs64){return this.rpcClient.watchContractEvent({abi:wrappedIpAbi,address:this.address,eventName:"Approval",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs64(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Approval for contract WrappedIP
   */},{key:"parseTxApprovalEvent",value:function parseTxApprovalEvent(txReceipt){var targetLogs=[];var _iterator64=_createForOfIteratorHelper(txReceipt.logs),_step64;try{for(_iterator64.s();!(_step64=_iterator64.n()).done;){var log=_step64.value;try{var event=decodeEventLog({abi:wrappedIpAbi,eventName:"Approval",data:log.data,topics:log.topics});if(event.eventName==="Approval"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator64.e(err);}finally{_iterator64.f();}return targetLogs;}/**
   * event Deposit for contract WrappedIP
   */},{key:"watchDepositEvent",value:function watchDepositEvent(_onLogs65){return this.rpcClient.watchContractEvent({abi:wrappedIpAbi,address:this.address,eventName:"Deposit",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs65(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Deposit for contract WrappedIP
   */},{key:"parseTxDepositEvent",value:function parseTxDepositEvent(txReceipt){var targetLogs=[];var _iterator65=_createForOfIteratorHelper(txReceipt.logs),_step65;try{for(_iterator65.s();!(_step65=_iterator65.n()).done;){var log=_step65.value;try{var event=decodeEventLog({abi:wrappedIpAbi,eventName:"Deposit",data:log.data,topics:log.topics});if(event.eventName==="Deposit"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator65.e(err);}finally{_iterator65.f();}return targetLogs;}/**
   * event Transfer for contract WrappedIP
   */},{key:"watchTransferEvent",value:function watchTransferEvent(_onLogs66){return this.rpcClient.watchContractEvent({abi:wrappedIpAbi,address:this.address,eventName:"Transfer",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs66(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Transfer for contract WrappedIP
   */},{key:"parseTxTransferEvent",value:function parseTxTransferEvent(txReceipt){var targetLogs=[];var _iterator66=_createForOfIteratorHelper(txReceipt.logs),_step66;try{for(_iterator66.s();!(_step66=_iterator66.n()).done;){var log=_step66.value;try{var event=decodeEventLog({abi:wrappedIpAbi,eventName:"Transfer",data:log.data,topics:log.topics});if(event.eventName==="Transfer"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator66.e(err);}finally{_iterator66.f();}return targetLogs;}/**
   * event Withdrawal for contract WrappedIP
   */},{key:"watchWithdrawalEvent",value:function watchWithdrawalEvent(_onLogs67){return this.rpcClient.watchContractEvent({abi:wrappedIpAbi,address:this.address,eventName:"Withdrawal",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs67(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Withdrawal for contract WrappedIP
   */},{key:"parseTxWithdrawalEvent",value:function parseTxWithdrawalEvent(txReceipt){var targetLogs=[];var _iterator67=_createForOfIteratorHelper(txReceipt.logs),_step67;try{for(_iterator67.s();!(_step67=_iterator67.n()).done;){var log=_step67.value;try{var event=decodeEventLog({abi:wrappedIpAbi,eventName:"Withdrawal",data:log.data,topics:log.topics});if(event.eventName==="Withdrawal"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator67.e(err);}finally{_iterator67.f();}return targetLogs;}}]);}();/**
 * contract WrappedIP readonly method
 */var WrappedIpReadOnlyClient=/*#__PURE__*/function(_WrappedIpEventClient){function WrappedIpReadOnlyClient(rpcClient,address){_classCallCheck(this,WrappedIpReadOnlyClient);return _callSuper(this,WrappedIpReadOnlyClient,[rpcClient,address]);}/**
   * method DOMAIN_SEPARATOR for contract WrappedIP
   *
   * @param request WrappedIpDomainSeparatorRequest
   * @return Promise<WrappedIpDomainSeparatorResponse>
   */_inherits(WrappedIpReadOnlyClient,_WrappedIpEventClient);return _createClass(WrappedIpReadOnlyClient,[{key:"domainSeparator",value:(function(){var _domainSeparator=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee290(){var result;return _regeneratorRuntime().wrap(function _callee290$(_context290){while(1)switch(_context290.prev=_context290.next){case 0:_context290.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"DOMAIN_SEPARATOR"});case 2:result=_context290.sent;return _context290.abrupt("return",{result:result});case 4:case"end":return _context290.stop();}},_callee290,this);}));function domainSeparator(){return _domainSeparator.apply(this,arguments);}return domainSeparator;}()/**
   * method allowance for contract WrappedIP
   *
   * @param request WrappedIpAllowanceRequest
   * @return Promise<WrappedIpAllowanceResponse>
   */)},{key:"allowance",value:(function(){var _allowance2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee291(request){var result;return _regeneratorRuntime().wrap(function _callee291$(_context291){while(1)switch(_context291.prev=_context291.next){case 0:_context291.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"allowance",args:[request.owner,request.spender]});case 2:result=_context291.sent;return _context291.abrupt("return",{result:result});case 4:case"end":return _context291.stop();}},_callee291,this);}));function allowance(_x189){return _allowance2.apply(this,arguments);}return allowance;}()/**
   * method balanceOf for contract WrappedIP
   *
   * @param request WrappedIpBalanceOfRequest
   * @return Promise<WrappedIpBalanceOfResponse>
   */)},{key:"balanceOf",value:(function(){var _balanceOf4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee292(request){var result;return _regeneratorRuntime().wrap(function _callee292$(_context292){while(1)switch(_context292.prev=_context292.next){case 0:_context292.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"balanceOf",args:[request.owner]});case 2:result=_context292.sent;return _context292.abrupt("return",{result:result});case 4:case"end":return _context292.stop();}},_callee292,this);}));function balanceOf(_x190){return _balanceOf4.apply(this,arguments);}return balanceOf;}()/**
   * method decimals for contract WrappedIP
   *
   * @param request WrappedIpDecimalsRequest
   * @return Promise<WrappedIpDecimalsResponse>
   */)},{key:"decimals",value:(function(){var _decimals2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee293(){return _regeneratorRuntime().wrap(function _callee293$(_context293){while(1)switch(_context293.prev=_context293.next){case 0:_context293.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"decimals"});case 2:return _context293.abrupt("return",_context293.sent);case 3:case"end":return _context293.stop();}},_callee293,this);}));function decimals(){return _decimals2.apply(this,arguments);}return decimals;}()/**
   * method name for contract WrappedIP
   *
   * @param request WrappedIpNameRequest
   * @return Promise<WrappedIpNameResponse>
   */)},{key:"name",value:(function(){var _name6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee294(){return _regeneratorRuntime().wrap(function _callee294$(_context294){while(1)switch(_context294.prev=_context294.next){case 0:_context294.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"name"});case 2:return _context294.abrupt("return",_context294.sent);case 3:case"end":return _context294.stop();}},_callee294,this);}));function name(){return _name6.apply(this,arguments);}return name;}()/**
   * method nonces for contract WrappedIP
   *
   * @param request WrappedIpNoncesRequest
   * @return Promise<WrappedIpNoncesResponse>
   */)},{key:"nonces",value:(function(){var _nonces=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee295(request){var result;return _regeneratorRuntime().wrap(function _callee295$(_context295){while(1)switch(_context295.prev=_context295.next){case 0:_context295.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"nonces",args:[request.owner]});case 2:result=_context295.sent;return _context295.abrupt("return",{result:result});case 4:case"end":return _context295.stop();}},_callee295,this);}));function nonces(_x191){return _nonces.apply(this,arguments);}return nonces;}()/**
   * method symbol for contract WrappedIP
   *
   * @param request WrappedIpSymbolRequest
   * @return Promise<WrappedIpSymbolResponse>
   */)},{key:"symbol",value:(function(){var _symbol3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee296(){return _regeneratorRuntime().wrap(function _callee296$(_context296){while(1)switch(_context296.prev=_context296.next){case 0:_context296.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"symbol"});case 2:return _context296.abrupt("return",_context296.sent);case 3:case"end":return _context296.stop();}},_callee296,this);}));function symbol(){return _symbol3.apply(this,arguments);}return symbol;}()/**
   * method totalSupply for contract WrappedIP
   *
   * @param request WrappedIpTotalSupplyRequest
   * @return Promise<WrappedIpTotalSupplyResponse>
   */)},{key:"totalSupply",value:(function(){var _totalSupply3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee297(){var result;return _regeneratorRuntime().wrap(function _callee297$(_context297){while(1)switch(_context297.prev=_context297.next){case 0:_context297.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"totalSupply"});case 2:result=_context297.sent;return _context297.abrupt("return",{result:result});case 4:case"end":return _context297.stop();}},_callee297,this);}));function totalSupply(){return _totalSupply3.apply(this,arguments);}return totalSupply;}())}]);}(WrappedIpEventClient);/**
 * contract WrappedIP write method
 */var WrappedIpClient=/*#__PURE__*/function(_WrappedIpReadOnlyCli){function WrappedIpClient(rpcClient,wallet,address){var _this17;_classCallCheck(this,WrappedIpClient);_this17=_callSuper(this,WrappedIpClient,[rpcClient,address]);_this17.wallet=wallet;return _this17;}/**
   * method approve for contract WrappedIP
   *
   * @param request WrappedIpApproveRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(WrappedIpClient,_WrappedIpReadOnlyCli);return _createClass(WrappedIpClient,[{key:"approve",value:(function(){var _approve3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee298(request){var _yield$this$rpcClient124,call;return _regeneratorRuntime().wrap(function _callee298$(_context298){while(1)switch(_context298.prev=_context298.next){case 0:_context298.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"approve",account:this.wallet.account,args:[request.spender,request.amount]});case 2:_yield$this$rpcClient124=_context298.sent;call=_yield$this$rpcClient124.request;_context298.next=6;return this.wallet.writeContract(call);case 6:return _context298.abrupt("return",_context298.sent);case 7:case"end":return _context298.stop();}},_callee298,this);}));function approve(_x192){return _approve3.apply(this,arguments);}return approve;}()/**
   * method approve for contract WrappedIP with only encode
   *
   * @param request WrappedIpApproveRequest
   * @return EncodedTxData
   */)},{key:"approveEncode",value:function approveEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"approve",args:[request.spender,request.amount]})};}/**
   * method deposit for contract WrappedIP
   *
   * @param request WrappedIpDepositRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"deposit",value:(function(){var _deposit=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee299(){var _yield$this$rpcClient125,call;return _regeneratorRuntime().wrap(function _callee299$(_context299){while(1)switch(_context299.prev=_context299.next){case 0:_context299.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"deposit",account:this.wallet.account});case 2:_yield$this$rpcClient125=_context299.sent;call=_yield$this$rpcClient125.request;_context299.next=6;return this.wallet.writeContract(call);case 6:return _context299.abrupt("return",_context299.sent);case 7:case"end":return _context299.stop();}},_callee299,this);}));function deposit(){return _deposit.apply(this,arguments);}return deposit;}()/**
   * method deposit for contract WrappedIP with only encode
   *
   * @param request WrappedIpDepositRequest
   * @return EncodedTxData
   */)},{key:"depositEncode",value:function depositEncode(){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"deposit"})};}/**
   * method permit for contract WrappedIP
   *
   * @param request WrappedIpPermitRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"permit",value:(function(){var _permit=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee300(request){var _yield$this$rpcClient126,call;return _regeneratorRuntime().wrap(function _callee300$(_context300){while(1)switch(_context300.prev=_context300.next){case 0:_context300.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"permit",account:this.wallet.account,args:[request.owner,request.spender,request.value,request.deadline,request.v,request.r,request.s]});case 2:_yield$this$rpcClient126=_context300.sent;call=_yield$this$rpcClient126.request;_context300.next=6;return this.wallet.writeContract(call);case 6:return _context300.abrupt("return",_context300.sent);case 7:case"end":return _context300.stop();}},_callee300,this);}));function permit(_x193){return _permit.apply(this,arguments);}return permit;}()/**
   * method permit for contract WrappedIP with only encode
   *
   * @param request WrappedIpPermitRequest
   * @return EncodedTxData
   */)},{key:"permitEncode",value:function permitEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"permit",args:[request.owner,request.spender,request.value,request.deadline,request.v,request.r,request.s]})};}/**
   * method transfer for contract WrappedIP
   *
   * @param request WrappedIpTransferRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transfer",value:(function(){var _transfer2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee301(request){var _yield$this$rpcClient127,call;return _regeneratorRuntime().wrap(function _callee301$(_context301){while(1)switch(_context301.prev=_context301.next){case 0:_context301.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"transfer",account:this.wallet.account,args:[request.to,request.amount]});case 2:_yield$this$rpcClient127=_context301.sent;call=_yield$this$rpcClient127.request;_context301.next=6;return this.wallet.writeContract(call);case 6:return _context301.abrupt("return",_context301.sent);case 7:case"end":return _context301.stop();}},_callee301,this);}));function transfer(_x194){return _transfer2.apply(this,arguments);}return transfer;}()/**
   * method transfer for contract WrappedIP with only encode
   *
   * @param request WrappedIpTransferRequest
   * @return EncodedTxData
   */)},{key:"transferEncode",value:function transferEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"transfer",args:[request.to,request.amount]})};}/**
   * method transferFrom for contract WrappedIP
   *
   * @param request WrappedIpTransferFromRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transferFrom",value:(function(){var _transferFrom3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee302(request){var _yield$this$rpcClient128,call;return _regeneratorRuntime().wrap(function _callee302$(_context302){while(1)switch(_context302.prev=_context302.next){case 0:_context302.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"transferFrom",account:this.wallet.account,args:[request.from,request.to,request.amount]});case 2:_yield$this$rpcClient128=_context302.sent;call=_yield$this$rpcClient128.request;_context302.next=6;return this.wallet.writeContract(call);case 6:return _context302.abrupt("return",_context302.sent);case 7:case"end":return _context302.stop();}},_callee302,this);}));function transferFrom(_x195){return _transferFrom3.apply(this,arguments);}return transferFrom;}()/**
   * method transferFrom for contract WrappedIP with only encode
   *
   * @param request WrappedIpTransferFromRequest
   * @return EncodedTxData
   */)},{key:"transferFromEncode",value:function transferFromEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"transferFrom",args:[request.from,request.to,request.amount]})};}/**
   * method withdraw for contract WrappedIP
   *
   * @param request WrappedIpWithdrawRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"withdraw",value:(function(){var _withdraw=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee303(request){var _yield$this$rpcClient129,call;return _regeneratorRuntime().wrap(function _callee303$(_context303){while(1)switch(_context303.prev=_context303.next){case 0:_context303.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"withdraw",account:this.wallet.account,args:[request.value]});case 2:_yield$this$rpcClient129=_context303.sent;call=_yield$this$rpcClient129.request;_context303.next=6;return this.wallet.writeContract(call);case 6:return _context303.abrupt("return",_context303.sent);case 7:case"end":return _context303.stop();}},_callee303,this);}));function withdraw(_x196){return _withdraw.apply(this,arguments);}return withdraw;}()/**
   * method withdraw for contract WrappedIP with only encode
   *
   * @param request WrappedIpWithdrawRequest
   * @return EncodedTxData
   */)},{key:"withdrawEncode",value:function withdrawEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"withdraw",args:[request.value]})};}}]);}(WrappedIpReadOnlyClient);

/**
 * This structure defines the terms for a Programmable IP License (PIL). These terms can be attached to IP Assets. The legal document of the PIL can be found in this repository.
 * @type LicenseTerms
 **/

var PIL_TYPE = /*#__PURE__*/function (PIL_TYPE) {
  PIL_TYPE[PIL_TYPE["NON_COMMERCIAL_REMIX"] = 0] = "NON_COMMERCIAL_REMIX";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_USE"] = 1] = "COMMERCIAL_USE";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_REMIX"] = 2] = "COMMERCIAL_REMIX";
  return PIL_TYPE;
}({});

var AddressZero = "0x0000000000000000000000000000000000000000";
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
var defaultFunctionSelector = "0x00000000";
var royaltySharesTotalSupply = 100000000;
var MAX_ROYALTY_TOKEN = 100000000;

/** Address for the WIP contract. This address is fixed */
var WIP_TOKEN_ADDRESS = "0x1514000000000000000000000000000000000000";

function getLicenseTermByType(type, term) {
  var licenseTerms = {
    transferable: true,
    royaltyPolicy: zeroAddress,
    defaultMintingFee: BigInt(0),
    expiration: BigInt(0),
    commercialUse: false,
    commercialAttribution: false,
    commercializerChecker: zeroAddress,
    commercializerCheckerData: zeroAddress,
    commercialRevShare: 0,
    commercialRevCeiling: BigInt(0),
    derivativesAllowed: true,
    derivativesAttribution: true,
    derivativesApproval: false,
    derivativesReciprocal: true,
    derivativeRevCeiling: BigInt(0),
    currency: zeroAddress,
    uri: ""
  };
  if (type === PIL_TYPE.NON_COMMERCIAL_REMIX) {
    licenseTerms.commercializerCheckerData = "0x";
    return licenseTerms;
  } else if (type === PIL_TYPE.COMMERCIAL_USE) {
    if (!term || term.defaultMintingFee === undefined || term.currency === undefined) {
      throw new Error("DefaultMintingFee, currency are required for commercial use PIL.");
    }
    licenseTerms.royaltyPolicy = getAddress$1(term.royaltyPolicyAddress, "term.royaltyPolicyLAPAddress");
    licenseTerms.defaultMintingFee = BigInt(term.defaultMintingFee);
    licenseTerms.commercialUse = true;
    licenseTerms.commercialAttribution = true;
    licenseTerms.derivativesReciprocal = false;
    licenseTerms.currency = getAddress$1(term.currency, "term.currency");
    return licenseTerms;
  } else {
    if (!term || term.defaultMintingFee === undefined || term.currency === undefined || term.commercialRevShare === undefined) {
      throw new Error("DefaultMintingFee, currency and commercialRevShare are required for commercial remix PIL.");
    }
    licenseTerms.royaltyPolicy = getAddress$1(term.royaltyPolicyAddress, "term.royaltyPolicyLAPAddress");
    licenseTerms.defaultMintingFee = BigInt(term.defaultMintingFee);
    licenseTerms.commercialUse = true;
    licenseTerms.commercialAttribution = true;
    licenseTerms.commercialRevShare = getRevenueShare(term.commercialRevShare);
    licenseTerms.derivativesReciprocal = true;
    licenseTerms.currency = getAddress$1(term.currency, "term.currency");
    return licenseTerms;
  }
}
function validateLicenseTerms(_x, _x2) {
  return _validateLicenseTerms.apply(this, arguments);
}
function _validateLicenseTerms() {
  _validateLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params, rpcClient) {
    var royaltyPolicy, currency, royaltyModuleReadOnlyClient, isWhitelistedArbitrationPolicy, isWhitelistedRoyaltyToken, object;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          royaltyPolicy = params.royaltyPolicy, currency = params.currency;
          royaltyModuleReadOnlyClient = new RoyaltyModuleReadOnlyClient(rpcClient);
          if (!(getAddress$1(royaltyPolicy, "params.royaltyPolicy") !== zeroAddress)) {
            _context.next = 8;
            break;
          }
          _context.next = 5;
          return royaltyModuleReadOnlyClient.isWhitelistedRoyaltyPolicy({
            royaltyPolicy: royaltyPolicy
          });
        case 5:
          isWhitelistedArbitrationPolicy = _context.sent;
          if (isWhitelistedArbitrationPolicy) {
            _context.next = 8;
            break;
          }
          throw new Error("The royalty policy is not whitelisted.");
        case 8:
          if (!(getAddress$1(currency, "params.currency") !== zeroAddress)) {
            _context.next = 14;
            break;
          }
          _context.next = 11;
          return royaltyModuleReadOnlyClient.isWhitelistedRoyaltyToken({
            token: currency
          });
        case 11:
          isWhitelistedRoyaltyToken = _context.sent;
          if (isWhitelistedRoyaltyToken) {
            _context.next = 14;
            break;
          }
          throw new Error("The currency token is not whitelisted.");
        case 14:
          if (!(royaltyPolicy !== zeroAddress && currency === zeroAddress)) {
            _context.next = 16;
            break;
          }
          throw new Error("Royalty policy requires currency token.");
        case 16:
          object = _objectSpread2(_objectSpread2({}, params), {}, {
            defaultMintingFee: BigInt(params.defaultMintingFee),
            expiration: BigInt(params.expiration),
            commercialRevCeiling: BigInt(params.commercialRevCeiling),
            derivativeRevCeiling: BigInt(params.derivativeRevCeiling)
          });
          if (!(object.defaultMintingFee < 0)) {
            _context.next = 19;
            break;
          }
          throw new Error("DefaultMintingFee should be greater than or equal to 0.");
        case 19:
          if (!(object.defaultMintingFee > 0 && object.royaltyPolicy === zeroAddress)) {
            _context.next = 21;
            break;
          }
          throw new Error("Royalty policy is required when defaultMintingFee is greater than 0.");
        case 21:
          verifyCommercialUse(object);
          verifyDerivatives(object);
          if (!(object.commercialRevShare < 0 || object.commercialRevShare > 100)) {
            _context.next = 27;
            break;
          }
          throw new Error("CommercialRevShare should be between 0 and 100.");
        case 27:
          object.commercialRevShare = object.commercialRevShare / 100 * 100000000;
        case 28:
          return _context.abrupt("return", object);
        case 29:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _validateLicenseTerms.apply(this, arguments);
}
var verifyCommercialUse = function verifyCommercialUse(terms) {
  if (!terms.commercialUse) {
    if (terms.commercialAttribution) {
      throw new Error("Cannot add commercial attribution when commercial use is disabled.");
    }
    if (terms.commercializerChecker !== zeroAddress) {
      throw new Error("Cannot add commercializerChecker when commercial use is disabled.");
    }
    if (terms.commercialRevShare > 0) {
      throw new Error("Cannot add commercial revenue share when commercial use is disabled.");
    }
    if (terms.commercialRevCeiling > 0) {
      throw new Error("Cannot add commercial revenue ceiling when commercial use is disabled.");
    }
    if (terms.derivativeRevCeiling > 0) {
      throw new Error("Cannot add derivative revenue ceiling share when commercial use is disabled.");
    }
    if (terms.royaltyPolicy !== zeroAddress) {
      throw new Error("Cannot add commercial royalty policy when commercial use is disabled.");
    }
  } else {
    if (terms.royaltyPolicy === zeroAddress) {
      throw new Error("Royalty policy is required when commercial use is enabled.");
    }
  }
};
var verifyDerivatives = function verifyDerivatives(terms) {
  if (!terms.derivativesAllowed) {
    if (terms.derivativesAttribution) {
      throw new Error("Cannot add derivative attribution when derivative use is disabled.");
    }
    if (terms.derivativesApproval) {
      throw new Error("Cannot add derivative approval when derivative use is disabled.");
    }
    if (terms.derivativesReciprocal) {
      throw new Error("Cannot add derivative reciprocal when derivative use is disabled.");
    }
    if (terms.derivativeRevCeiling > 0) {
      throw new Error("Cannot add derivative revenue ceiling when derivative use is disabled.");
    }
  }
};
var getRevenueShare = function getRevenueShare(revShare) {
  var revShareNumber = Number(revShare);
  if (isNaN(revShareNumber)) {
    throw new Error("CommercialRevShare must be a valid number.");
  }
  if (revShareNumber < 0 || revShareNumber > 100) {
    throw new Error("CommercialRevShare should be between 0 and 100.");
  }
  return revShareNumber / 100 * MAX_ROYALTY_TOKEN;
};

/**
 * Get the signature for setting permissions.
 * @param param - The parameter object containing necessary data to get the signature.
 * @param param.ipId - The IP ID.
 * @param param.deadline - The deadline.
 * @param param.nonce - The nonce.
 * @param param.wallet - The wallet client.
 * @param param.chainId - The chain ID.
 * @param param.permissionFunc - The permission function,default function is setPermission.
 * @returns A Promise that resolves to the signature.
 */
var getPermissionSignature = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(param) {
    var ipId, deadline, state, wallet, chainId, permissions, accessAddress, isBatchPermissionFunction, data;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          ipId = param.ipId, deadline = param.deadline, state = param.state, wallet = param.wallet, chainId = param.chainId, permissions = param.permissions;
          accessAddress = accessControllerAddress[Number(chainId)];
          isBatchPermissionFunction = permissions.length >= 2;
          data = encodeFunctionData({
            abi: accessControllerAbi,
            functionName: isBatchPermissionFunction ? "setBatchTransientPermissions" : "setTransientPermission",
            args: isBatchPermissionFunction ? [permissions.map(function (item, index) {
              return {
                ipAccount: getAddress$1(item.ipId, "permissions[".concat(index, "].ipId")),
                signer: getAddress$1(item.signer, "permissions[".concat(index, "].signer")),
                to: getAddress$1(item.to, "permissions[".concat(index, "].to")),
                func: item.func ? toFunctionSelector(item.func) : defaultFunctionSelector,
                permission: item.permission
              };
            })] : [getAddress$1(permissions[0].ipId, "permissions[0].ipId"), getAddress$1(permissions[0].signer, "permissions[0].signer"), getAddress$1(permissions[0].to, "permissions[0].to"), permissions[0].func ? toFunctionSelector(permissions[0].func) : defaultFunctionSelector, permissions[0].permission]
          });
          _context.next = 6;
          return getSignature({
            state: state,
            to: accessAddress,
            encodeData: data,
            wallet: wallet,
            verifyingContract: ipId,
            deadline: deadline,
            chainId: chainId
          });
        case 6:
          return _context.abrupt("return", _context.sent);
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getPermissionSignature(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getDeadline = function getDeadline(unixTimestamp, deadline) {
  if (deadline && (isNaN(Number(deadline)) || BigInt(deadline) < 0n)) {
    throw new Error("Invalid deadline value.");
  }
  return deadline ? unixTimestamp + BigInt(deadline) : unixTimestamp + 1000n;
};

/**
 * Get the signature.
 * @param param - The parameter object containing necessary data to get the signature.
 * @param param.state - The IP Account's state.
 * @param param.to - The recipient address.
 * @param param.encodeData - The encoded data.
 * @param param.wallet - The wallet client.
 * @param param.verifyingContract - The verifying contract.
 * @param param.deadline - The deadline.
 * @param param.chainId - The chain ID.
 * @returns A Promise that resolves to the signature.
 */
var getSignature = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {
    var state, to, encodeData, wallet, verifyingContract, deadline, chainId, nonce, signature;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          state = _ref2.state, to = _ref2.to, encodeData = _ref2.encodeData, wallet = _ref2.wallet, verifyingContract = _ref2.verifyingContract, deadline = _ref2.deadline, chainId = _ref2.chainId;
          if (wallet.signTypedData) {
            _context2.next = 3;
            break;
          }
          throw new Error("The wallet client does not support signTypedData, please try again.");
        case 3:
          if (wallet.account) {
            _context2.next = 5;
            break;
          }
          throw new Error("The wallet client does not have an account, please try again.");
        case 5:
          nonce = keccak256(encodeAbiParameters([{
            name: "",
            type: "bytes32"
          }, {
            name: "",
            type: "bytes"
          }], [state, encodeFunctionData({
            abi: ipAccountImplAbi,
            functionName: "execute",
            args: [to, 0n, encodeData]
          })]));
          _context2.next = 8;
          return wallet.signTypedData({
            account: wallet.account,
            domain: {
              name: "Story Protocol IP Account",
              version: "1",
              chainId: Number(chainId),
              verifyingContract: verifyingContract
            },
            types: {
              Execute: [{
                name: "to",
                type: "address"
              }, {
                name: "value",
                type: "uint256"
              }, {
                name: "data",
                type: "bytes"
              }, {
                name: "nonce",
                type: "bytes32"
              }, {
                name: "deadline",
                type: "uint256"
              }]
            },
            primaryType: "Execute",
            message: {
              to: to,
              value: BigInt(0),
              data: encodeData,
              nonce: nonce,
              deadline: BigInt(deadline)
            }
          });
        case 8:
          signature = _context2.sent;
          return _context2.abrupt("return", {
            signature: signature,
            nonce: nonce
          });
        case 10:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function getSignature(_x2) {
    return _ref3.apply(this, arguments);
  };
}();

/**
 * Permission level
 * @enum {number}
 **/
var AccessPermission = /*#__PURE__*/function (AccessPermission) {
  AccessPermission[AccessPermission["ABSTAIN"] = 0] = "ABSTAIN";
  AccessPermission[AccessPermission["ALLOW"] = 1] = "ALLOW";
  AccessPermission[AccessPermission["DENY"] = 2] = "DENY";
  return AccessPermission;
}({});

/**
 * Gets the function signature from an ABI for a given method name
 * @param abi - The contract ABI
 * @param methodName - The name of the method to get the signature for
 * @param overloadIndex - Optional index for overloaded functions (0-based)
 * @returns The function signature in standard format (e.g. "methodName(uint256,address)")
 * @throws Error if method not found or if overloadIndex is required but not provided
 */
function getFunctionSignature(abi, methodName, overloadIndex) {
  var functions = abi.filter(function (x) {
    return x.type === "function" && x.name === methodName;
  });
  if (functions.length === 0) {
    throw new Error("Method ".concat(methodName, " not found in ABI."));
  }
  if (functions.length > 1 && overloadIndex === undefined) {
    throw new Error("Method ".concat(methodName, " has ").concat(functions.length, " overloads. Please specify overloadIndex (0-").concat(functions.length - 1, ")."));
  }
  var func = functions[overloadIndex || 0];
  var getTypeString = function getTypeString(input) {
    if (input.type.startsWith("tuple")) {
      var _input$components;
      var components = (_input$components = input.components) === null || _input$components === void 0 ? void 0 : _input$components.map(function (comp) {
        return getTypeString(comp);
      }).join(",");
      return "(".concat(components, ")");
    }
    return input.type;
  };
  var inputs = func.inputs.map(function (input) {
    return getTypeString(input);
  }).join(",");
  return "".concat(methodName, "(").concat(inputs, ")");
}

var validateLicenseConfig = function validateLicenseConfig(licensingConfig) {
  var licenseConfig = _objectSpread2(_objectSpread2({}, licensingConfig), {}, {
    expectMinimumGroupRewardShare: Number(licensingConfig.expectMinimumGroupRewardShare),
    commercialRevShare: getRevenueShare(licensingConfig.commercialRevShare),
    mintingFee: BigInt(licensingConfig.mintingFee),
    expectGroupRewardPool: getAddress$1(licensingConfig.expectGroupRewardPool, "licensingConfig.expectGroupRewardPool"),
    licensingHook: getAddress$1(licensingConfig.licensingHook, "licensingConfig.licensingHook")
  });
  if (isNaN(licenseConfig.expectMinimumGroupRewardShare)) {
    throw new Error("The expectMinimumGroupRewardShare must be a valid number.");
  }
  if (licenseConfig.expectMinimumGroupRewardShare < 0 || licenseConfig.expectMinimumGroupRewardShare > 100) {
    throw new Error("The expectMinimumGroupRewardShare must be greater than 0 and less than 100.");
  }
  if (licenseConfig.mintingFee < 0) {
    throw new Error("The mintingFee must be greater than 0.");
  }
  return licenseConfig;
};

var getIpMetadataForWorkflow = function getIpMetadataForWorkflow(metadata) {
  return {
    ipMetadataURI: (metadata === null || metadata === void 0 ? void 0 : metadata.ipMetadataURI) || "",
    ipMetadataHash: (metadata === null || metadata === void 0 ? void 0 : metadata.ipMetadataHash) || zeroHash,
    nftMetadataURI: (metadata === null || metadata === void 0 ? void 0 : metadata.nftMetadataURI) || "",
    nftMetadataHash: (metadata === null || metadata === void 0 ? void 0 : metadata.nftMetadataHash) || zeroHash
  };
};

function simulateAndWriteContract(_x) {
  return _simulateAndWriteContract.apply(this, arguments);
}
function _simulateAndWriteContract() {
  _simulateAndWriteContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var rpcClient, wallet, waitForTransaction, data, _yield$rpcClient$simu, request, txHash, receipt;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          rpcClient = _ref.rpcClient, wallet = _ref.wallet, waitForTransaction = _ref.waitForTransaction, data = _ref.data;
          _context.next = 3;
          return rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, data), {}, {
            account: wallet.account
          }));
        case 3:
          _yield$rpcClient$simu = _context.sent;
          request = _yield$rpcClient$simu.request;
          _context.next = 7;
          return wallet.writeContract(request);
        case 7:
          txHash = _context.sent;
          if (!(waitForTransaction !== false)) {
            _context.next = 13;
            break;
          }
          _context.next = 11;
          return rpcClient.waitForTransactionReceipt({
            hash: txHash
          });
        case 11:
          receipt = _context.sent;
          return _context.abrupt("return", {
            txHash: txHash,
            receipt: receipt
          });
        case 13:
          return _context.abrupt("return", {
            txHash: txHash
          });
        case 14:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _simulateAndWriteContract.apply(this, arguments);
}

function handleTxOptions(_x) {
  return _handleTxOptions.apply(this, arguments);
}
function _handleTxOptions() {
  _handleTxOptions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var txOptions, rpcClient, txHash, receipt;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          txOptions = _ref.txOptions, rpcClient = _ref.rpcClient, txHash = _ref.txHash;
          if (!(!txOptions || !txOptions.waitForTransaction)) {
            _context.next = 3;
            break;
          }
          return _context.abrupt("return", {
            txHash: txHash
          });
        case 3:
          _context.next = 5;
          return rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
            hash: txHash
          }));
        case 5:
          receipt = _context.sent;
          return _context.abrupt("return", {
            txHash: txHash,
            receipt: receipt
          });
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _handleTxOptions.apply(this, arguments);
}

/**
 * check the allowance of all spenders and call approval if any spender
 * allowance is lower than the amount they are expected to spend.
 * Supports using multicall to return all approve calls in a multicall array.
 */
var approvalAllSpenders = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
    var spenders, client, owner, useMultiCall, rpcClient, multicallAddress, approvals, allCalls, _iterator, _step, approval, hash;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          spenders = _ref.spenders, client = _ref.client, owner = _ref.owner, useMultiCall = _ref.useMultiCall, rpcClient = _ref.rpcClient, multicallAddress = _ref.multicallAddress;
          _context2.next = 3;
          return Promise.all(spenders.map( /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(spender) {
              var spenderAmount, _yield$client$allowan, allowance;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!(spender.address === multicallAddress)) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return");
                  case 2:
                    spenderAmount = spender.amount || maxUint256;
                    _context.next = 5;
                    return client.allowance({
                      owner: owner,
                      spender: spender.address
                    });
                  case 5:
                    _yield$client$allowan = _context.sent;
                    allowance = _yield$client$allowan.result;
                    if (!(allowance < spenderAmount)) {
                      _context.next = 9;
                      break;
                    }
                    return _context.abrupt("return", {
                      spender: spender.address,
                      amount: maxUint256 // approve max amount to avoid approvals in the future
                    });
                  case 9:
                    return _context.abrupt("return");
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x2) {
              return _ref3.apply(this, arguments);
            };
          }()));
        case 3:
          approvals = _context2.sent;
          if (!useMultiCall) {
            _context2.next = 8;
            break;
          }
          allCalls = [];
          approvals.forEach(function (approval) {
            if (!approval) {
              return;
            }
            var encodedData = client.approveEncode(approval);
            allCalls.push({
              target: encodedData.to,
              allowFailure: false,
              value: 0n,
              callData: encodedData.data
            });
          });
          return _context2.abrupt("return", allCalls);
        case 8:
          // make approval calls sequentially
          _iterator = _createForOfIteratorHelper(approvals);
          _context2.prev = 9;
          _iterator.s();
        case 11:
          if ((_step = _iterator.n()).done) {
            _context2.next = 22;
            break;
          }
          approval = _step.value;
          if (approval) {
            _context2.next = 15;
            break;
          }
          return _context2.abrupt("continue", 20);
        case 15:
          _context2.next = 17;
          return client.approve(approval);
        case 17:
          hash = _context2.sent;
          _context2.next = 20;
          return rpcClient.waitForTransactionReceipt({
            hash: hash
          });
        case 20:
          _context2.next = 11;
          break;
        case 22:
          _context2.next = 27;
          break;
        case 24:
          _context2.prev = 24;
          _context2.t0 = _context2["catch"](9);
          _iterator.e(_context2.t0);
        case 27:
          _context2.prev = 27;
          _iterator.f();
          return _context2.finish(27);
        case 30:
          return _context2.abrupt("return", []);
        case 31:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[9, 24, 27, 30]]);
  }));
  return function approvalAllSpenders(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var calculateLicenseWipMintFee = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {
    var fee;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return params.licensingModuleClient.predictMintingLicenseFee({
            licensorIpId: params.parentIpId,
            licenseTemplate: params.licenseTemplateClient.address,
            licenseTermsId: params.licenseTermsId,
            amount: params.amount,
            receiver: params.receiver,
            royaltyContext: zeroAddress
          });
        case 2:
          fee = _context3.sent;
          if (!(fee.currencyToken !== WIP_TOKEN_ADDRESS)) {
            _context3.next = 5;
            break;
          }
          return _context3.abrupt("return", 0n);
        case 5:
          return _context3.abrupt("return", fee.tokenAmount);
        case 6:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function calculateLicenseWipMintFee(_x3) {
    return _ref4.apply(this, arguments);
  };
}();
var calculateSPGWipMintFee = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(spgNftClient) {
    var token;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return spgNftClient.mintFeeToken();
        case 2:
          token = _context4.sent;
          if (!(token !== WIP_TOKEN_ADDRESS)) {
            _context4.next = 5;
            break;
          }
          return _context4.abrupt("return", 0n);
        case 5:
          _context4.next = 7;
          return spgNftClient.mintFee();
        case 7:
          return _context4.abrupt("return", _context4.sent);
        case 8:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return function calculateSPGWipMintFee(_x4) {
    return _ref5.apply(this, arguments);
  };
}();
var multiCallWrapIp = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref6) {
    var ipAmountToWrap, wipClient, multicall3Client, wipSpenders, calls, rpcClient, wallet, contractCall, wipOptions, multiCalls, useMultiCall, deposit, autoApprove, approvalCalls, txHash;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          ipAmountToWrap = _ref6.ipAmountToWrap, wipClient = _ref6.wipClient, multicall3Client = _ref6.multicall3Client, wipSpenders = _ref6.wipSpenders, calls = _ref6.calls, rpcClient = _ref6.rpcClient, wallet = _ref6.wallet, contractCall = _ref6.contractCall, wipOptions = _ref6.wipOptions;
          if (!(ipAmountToWrap === 0n)) {
            _context5.next = 3;
            break;
          }
          throw new Error("ipAmountToWrap should be greater than 0");
        case 3:
          multiCalls = [];
          useMultiCall = (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.useMulticallWhenPossible) !== false;
          if (!useMultiCall) {
            _context5.next = 10;
            break;
          }
          deposit = wipClient.depositEncode();
          multiCalls.push({
            target: deposit.to,
            allowFailure: false,
            value: ipAmountToWrap,
            callData: deposit.data
          });
          _context5.next = 12;
          break;
        case 10:
          _context5.next = 12;
          return simulateAndWriteContract({
            rpcClient: rpcClient,
            wallet: wallet,
            data: {
              abi: wrappedIpAbi,
              address: WIP_TOKEN_ADDRESS,
              functionName: "deposit",
              value: ipAmountToWrap
            },
            waitForTransaction: true
          });
        case 12:
          autoApprove = (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.enableAutoApprove) !== false;
          if (!autoApprove) {
            _context5.next = 18;
            break;
          }
          _context5.next = 16;
          return approvalAllSpenders({
            spenders: wipSpenders,
            client: wipClient,
            multicallAddress: multicall3Client.address,
            owner: useMultiCall ? multicall3Client.address : wallet.account.address,
            rpcClient: rpcClient,
            useMultiCall: useMultiCall
          });
        case 16:
          approvalCalls = _context5.sent;
          if (approvalCalls.length > 0 && useMultiCall) {
            multiCalls.push.apply(multiCalls, _toConsumableArray(approvalCalls));
          }
        case 18:
          multiCalls.push.apply(multiCalls, _toConsumableArray(calls));
          if (useMultiCall) {
            _context5.next = 24;
            break;
          }
          _context5.next = 22;
          return contractCall();
        case 22:
          txHash = _context5.sent;
          return _context5.abrupt("return", {
            txHash: txHash
          });
        case 24:
          return _context5.abrupt("return", simulateAndWriteContract({
            rpcClient: rpcClient,
            wallet: wallet,
            data: {
              abi: multicall3Abi,
              address: multicall3Client.address,
              functionName: "aggregate3Value",
              args: [multiCalls],
              value: ipAmountToWrap
            },
            // caller should handle waiting for transaction if needed
            waitForTransaction: false
          }));
        case 25:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return function multiCallWrapIp(_x5) {
    return _ref7.apply(this, arguments);
  };
}();

/**
 * Handle contract calls that require WIP fees by automatically wrapping IP to WIP when needed.
 *
 * @remarks
 * This function will automatically handle the following:
 *
 * If the user does not have enough WIP, it will wrap IP to WIP, unless
 * disabled via `disableAutoWrappingIp`.
 *
 * If the user have enough WIP, it will check for if approvals are needed
 * for each spender address and batch them in a multicall, unless disabled via
 * `disableAutoApprove`.
 */
var contractCallWithWipFees = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref8) {
    var totalFees, wipOptions, multicall3Client, rpcClient, wipClient, wallet, wipSpenders, contractCall, sender, txOptions, encodedTxs, _txHash, wipBalanceOf, wipBalance, calls, autoApprove, autoWrapIp, _txHash2, startingBalance, _yield$multiCallWrapI, txHash;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          totalFees = _ref8.totalFees, wipOptions = _ref8.wipOptions, multicall3Client = _ref8.multicall3Client, rpcClient = _ref8.rpcClient, wipClient = _ref8.wipClient, wallet = _ref8.wallet, wipSpenders = _ref8.wipSpenders, contractCall = _ref8.contractCall, sender = _ref8.sender, txOptions = _ref8.txOptions, encodedTxs = _ref8.encodedTxs;
          if (!(totalFees === 0n)) {
            _context6.next = 6;
            break;
          }
          _context6.next = 4;
          return contractCall();
        case 4:
          _txHash = _context6.sent;
          return _context6.abrupt("return", handleTxOptions({
            rpcClient: rpcClient,
            txOptions: txOptions,
            txHash: _txHash
          }));
        case 6:
          _context6.next = 8;
          return wipClient.balanceOf({
            owner: sender
          });
        case 8:
          wipBalanceOf = _context6.sent;
          wipBalance = wipBalanceOf.result;
          calls = encodedTxs.map(function (data) {
            return {
              target: data.to,
              allowFailure: false,
              value: 0n,
              callData: data.data
            };
          });
          autoApprove = (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.enableAutoApprove) !== false;
          autoWrapIp = (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.enableAutoWrapIp) !== false; // handle when there's enough WIP to cover all fees
          if (!(wipBalance >= totalFees)) {
            _context6.next = 21;
            break;
          }
          if (!autoApprove) {
            _context6.next = 17;
            break;
          }
          _context6.next = 17;
          return approvalAllSpenders({
            spenders: wipSpenders,
            client: wipClient,
            owner: sender,
            // sender owns the wip
            multicallAddress: multicall3Client.address,
            rpcClient: rpcClient,
            // since sender has all wip, if using multicall, we will also need to transfer
            // sender's wip to multicall, which brings more complexity. So in this case,
            // we don't use multicall here and instead just wait for each approval to be finished.
            useMultiCall: false
          });
        case 17:
          _context6.next = 19;
          return contractCall();
        case 19:
          _txHash2 = _context6.sent;
          return _context6.abrupt("return", handleTxOptions({
            rpcClient: rpcClient,
            txOptions: txOptions,
            txHash: _txHash2
          }));
        case 21:
          _context6.next = 23;
          return rpcClient.getBalance({
            address: sender
          });
        case 23:
          startingBalance = _context6.sent;
          if (!(startingBalance < totalFees)) {
            _context6.next = 26;
            break;
          }
          throw new Error("Wallet does not have enough IP to wrap to WIP and pay for fees. Total fees: ".concat(getTokenAmountDisplay(totalFees), ", balance: ").concat(getTokenAmountDisplay(startingBalance)));
        case 26:
          if (autoWrapIp) {
            _context6.next = 28;
            break;
          }
          throw new Error("Wallet does not have enough WIP to pay for fees. Total fees: ".concat(getTokenAmountDisplay(totalFees), ", balance: ").concat(getTokenAmountDisplay(wipBalance, "WIP")));
        case 28:
          _context6.next = 30;
          return multiCallWrapIp({
            ipAmountToWrap: totalFees,
            multicall3Client: multicall3Client,
            wipClient: wipClient,
            wipOptions: wipOptions,
            contractCall: contractCall,
            wipSpenders: wipSpenders,
            rpcClient: rpcClient,
            wallet: wallet,
            calls: calls
          });
        case 30:
          _yield$multiCallWrapI = _context6.sent;
          txHash = _yield$multiCallWrapI.txHash;
          return _context6.abrupt("return", handleTxOptions({
            rpcClient: rpcClient,
            txOptions: txOptions,
            txHash: txHash
          }));
        case 33:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return function contractCallWithWipFees(_x6) {
    return _ref9.apply(this, arguments);
  };
}();

var _excluded = ["title", "description", "ipType", "relationships", "createdAt", "watermarkImg", "creators", "media", "attributes", "app", "tags", "robotTerms"];
var IPAssetClient = /*#__PURE__*/function () {
  function IPAssetClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, IPAssetClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.licenseTokenReadOnlyClient = new LicenseTokenReadOnlyClient(rpcClient);
    this.accessControllerClient = new AccessControllerClient(rpcClient, wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(rpcClient, wallet);
    this.registrationWorkflowsClient = new RegistrationWorkflowsClient(rpcClient, wallet);
    this.licenseAttachmentWorkflowsClient = new LicenseAttachmentWorkflowsClient(rpcClient, wallet);
    this.derivativeWorkflowsClient = new DerivativeWorkflowsClient(rpcClient, wallet);
    this.royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
    this.royaltyModuleEventClient = new RoyaltyModuleEventClient(rpcClient);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.spgNftClient = new SpgnftImplReadOnlyClient(rpcClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.walletAddress = this.wallet.account.address;
  }

  /**
   * Create a new `IpCreator` object with the specified details.
   * @param params - The parameters required to create the `IpCreator` object.
   *   @param params.name The name of the creator.
   *   @param params.address The wallet address of the creator.
   *   @param params.description [Optional] A description of the creator.
   *   @param params.image [Optional] The URL or path to an image representing the creator.
   *   @param {Array} params.socialMedia [Optional] An array of social media profiles associated with the creator.
   *     @param params.socialMedia[].platform The name of the social media platform.
   *     @param params.socialMedia[].url The URL to the creator's profile on the platform.
   *  @param params.contributionPercent The percentage of contribution by the creator, must add up to 100.
   *  @param params.role [Optional] The role of the creator in relation to the IP.
   * @returns An `IpCreator` object containing the provided details.
   */
  return _createClass(IPAssetClient, [{
    key: "generateCreatorMetadata",
    value: function generateCreatorMetadata(param) {
      var name = param.name,
        address = param.address,
        _param$description = param.description,
        description = _param$description === void 0 ? "" : _param$description,
        _param$image = param.image,
        image = _param$image === void 0 ? "" : _param$image,
        _param$socialMedia = param.socialMedia,
        socialMedia = _param$socialMedia === void 0 ? [] : _param$socialMedia,
        contributionPercent = param.contributionPercent,
        _param$role = param.role,
        role = _param$role === void 0 ? "" : _param$role;
      return {
        name: name,
        address: address,
        description: description,
        image: image,
        socialMedia: socialMedia,
        contributionPercent: contributionPercent,
        role: role
      };
    }

    /**
     * Create a new `IpMetadata` object with the specified details.
     * @param params - The parameters required to create the `IpMetadata` object.
     *   @param params.title [Optional] The title of the IP.
     *   @param params.description [Optional] A description of the IP.
     *   @param params.ipType [Optional] The type of the IP asset (e.g., "character", "chapter").
     *   @param {Array} params.relationships [Optional] An array of relationships between this IP and its parent IPs.
     *     @param params.relationships[].ipId The ID of the parent IP.
     *     @param params.relationships[].type The type of relationship (e.g., "APPEARS_IN").
     *   @param params.createdAt [Optional] The creation date and time of the IP in ISO 8601 format.
     *   @param params.watermarkImg [Optional] The URL or path to an image used as a watermark for the IP.
     *   @param {Array} params.creators [Optional] An array of creators associated with the IP.
     *     @param params.creators[].name The name of the creator.
     *     @param params.creators[].address The address of the creator.
     *     @param params.creators[].description [Optional] A description of the creator.
     *     @param params.creators[].image [Optional] The URL or path to an image representing the creator.
     *     @param params.creators[].socialMedia [Optional] An array of social media profiles for the creator.
     *     @param params.creators[].socialMedia[].platform The social media platform name.
     *     @param params.creators[].socialMedia[].url The URL to the creator's profile.
     *     @param params.creators[].role [Optional] The role of the creator in relation to the IP.
     *     @param params.creators[].contributionPercent The percentage of contribution by the creator.
     *   @param {Array} params.media [Optional] An array of media related to the IP.
     *     @param params.media[].name The name of the media.
     *     @param params.media[].url The URL to the media.
     *     @param params.media[].mimeType The MIME type of the media.
     *   @param {Array} params.attributes [Optional] An array of key-value pairs providing additional metadata.
     *     @param params.attributes[].key The key for the attribute.
     *     @param params.attributes[].value The value for the attribute, can be a string or number.
     *   @param {Object} params.app [Optional] Information about the application associated with the IP.
     *     @param params.app.id The ID of the application.
     *     @param params.app.name The name of the application.
     *     @param params.app.website The website URL of the application.
     *   @param {Array} params.tags [Optional] An array of tags associated with the IP.
     *   @param {Object} params.robotTerms [Optional] Robot terms for the IP, specifying access rules.
     *     @param params.robotTerms.userAgent The user agent for which the rules apply.
     *     @param params.robotTerms.allow The rules allowing access.
     *   @param params.additionalProperties [Optional] Any additional key-value pairs to include in the metadata.
     * @returns An `IpMetadata` object containing the provided details and any additional properties.
     */
  }, {
    key: "generateIpMetadata",
    value: function generateIpMetadata(param) {
      var _param$title = param.title,
        title = _param$title === void 0 ? "" : _param$title,
        _param$description2 = param.description,
        description = _param$description2 === void 0 ? "" : _param$description2,
        _param$ipType = param.ipType,
        ipType = _param$ipType === void 0 ? "" : _param$ipType,
        _param$relationships = param.relationships,
        relationships = _param$relationships === void 0 ? [] : _param$relationships,
        _param$createdAt = param.createdAt,
        createdAt = _param$createdAt === void 0 ? "" : _param$createdAt,
        _param$watermarkImg = param.watermarkImg,
        watermarkImg = _param$watermarkImg === void 0 ? "" : _param$watermarkImg,
        _param$creators = param.creators,
        creators = _param$creators === void 0 ? [] : _param$creators,
        _param$media = param.media,
        media = _param$media === void 0 ? [] : _param$media,
        _param$attributes = param.attributes,
        attributes = _param$attributes === void 0 ? [] : _param$attributes,
        app = param.app,
        _param$tags = param.tags,
        tags = _param$tags === void 0 ? [] : _param$tags,
        robotTerms = param.robotTerms,
        additionalProperties = _objectWithoutProperties(param, _excluded);
      return _objectSpread2({
        title: title,
        description: description,
        ipType: ipType,
        relationships: relationships,
        createdAt: createdAt,
        watermarkImg: watermarkImg,
        creators: creators,
        media: media,
        attributes: attributes,
        app: app,
        tags: tags,
        robotTerms: robotTerms
      }, additionalProperties);
    }

    /**
     * Registers an NFT as IP, creating a corresponding IP record.
     * @param request - The request object that contains all data needed to register IP.
     *   @param request.nftContract The address of the NFT.
     *   @param request.tokenId The token identifier of the NFT.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes IP ID, token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, resolverAddr, metadataProviderAddress, metadata)
     */
  }, {
    key: "register",
    value: (function () {
      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, tokenId, ipIdAddress, isRegistered, object, calculatedDeadline, _yield$getPermissionS, signature, _request$txOptions2, txHash, txReceipt, log;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context.next = 4;
              return this.getIpIdAddress(request.nftContract, tokenId);
            case 4:
              ipIdAddress = _context.sent;
              _context.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context.sent;
              if (!isRegistered) {
                _context.next = 10;
                break;
              }
              return _context.abrupt("return", {
                ipId: ipIdAddress
              });
            case 10:
              object = {
                tokenId: tokenId,
                nftContract: getAddress$1(request.nftContract, "request.nftContract"),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigMetadata: {
                  signer: zeroAddress,
                  deadline: BigInt(0),
                  signature: zeroHash
                }
              };
              if (!request.ipMetadata) {
                _context.next = 20;
                break;
              }
              _context.next = 14;
              return this.getCalculatedDeadline(request.deadline);
            case 14:
              calculatedDeadline = _context.sent;
              _context.next = 17;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.registrationWorkflowsClient.address, "registrationWorkflowsClient"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }]
              });
            case 17:
              _yield$getPermissionS = _context.sent;
              signature = _yield$getPermissionS.signature;
              object.sigMetadata = {
                signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                deadline: calculatedDeadline,
                signature: signature
              };
            case 20:
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 28;
                break;
              }
              if (!request.ipMetadata) {
                _context.next = 25;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.registrationWorkflowsClient.registerIpEncode(object)
              });
            case 25:
              return _context.abrupt("return", {
                encodedTxData: this.ipAssetRegistryClient.registerEncode({
                  tokenContract: object.nftContract,
                  tokenId: object.tokenId,
                  chainid: BigInt(chain[this.chainId])
                })
              });
            case 26:
              _context.next = 46;
              break;
            case 28:
              if (!request.ipMetadata) {
                _context.next = 34;
                break;
              }
              _context.next = 31;
              return this.registrationWorkflowsClient.registerIp(object);
            case 31:
              txHash = _context.sent;
              _context.next = 37;
              break;
            case 34:
              _context.next = 36;
              return this.ipAssetRegistryClient.register({
                tokenContract: object.nftContract,
                tokenId: object.tokenId,
                chainid: BigInt(this.chainId)
              });
            case 36:
              txHash = _context.sent;
            case 37:
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 45;
                break;
              }
              _context.next = 40;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 40:
              txReceipt = _context.sent;
              log = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0];
              return _context.abrupt("return", _objectSpread2({
                txHash: txHash
              }, log));
            case 45:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 46:
              _context.next = 51;
              break;
            case 48:
              _context.prev = 48;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register IP");
            case 51:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 48]]);
      }));
      function register(_x) {
        return _register.apply(this, arguments);
      }
      return register;
    }()
    /**
     * Batch registers an NFT as IP, creating a corresponding IP record.
     * @param request - The request object that contains all data needed to batch register IP.
     *  @param {Array} request.args The array of objects containing the data needed to register IP.
     *   @param request.args.nftContract The address of the NFT.
     *   @param request.args.tokenId The token identifier of the NFT.
     *   @param {Object} request.args.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *    @param request.args.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *    @param request.args.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *    @param request.args.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *    @param request.args.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property, without encodedTxDataOnly option.
     * @returns A Promise that resolves to a transaction hash, if waitForTransaction is true, return an array of containing IP ID, Token ID, NFT Contract.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, resolverAddr, metadataProviderAddress, metadata)
     */
    )
  }, {
    key: "batchRegister",
    value: (function () {
      var _batchRegister = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _this = this;
        var _request$txOptions3, contracts, spgContracts, encodedTxData, _iterator, _step, arg, result, spgTxHash, txHash, results, processTransaction;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              contracts = [];
              spgContracts = [];
              _iterator = _createForOfIteratorHelper(request.args);
              _context3.prev = 4;
              _iterator.s();
            case 6:
              if ((_step = _iterator.n()).done) {
                _context3.next = 21;
                break;
              }
              arg = _step.value;
              _context3.prev = 8;
              _context3.next = 11;
              return this.register(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 11:
              result = _context3.sent;
              encodedTxData = result.encodedTxData.data;
              _context3.next = 18;
              break;
            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](8);
              throw new Error(_context3.t0.message.replace("Failed to register IP:", "").trim());
            case 18:
              if (arg.ipMetadata) {
                spgContracts.push(encodedTxData);
              } else {
                contracts.push({
                  target: this.ipAssetRegistryClient.address,
                  allowFailure: false,
                  callData: encodedTxData
                });
              }
            case 19:
              _context3.next = 6;
              break;
            case 21:
              _context3.next = 26;
              break;
            case 23:
              _context3.prev = 23;
              _context3.t1 = _context3["catch"](4);
              _iterator.e(_context3.t1);
            case 26:
              _context3.prev = 26;
              _iterator.f();
              return _context3.finish(26);
            case 29:
              if (!(spgContracts.length > 0)) {
                _context3.next = 33;
                break;
              }
              _context3.next = 32;
              return this.registrationWorkflowsClient.multicall({
                data: spgContracts
              });
            case 32:
              spgTxHash = _context3.sent;
            case 33:
              if (!(contracts.length > 0)) {
                _context3.next = 37;
                break;
              }
              _context3.next = 36;
              return this.multicall3Client.aggregate3({
                calls: contracts
              });
            case 36:
              txHash = _context3.sent;
            case 37:
              results = [];
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context3.next = 49;
                break;
              }
              processTransaction = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(hash, contractType) {
                  var txReceipt, eventResults;
                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return _this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                          hash: hash
                        }));
                      case 2:
                        txReceipt = _context2.sent;
                        eventResults = _this.getIpIdAndTokenIdsFromEvent(txReceipt, contractType);
                        results.push.apply(results, _toConsumableArray(eventResults));
                      case 5:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2);
                }));
                return function processTransaction(_x3, _x4) {
                  return _ref.apply(this, arguments);
                };
              }();
              if (!txHash) {
                _context3.next = 43;
                break;
              }
              _context3.next = 43;
              return processTransaction(txHash, "nftContract");
            case 43:
              if (!spgTxHash) {
                _context3.next = 46;
                break;
              }
              _context3.next = 46;
              return processTransaction(spgTxHash, "spgNftContract");
            case 46:
              return _context3.abrupt("return", {
                txHash: txHash,
                spgTxHash: spgTxHash,
                results: results
              });
            case 49:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 50:
              _context3.next = 55;
              break;
            case 52:
              _context3.prev = 52;
              _context3.t2 = _context3["catch"](0);
              handleError(_context3.t2, "Failed to batch register IP");
            case 55:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 52], [4, 23, 26, 29], [8, 15]]);
      }));
      function batchRegister(_x2) {
        return _batchRegister.apply(this, arguments);
      }
      return batchRegister;
    }()
    /**
     * Registers a derivative directly with parent IP's license terms, without needing license tokens,
     * and attaches the license terms of the parent IPs to the derivative IP.
     * The license terms must be attached to the parent IP before calling this function.
     * All IPs attached default license terms by default.
     * The derivative IP owner must be the caller or an authorized operator.
     * @param request - The request object that contains all data needed to register derivative IP.
     *   @param request.childIpId The derivative IP ID.
     *   @param {Array} request.parentIpIds The parent IP IDs.
     *   @param {Array} request.licenseTermsIds The IDs of the license terms that the parent IP supports.
     *   @param request.maxMintingFee The maximum minting fee that the caller is willing to pay. if set to 0 then no limit.
     *   @param request.maxRts The maximum number of royalty tokens that can be distributed to the external royalty policies (max: 100,000,000).
     *   @param request.maxRevenueShare The maximum revenue share percentage allowed for minting the License Tokens. Must be between 0 and 100,000,000 (where 100,000,000 represents 100%).
     *   @param request.licenseTemplate [Optional] The license template address, default value is Programmable IP License.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data.
     */
    )
  }, {
    key: "registerDerivative",
    value: (function () {
      var _registerDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions4, isChildIpIdRegistered, derivativeData, object, _request$txOptions5, txHash;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return this.isRegistered(request.childIpId);
            case 3:
              isChildIpIdRegistered = _context4.sent;
              if (isChildIpIdRegistered) {
                _context4.next = 6;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 6:
              _context4.next = 8;
              return this.validateDerivativeData(request);
            case 8:
              derivativeData = _context4.sent;
              object = _objectSpread2({
                childIpId: request.childIpId
              }, derivativeData);
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.encodedTxDataOnly)) {
                _context4.next = 14;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.licensingModuleClient.registerDerivativeEncode(object)
              });
            case 14:
              _context4.next = 16;
              return this.licensingModuleClient.registerDerivative(object);
            case 16:
              txHash = _context4.sent;
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.waitForTransaction)) {
                _context4.next = 23;
                break;
              }
              _context4.next = 20;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 20:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 23:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 24:
              _context4.next = 29;
              break;
            case 26:
              _context4.prev = 26;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to register derivative");
            case 29:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 26]]);
      }));
      function registerDerivative(_x5) {
        return _registerDerivative.apply(this, arguments);
      }
      return registerDerivative;
    }()
    /**
     * Batch registers a derivative directly with parent IP's license terms.
     * @param request - The request object that contains all data needed to batch register derivative IP.
     *  @param {Array} request.args The array of objects containing the data needed to register derivative IP.
     *    @param request.args.childIpId The derivative IP ID.
     *    @param {Array} request.args.parentIpIds The parent IP IDs.
     *    @param {Array} request.args.licenseTermsIds The IDs of the license terms that the parent IP supports.
     *    @param request.args.maxMintingFee The maximum minting fee that the caller is willing to pay. if set to 0 then no limit.
     *    @param request.args.maxRts The maximum number of royalty tokens that can be distributed to the external royalty policies (max: 100,000,000).
     *    @param request.args.maxRevenueShare The maximum revenue share percentage allowed for minting the License Tokens. Must be between 0 and 100,000,000 (where 100,000,000 represents 100%).
     *  @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *  @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property, without encodedTxDataOnly option.
     * @returns A Promise that resolves to a transaction hash.
     */
    )
  }, {
    key: "batchRegisterDerivative",
    value: (function () {
      var _batchRegisterDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions6, contracts, licenseModuleAddress, _iterator2, _step2, arg, calculatedDeadline, ipAccount, data, _yield$ipAccount$stat, state, _yield$getSignature, signature, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              contracts = [];
              licenseModuleAddress = getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress");
              _iterator2 = _createForOfIteratorHelper(request.args);
              _context5.prev = 4;
              _iterator2.s();
            case 6:
              if ((_step2 = _iterator2.n()).done) {
                _context5.next = 32;
                break;
              }
              arg = _step2.value;
              _context5.prev = 8;
              _context5.next = 11;
              return this.registerDerivative(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 11:
              _context5.next = 16;
              break;
            case 13:
              _context5.prev = 13;
              _context5.t0 = _context5["catch"](8);
              throw new Error(_context5.t0.message.replace("Failed to register derivative:", "").trim());
            case 16:
              _context5.next = 18;
              return this.getCalculatedDeadline(request.deadline);
            case 18:
              calculatedDeadline = _context5.sent;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(arg.childIpId, "arg.childIpId"));
              data = encodeFunctionData({
                abi: licensingModuleAbi,
                functionName: "registerDerivative",
                args: [arg.childIpId, arg.parentIpIds, arg.licenseTermsIds.map(function (id) {
                  return BigInt(id);
                }), arg.licenseTemplate || this.licenseTemplateClient.address, zeroAddress, BigInt(arg.maxMintingFee), Number(arg.maxRts), getRevenueShare(arg.maxRevenueShare)]
              });
              _context5.next = 23;
              return ipAccount.state();
            case 23:
              _yield$ipAccount$stat = _context5.sent;
              state = _yield$ipAccount$stat.result;
              _context5.next = 27;
              return getSignature({
                state: state,
                to: licenseModuleAddress,
                encodeData: data,
                wallet: this.wallet,
                verifyingContract: arg.childIpId,
                deadline: calculatedDeadline,
                chainId: chain[this.chainId]
              });
            case 27:
              _yield$getSignature = _context5.sent;
              signature = _yield$getSignature.signature;
              contracts.push({
                target: arg.childIpId,
                allowFailure: false,
                callData: encodeFunctionData({
                  abi: ipAccountImplAbi,
                  functionName: "executeWithSig",
                  args: [licenseModuleAddress, BigInt(0), data, this.wallet.account.address, calculatedDeadline, signature]
                })
              });
            case 30:
              _context5.next = 6;
              break;
            case 32:
              _context5.next = 37;
              break;
            case 34:
              _context5.prev = 34;
              _context5.t1 = _context5["catch"](4);
              _iterator2.e(_context5.t1);
            case 37:
              _context5.prev = 37;
              _iterator2.f();
              return _context5.finish(37);
            case 40:
              _context5.next = 42;
              return this.multicall3Client.aggregate3({
                calls: contracts
              });
            case 42:
              txHash = _context5.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context5.next = 49;
                break;
              }
              _context5.next = 46;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 46:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 49:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 50:
              _context5.next = 55;
              break;
            case 52:
              _context5.prev = 52;
              _context5.t2 = _context5["catch"](0);
              handleError(_context5.t2, "Failed to batch register derivative");
            case 55:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 52], [4, 34, 37, 40], [8, 13]]);
      }));
      function batchRegisterDerivative(_x6) {
        return _batchRegisterDerivative.apply(this, arguments);
      }
      return batchRegisterDerivative;
    }()
    /**
     * Registers a derivative with license tokens. The derivative IP is registered with license tokens minted from the parent IP's license terms.
     * The license terms of the parent IPs issued with license tokens are attached to the derivative IP.
     * The caller must be the derivative IP owner or an authorized operator.
     * @param request - The request object that contains all data needed to register derivative license tokens.
     *   @param request.childIpId The derivative IP ID.
     *   @param {Array} request.licenseTokenIds The IDs of the license tokens.
     *    @param request.args.maxRts The maximum number of royalty tokens that can be distributed to the external royalty policies (max: 100,000,000).
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "registerDerivativeWithLicenseTokens",
    value: (function () {
      var _registerDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
        var _request$txOptions7, req, isChildIpIdRegistered, _request$txOptions8, txHash;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              req = {
                childIpId: getAddress$1(request.childIpId, "request.childIpId"),
                licenseTokenIds: request.licenseTokenIds.map(function (id) {
                  return BigInt(id);
                }),
                royaltyContext: zeroAddress,
                maxRts: Number(request.maxRts)
              };
              this.validateMaxRts(req.maxRts);
              _context6.next = 5;
              return this.isRegistered(request.childIpId);
            case 5:
              isChildIpIdRegistered = _context6.sent;
              if (isChildIpIdRegistered) {
                _context6.next = 8;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 8:
              if (!(request.licenseTokenIds.length === 0)) {
                _context6.next = 10;
                break;
              }
              throw new Error("The licenseTokenIds must be provided.");
            case 10:
              _context6.next = 12;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 12:
              request.licenseTokenIds = _context6.sent;
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context6.next = 17;
                break;
              }
              return _context6.abrupt("return", {
                encodedTxData: this.licensingModuleClient.registerDerivativeWithLicenseTokensEncode(req)
              });
            case 17:
              _context6.next = 19;
              return this.licensingModuleClient.registerDerivativeWithLicenseTokens(req);
            case 19:
              txHash = _context6.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context6.next = 26;
                break;
              }
              _context6.next = 23;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 23:
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 26:
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 27:
              _context6.next = 32;
              break;
            case 29:
              _context6.prev = 29;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to register derivative with license tokens");
            case 32:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 29]]);
      }));
      function registerDerivativeWithLicenseTokens(_x7) {
        return _registerDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerDerivativeWithLicenseTokens;
    }()
    /**
     * Mint an NFT from a collection and register it as an IP.
     * @param request - The request object that contains all data needed to mint and register ip.
     *   @param request.spgNftContract The address of the NFT collection.
     *   @param request.allowDuplicates Indicates whether the license terms can be attached to the same IP ID or not.
     *   @param {Array} request.licenseTermsData The PIL terms and licensing configuration data to be attached to the IP.
     *     @param {Object} request.licenseTermsData.terms The PIL terms to be used for the licensing.
     *       @param request.licenseTermsData.terms.transferable Indicates whether the license is transferable or not.
     *       @param request.licenseTermsData.terms.royaltyPolicy The address of the royalty policy contract which required to StoryProtocol in advance.
     *       @param request.licenseTermsData.terms.mintingFee The fee to be paid when minting a license.
     *       @param request.licenseTermsData.terms.expiration The expiration period of the license.
     *       @param request.licenseTermsData.terms.commercialUse Indicates whether the work can be used commercially or not, Commercial use is required to deploy a royalty vault.
     *       @param request.licenseTermsData.terms.commercialAttribution Whether attribution is required when reproducing the work commercially or not.
     *       @param request.licenseTermsData.terms.commercializerChecker Commercializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
     *       @param request.licenseTermsData.terms.commercializerCheckerData The data to be passed to the commercializer checker contract.
     *       @param request.licenseTermsData.terms.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *       @param request.licenseTermsData.terms.commercialRevCeiling The maximum revenue that can be generated from the commercial use of the work.
     *       @param request.licenseTermsData.terms.derivativesAllowed Indicates whether the licensee can create derivatives of his work or not.
     *       @param request.licenseTermsData.terms.derivativesAttribution Indicates whether attribution is required for derivatives of the work or not.
     *       @param request.licenseTermsData.terms.derivativesApproval Indicates whether the licensor must approve derivatives of the work before they can be linked to the licensor IP ID or not.
     *       @param request.licenseTermsData.terms.derivativesReciprocal Indicates whether the licensee must license derivatives of the work under the same terms or not.
     *       @param request.licenseTermsData.terms.derivativeRevCeiling The maximum revenue that can be generated from the derivative use of the work.
     *       @param request.licenseTermsData.terms.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *       @param request.licenseTermsData.terms.uri The URI of the license terms, which can be used to fetch the offchain license terms.
     *     @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *       @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *       @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *       @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *       @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *       @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *       @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *       @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *       If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *       @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.recipient [Optional] The address of the recipient of the minted NFT,default value is your wallet address.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, including IP ID, Token ID, License Terms Ids.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     * @emits LicenseTermsAttached (caller, ipId, licenseTemplate, licenseTermsId)
     */
    )
  }, {
    key: "mintAndRegisterIpAssetWithPilTerms",
    value: (function () {
      var _mintAndRegisterIpAssetWithPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {
        var _this2 = this;
        var _request$txOptions9, _yield$this$validateL, licenseTerms, licenseTermsData, object, encodedTxData, contractCall, rsp, licenseTermsIds;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return this.validateLicenseTermsData(request.licenseTermsData);
            case 3:
              _yield$this$validateL = _context7.sent;
              licenseTerms = _yield$this$validateL.licenseTerms;
              licenseTermsData = _yield$this$validateL.licenseTermsData;
              object = {
                spgNftContract: getAddress$1(request.spgNftContract, "request.spgNftContract"),
                recipient: request.recipient && getAddress$1(request.recipient, "request.recipient") || this.wallet.account.address,
                licenseTermsData: licenseTermsData,
                allowDuplicates: request.allowDuplicates,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata)
              };
              encodedTxData = this.licenseAttachmentWorkflowsClient.mintAndRegisterIpAndAttachPilTermsEncode(object);
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context7.next = 10;
                break;
              }
              return _context7.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 10:
              contractCall = function contractCall() {
                return _this2.licenseAttachmentWorkflowsClient.mintAndRegisterIpAndAttachPilTerms(object);
              };
              _context7.next = 13;
              return this.commonRegistrationHandler({
                wipOptions: request.wipOptions,
                sender: this.walletAddress,
                spgNftContract: object.spgNftContract,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              });
            case 13:
              rsp = _context7.sent;
              if (!rsp.receipt) {
                _context7.next = 21;
                break;
              }
              _context7.next = 17;
              return this.getLicenseTermsId(licenseTerms);
            case 17:
              licenseTermsIds = _context7.sent;
              return _context7.abrupt("return", _objectSpread2(_objectSpread2({}, rsp), {}, {
                licenseTermsIds: licenseTermsIds
              }));
            case 21:
              return _context7.abrupt("return", rsp);
            case 22:
              _context7.next = 27;
              break;
            case 24:
              _context7.prev = 24;
              _context7.t0 = _context7["catch"](0);
              handleError(_context7.t0, "Failed to mint and register IP and attach PIL terms");
            case 27:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 24]]);
      }));
      function mintAndRegisterIpAssetWithPilTerms(_x8) {
        return _mintAndRegisterIpAssetWithPilTerms.apply(this, arguments);
      }
      return mintAndRegisterIpAssetWithPilTerms;
    }()
    /**
     * Batch mint an NFT from a collection and register it as an IP.
     * @param request - The request object that contains all data needed to batch mint and register ip.
     *   @param {Array} request.args The array of mint and register IP requests.
     *     @param request.args.spgNftContract The address of the NFT collection.
     *     @param request.allowDuplicates Indicates whether the license terms can be attached to the same IP ID or not.
     *     @param {Array} request.args.licenseTermsData The PIL terms and licensing configuration data to be attached to the IP.
     *       @param {Object} request.args.licenseTermsData.terms The PIL terms to be used for the licensing.
     *         @param request.args.licenseTermsData.terms.transferable Indicates whether the license is transferable or not.
     *         @param request.args.licenseTermsData.terms.royaltyPolicy The address of the royalty policy contract which required to StoryProtocol in advance.
     *         @param request.args.licenseTermsData.terms.mintingFee The fee to be paid when minting a license.
     *         @param request.args.licenseTermsData.terms.expiration The expiration period of the license.
     *         @param request.args.licenseTermsData.terms.commercialUse Indicates whether the work can be used commercially or not, Commercial use is required to deploy a royalty vault.
     *         @param request.args.licenseTermsData.terms.commercialAttribution Whether attribution is required when reproducing the work commercially or not.
     *         @param request.args.licenseTermsData.terms.commercializerChecker Commercializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
     *         @param request.args.licenseTermsData.terms.commercializerCheckerData The data to be passed to the commercializer checker contract.
     *         @param request.args.licenseTermsData.terms.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *         @param request.args.licenseTermsData.terms.commercialRevCeiling The maximum revenue that can be generated from the commercial use of the work.
     *         @param request.args.licenseTermsData.terms.derivativesAllowed Indicates whether the licensee can create derivatives of his work or not.
     *         @param request.args.licenseTermsData.terms.derivativesAttribution Indicates whether attribution is required for derivatives of the work or not.
     *         @param request.args.licenseTermsData.terms.derivativesApproval Indicates whether the licensor must approve derivatives of the work before they can be linked to the licensor IP ID or not.
     *         @param request.args.licenseTermsData.terms.derivativesReciprocal Indicates whether the licensee must license derivatives of the work under the same terms or not.
     *         @param request.args.licenseTermsData.terms.derivativeRevCeiling The maximum revenue that can be generated from the derivative use of the work.
     *         @param request.args.licenseTermsData.terms.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *         @param request.args.licenseTermsData.terms.uri The URI of the license terms, which can be used to fetch the offchain license terms.
     *       @param {Object} request.args.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *         @param request.args.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *         @param request.args.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *         @param request.args.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *         @param request.args.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *         @param request.args.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *         @param request.args.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *         @param request.args.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *         If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *         @param request.args.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *     @param {Object} request.args.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *       @param request.args.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *       @param request.args.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *       @param request.args.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *       @param request.args.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *     @param request.args.recipient [Optional] The address of the recipient of the minted NFT,default value is your wallet address.
     *    @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property, without encodedTxData option.
     * @returns A Promise that resolves to a transaction hash, if waitForTransaction is true, return an array containing IP ID, Token ID, License Terms Ids, SPG NFT Contract.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     * @emits LicenseTermsAttached (caller, ipId, licenseTemplate, licenseTermsId)
     */
    )
  }, {
    key: "batchMintAndRegisterIpAssetWithPilTerms",
    value: (function () {
      var _batchMintAndRegisterIpAssetWithPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {
        var _request$txOptions10, calldata, _iterator3, _step3, arg, result, txHash, txReceipt, results, j, licenseTerms, licenseTermsData, i, licenseTerm, licenseTermsIds;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              calldata = [];
              _iterator3 = _createForOfIteratorHelper(request.args);
              _context8.prev = 3;
              _iterator3.s();
            case 5:
              if ((_step3 = _iterator3.n()).done) {
                _context8.next = 13;
                break;
              }
              arg = _step3.value;
              _context8.next = 9;
              return this.mintAndRegisterIpAssetWithPilTerms(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 9:
              result = _context8.sent;
              calldata.push(result.encodedTxData.data);
            case 11:
              _context8.next = 5;
              break;
            case 13:
              _context8.next = 18;
              break;
            case 15:
              _context8.prev = 15;
              _context8.t0 = _context8["catch"](3);
              _iterator3.e(_context8.t0);
            case 18:
              _context8.prev = 18;
              _iterator3.f();
              return _context8.finish(18);
            case 21:
              _context8.next = 23;
              return this.licenseAttachmentWorkflowsClient.multicall({
                data: calldata
              });
            case 23:
              txHash = _context8.sent;
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.waitForTransaction)) {
                _context8.next = 50;
                break;
              }
              _context8.next = 27;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 27:
              txReceipt = _context8.sent;
              results = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt).map(function (log) {
                return {
                  ipId: log.ipId,
                  tokenId: log.tokenId,
                  spgNftContract: log.tokenContract,
                  licenseTermsIds: []
                };
              }); // Due to emit event log by sequence, we need to get license terms id from request.args
              j = 0;
            case 30:
              if (!(j < request.args.length)) {
                _context8.next = 49;
                break;
              }
              licenseTerms = [];
              licenseTermsData = request.args[j].licenseTermsData;
              i = 0;
            case 34:
              if (!(i < licenseTermsData.length)) {
                _context8.next = 42;
                break;
              }
              _context8.next = 37;
              return validateLicenseTerms(licenseTermsData[i].terms, this.rpcClient);
            case 37:
              licenseTerm = _context8.sent;
              licenseTerms.push(licenseTerm);
            case 39:
              i++;
              _context8.next = 34;
              break;
            case 42:
              _context8.next = 44;
              return this.getLicenseTermsId(licenseTerms);
            case 44:
              licenseTermsIds = _context8.sent;
              results[j].licenseTermsIds = licenseTermsIds;
            case 46:
              j++;
              _context8.next = 30;
              break;
            case 49:
              return _context8.abrupt("return", {
                txHash: txHash,
                results: results
              });
            case 50:
              return _context8.abrupt("return", {
                txHash: txHash
              });
            case 53:
              _context8.prev = 53;
              _context8.t1 = _context8["catch"](0);
              handleError(_context8.t1, "Failed to batch mint and register IP and attach PIL terms");
            case 56:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[0, 53], [3, 15, 18, 21]]);
      }));
      function batchMintAndRegisterIpAssetWithPilTerms(_x9) {
        return _batchMintAndRegisterIpAssetWithPilTerms.apply(this, arguments);
      }
      return batchMintAndRegisterIpAssetWithPilTerms;
    }()
    /**
     * Register a given NFT as an IP and attach Programmable IP License Terms.R.
     * @param request - The request object that contains all data needed to mint and register ip.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param {Array} request.licenseTermsData The PIL terms and licensing configuration data to be attached to the IP.
     *     @param {Object} request.licenseTermsData.terms The PIL terms to be used for the licensing.
     *       @param request.licenseTermsData.terms.transferable Indicates whether the license is transferable or not.
     *       @param request.licenseTermsData.terms.royaltyPolicy The address of the royalty policy contract which required to StoryProtocol in advance.
     *       @param request.licenseTermsData.terms.mintingFee The fee to be paid when minting a license.
     *       @param request.licenseTermsData.terms.expiration The expiration period of the license.
     *       @param request.licenseTermsData.terms.commercialUse Indicates whether the work can be used commercially or not, Commercial use is required to deploy a royalty vault.
     *       @param request.licenseTermsData.terms.commercialAttribution Whether attribution is required when reproducing the work commercially or not.
     *       @param request.licenseTermsData.terms.commercializerChecker Commercializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
     *       @param request.licenseTermsData.terms.commercializerCheckerData The data to be passed to the commercializer checker contract.
     *       @param request.licenseTermsData.terms.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *       @param request.licenseTermsData.terms.commercialRevCeiling The maximum revenue that can be generated from the commercial use of the work.
     *       @param request.licenseTermsData.terms.derivativesAllowed Indicates whether the licensee can create derivatives of his work or not.
     *       @param request.licenseTermsData.terms.derivativesAttribution Indicates whether attribution is required for derivatives of the work or not.
     *       @param request.licenseTermsData.terms.derivativesApproval Indicates whether the licensor must approve derivatives of the work before they can be linked to the licensor IP ID or not.
     *       @param request.licenseTermsData.terms.derivativesReciprocal Indicates whether the licensee must license derivatives of the work under the same terms or not.
     *       @param request.licenseTermsData.terms.derivativeRevCeiling The maximum revenue that can be generated from the derivative use of the work.
     *       @param request.licenseTermsData.terms.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *       @param request.licenseTermsData.terms.uri The URI of the license terms, which can be used to fetch the offchain license terms.
     *     @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *       @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *       @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *       @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *       @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *       @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *       @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *       @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *       If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *       @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, if waitForTransaction is true, including IP ID, token ID and License terms IDs.
     * @emits LicenseTermsAttached (caller, ipId, licenseTemplate, licenseTermsId)
     */
    )
  }, {
    key: "registerIpAndAttachPilTerms",
    value: (function () {
      var _registerIpAndAttachPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {
        var _request$txOptions11, ipIdAddress, isRegistered, _yield$this$validateL2, licenseTerms, licenseTermsData, calculatedDeadline, _yield$getPermissionS2, signature, _object, _request$txOptions12, txHash, txReceipt, log;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              request.tokenId = BigInt(request.tokenId);
              _context9.next = 4;
              return this.getIpIdAddress(request.nftContract, request.tokenId);
            case 4:
              ipIdAddress = _context9.sent;
              _context9.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context9.sent;
              if (!isRegistered) {
                _context9.next = 10;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 10:
              _context9.next = 12;
              return this.validateLicenseTermsData(request.licenseTermsData);
            case 12:
              _yield$this$validateL2 = _context9.sent;
              licenseTerms = _yield$this$validateL2.licenseTerms;
              licenseTermsData = _yield$this$validateL2.licenseTermsData;
              _context9.next = 17;
              return this.getCalculatedDeadline(request.deadline);
            case 17:
              calculatedDeadline = _context9.sent;
              _context9.next = 20;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.licenseAttachmentWorkflowsClient.address, "licenseAttachmentWorkflowsClient"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }, {
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.licenseAttachmentWorkflowsClient.address, "licenseAttachmentWorkflowsClient"),
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleClient"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
                }, {
                  ipId: ipIdAddress,
                  signer: this.licenseAttachmentWorkflowsClient.address,
                  to: this.licensingModuleClient.address,
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
                }]
              });
            case 20:
              _yield$getPermissionS2 = _context9.sent;
              signature = _yield$getPermissionS2.signature;
              _object = {
                nftContract: getAddress$1(request.nftContract, "request.nftContract"),
                tokenId: request.tokenId,
                licenseTermsData: licenseTermsData,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigMetadataAndAttachAndConfig: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: signature
                }
              };
              if (!((_request$txOptions11 = request.txOptions) !== null && _request$txOptions11 !== void 0 && _request$txOptions11.encodedTxDataOnly)) {
                _context9.next = 27;
                break;
              }
              return _context9.abrupt("return", {
                encodedTxData: this.licenseAttachmentWorkflowsClient.registerIpAndAttachPilTermsEncode(_object)
              });
            case 27:
              _context9.next = 29;
              return this.licenseAttachmentWorkflowsClient.registerIpAndAttachPilTerms(_object);
            case 29:
              txHash = _context9.sent;
              if (!((_request$txOptions12 = request.txOptions) !== null && _request$txOptions12 !== void 0 && _request$txOptions12.waitForTransaction)) {
                _context9.next = 43;
                break;
              }
              _context9.next = 33;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 33:
              txReceipt = _context9.sent;
              log = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0];
              _context9.t0 = _objectSpread2;
              _context9.t1 = txHash;
              _context9.next = 39;
              return this.getLicenseTermsId(licenseTerms);
            case 39:
              _context9.t2 = _context9.sent;
              _context9.t3 = {
                txHash: _context9.t1,
                licenseTermsIds: _context9.t2
              };
              _context9.t4 = log;
              return _context9.abrupt("return", (0, _context9.t0)(_context9.t3, _context9.t4));
            case 43:
              return _context9.abrupt("return", {
                txHash: txHash
              });
            case 44:
              _context9.next = 49;
              break;
            case 46:
              _context9.prev = 46;
              _context9.t5 = _context9["catch"](0);
              handleError(_context9.t5, "Failed to register IP and attach PIL terms");
            case 49:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[0, 46]]);
      }));
      function registerIpAndAttachPilTerms(_x10) {
        return _registerIpAndAttachPilTerms.apply(this, arguments);
      }
      return registerIpAndAttachPilTerms;
    }()
    /**
     * Register the given NFT as a derivative IP with metadata without using license tokens.
     * @param request - The request object that contains all data needed to register derivative IP.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param {Object} request.derivData The derivative data to be used for registerDerivative.
     *     @param {Array} request.derivData.parentIpIds The IDs of the parent IPs to link the registered derivative IP.
     *     @param {Array} request.derivData.licenseTermsIds The IDs of the license terms to be used for the linking.
     *     @param request.derivData.licenseTemplate [Optional] The address of the license template to be used for the linking, default value is Programmable IP License.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, included IP ID, Token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "registerDerivativeIp",
    value: (function () {
      var _registerDerivativeIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(request) {
        var _this3 = this;
        var _request$txOptions13, tokenId, ipIdAddress, isRegistered, calculatedDeadline, _yield$getPermissionS3, signature, derivData, _object2, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context10.next = 4;
              return this.getIpIdAddress(request.nftContract, tokenId);
            case 4:
              ipIdAddress = _context10.sent;
              _context10.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context10.sent;
              if (!isRegistered) {
                _context10.next = 10;
                break;
              }
              throw new Error("The NFT with id ".concat(tokenId, " is already registered as IP."));
            case 10:
              _context10.next = 12;
              return this.getCalculatedDeadline(request.deadline);
            case 12:
              calculatedDeadline = _context10.sent;
              _context10.next = 15;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.derivativeWorkflowsClient.address, "derivativeWorkflowsClient"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }, {
                  ipId: ipIdAddress,
                  signer: this.derivativeWorkflowsClient.address,
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "registerDerivative")
                }]
              });
            case 15:
              _yield$getPermissionS3 = _context10.sent;
              signature = _yield$getPermissionS3.signature;
              _context10.next = 19;
              return this.validateDerivativeData(request.derivData);
            case 19:
              derivData = _context10.sent;
              _object2 = {
                nftContract: getAddress$1(request.nftContract, "request.nftContract"),
                tokenId: BigInt(request.tokenId),
                derivData: derivData,
                sigMetadataAndRegister: {
                  signer: this.walletAddress,
                  deadline: calculatedDeadline,
                  signature: signature
                },
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata)
              };
              encodedTxData = this.derivativeWorkflowsClient.registerIpAndMakeDerivativeEncode(_object2);
              if (!((_request$txOptions13 = request.txOptions) !== null && _request$txOptions13 !== void 0 && _request$txOptions13.encodedTxDataOnly)) {
                _context10.next = 24;
                break;
              }
              return _context10.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 24:
              contractCall = function contractCall() {
                return _this3.derivativeWorkflowsClient.registerIpAndMakeDerivative(_object2);
              };
              return _context10.abrupt("return", this.commonRegistrationHandler({
                wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                  useMulticallWhenPossible: false
                }),
                sender: this.walletAddress,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                derivData: derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 28:
              _context10.prev = 28;
              _context10.t0 = _context10["catch"](0);
              handleError(_context10.t0, "Failed to register derivative IP");
            case 31:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this, [[0, 28]]);
      }));
      function registerDerivativeIp(_x11) {
        return _registerDerivativeIp.apply(this, arguments);
      }
      return registerDerivativeIp;
    }()
    /**
     * Mint an NFT from a collection and register it as a derivative IP without license tokens.
     * @param request - The request object that contains all data needed to mint and register ip and make derivative.
     *   @param request.spgNftContract The address of the NFT collection.
     *   @param request.allowDuplicates Set to true to allow minting an NFT with a duplicate metadata hash.
     *   @param {Object} request.derivData The derivative data to be used for registerDerivative.
     *     @param {Array} request.derivData.parentIpIds The IDs of the parent IPs to link the registered derivative IP.
     *     @param {Array} request.derivData.licenseTermsIds The IDs of the license terms to be used for the linking.
     *     @param request.derivData.licenseTemplate [Optional] The address of the license template to be used for the linking, default value is Programmable IP License.
     *     @param request.derivData.royaltyContext The address of the royalty context to be used for the linking, default value is zero address.
     *     @param request.derivData.maxMintingFee The maximum minting fee that the caller is willing to pay. if set to 0 then no limit.
     *     @param request.derivData.maxRts The maximum number of royalty tokens that can be distributed to the external royalty policies (max: 100,000,000).
     *     @param request.derivData.maxRevenueShare The maximum revenue share percentage allowed for minting the License Tokens. Must be between 0 and 100,000,000 (where 100,000,000 represents 100%).
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.recipient [Optional] The address of the recipient of the minted NFT,default value is your wallet address.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes child IP ID and token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(request) {
        var _this4 = this;
        var _request$txOptions14, derivData, recipient, spgNftContract, _object3, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _context11.prev = 0;
              _context11.next = 3;
              return this.validateDerivativeData(request.derivData);
            case 3:
              derivData = _context11.sent;
              recipient = request.recipient && getAddress$1(request.recipient, "request.recipient") || this.walletAddress;
              spgNftContract = getAddress$1(request.spgNftContract, "spgNftContract");
              _object3 = _objectSpread2(_objectSpread2({}, request), {}, {
                derivData: derivData,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                recipient: recipient,
                allowDuplicates: request.allowDuplicates,
                spgNftContract: spgNftContract
              });
              encodedTxData = this.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeEncode(_object3);
              if (!((_request$txOptions14 = request.txOptions) !== null && _request$txOptions14 !== void 0 && _request$txOptions14.encodedTxDataOnly)) {
                _context11.next = 10;
                break;
              }
              return _context11.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 10:
              contractCall = function contractCall() {
                return _this4.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivative(_object3);
              };
              return _context11.abrupt("return", this.commonRegistrationHandler({
                wipOptions: request.wipOptions,
                sender: this.walletAddress,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                spgNftContract: spgNftContract,
                derivData: derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 14:
              _context11.prev = 14;
              _context11.t0 = _context11["catch"](0);
              handleError(_context11.t0, "Failed to mint and register IP and make derivative");
            case 17:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this, [[0, 14]]);
      }));
      function mintAndRegisterIpAndMakeDerivative(_x12) {
        return _mintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivative;
    }()
    /**
     * Batch mint an NFT from a collection and register it as a derivative IP without license tokens.
     * @param request - The request object that contains all data needed to batch mint and register ip and make derivative.
     *  @param {Array} request.args The array of mint and register IP requests.
     *   @param request.args.spgNftContract The address of the NFT collection.
     *   @param {Object} request.args.derivData The derivative data to be used for registerDerivative.
     *     @param {Array} request.args.derivData.parentIpIds The IDs of the parent IPs to link the registered derivative IP.
     *     @param {Array} request.args.derivData.licenseTermsIds The IDs of the license terms to be used for the linking.
     *     @param request.args.derivData.licenseTemplate [Optional] The address of the license template to be used for the linking.
     *   @param {Object} request.args.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.args.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.args.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.args.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.args.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.arg.recipient [Optional] The address of the recipient of the minted NFT,default value is your wallet address.
     *  @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property, without encodedTxData option.
     * @returns A Promise that resolves to a transaction hash, if waitForTransaction is true, return an array of containing IP ID and token ID, SPG NFT Contract.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "batchMintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _batchMintAndRegisterIpAndMakeDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(request) {
        var _request$txOptions15, calldata, _iterator4, _step4, arg, result, txHash, txReceipt;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.prev = 0;
              calldata = [];
              _iterator4 = _createForOfIteratorHelper(request.args);
              _context12.prev = 3;
              _iterator4.s();
            case 5:
              if ((_step4 = _iterator4.n()).done) {
                _context12.next = 19;
                break;
              }
              arg = _step4.value;
              _context12.prev = 7;
              _context12.next = 10;
              return this.mintAndRegisterIpAndMakeDerivative(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 10:
              result = _context12.sent;
              calldata.push(result.encodedTxData.data);
              _context12.next = 17;
              break;
            case 14:
              _context12.prev = 14;
              _context12.t0 = _context12["catch"](7);
              throw new Error(_context12.t0.message.replace("Failed to mint and register IP and make derivative: ", "").trim());
            case 17:
              _context12.next = 5;
              break;
            case 19:
              _context12.next = 24;
              break;
            case 21:
              _context12.prev = 21;
              _context12.t1 = _context12["catch"](3);
              _iterator4.e(_context12.t1);
            case 24:
              _context12.prev = 24;
              _iterator4.f();
              return _context12.finish(24);
            case 27:
              _context12.next = 29;
              return this.derivativeWorkflowsClient.multicall({
                data: calldata
              });
            case 29:
              txHash = _context12.sent;
              if (!((_request$txOptions15 = request.txOptions) !== null && _request$txOptions15 !== void 0 && _request$txOptions15.waitForTransaction)) {
                _context12.next = 35;
                break;
              }
              _context12.next = 33;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 33:
              txReceipt = _context12.sent;
              return _context12.abrupt("return", {
                txHash: txHash,
                results: this.getIpIdAndTokenIdsFromEvent(txReceipt, "spgNftContract")
              });
            case 35:
              return _context12.abrupt("return", {
                txHash: txHash
              });
            case 38:
              _context12.prev = 38;
              _context12.t2 = _context12["catch"](0);
              handleError(_context12.t2, "Failed to batch mint and register IP and make derivative");
            case 41:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this, [[0, 38], [3, 21, 24, 27], [7, 14]]);
      }));
      function batchMintAndRegisterIpAndMakeDerivative(_x13) {
        return _batchMintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return batchMintAndRegisterIpAndMakeDerivative;
    }()
    /**
     * Mint an NFT from a SPGNFT collection and register it with metadata as an IP.
     * @param request - The request object that contains all data needed to attach license terms.
     *   @param request.spgNftContract The address of the SPGNFT collection.
     *   @param request.recipient The address of the recipient of the minted NFT,default value is your wallet address.
     *  @param request.allowDuplicates Set to true to allow minting an NFT with a duplicate metadata hash.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, or if waitForTransaction is true, includes IP ID and Token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "mintAndRegisterIp",
    value: (function () {
      var _mintAndRegisterIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(request) {
        var _request$txOptions16, _object4, _request$txOptions17, txHash, txReceipt, log;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _context13.prev = 0;
              _object4 = {
                spgNftContract: getAddress$1(request.spgNftContract, "request.spgNftContract"),
                recipient: request.recipient && getAddress$1(request.recipient, "request.recipient") || this.wallet.account.address,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                allowDuplicates: request.allowDuplicates
              };
              if (!((_request$txOptions16 = request.txOptions) !== null && _request$txOptions16 !== void 0 && _request$txOptions16.encodedTxDataOnly)) {
                _context13.next = 6;
                break;
              }
              return _context13.abrupt("return", {
                encodedTxData: this.registrationWorkflowsClient.mintAndRegisterIpEncode(_object4)
              });
            case 6:
              _context13.next = 8;
              return this.registrationWorkflowsClient.mintAndRegisterIp(_object4);
            case 8:
              txHash = _context13.sent;
              if (!((_request$txOptions17 = request.txOptions) !== null && _request$txOptions17 !== void 0 && _request$txOptions17.waitForTransaction)) {
                _context13.next = 15;
                break;
              }
              _context13.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              txReceipt = _context13.sent;
              log = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0];
              return _context13.abrupt("return", _objectSpread2({
                txHash: txHash
              }, log));
            case 15:
              return _context13.abrupt("return", {
                txHash: txHash
              });
            case 16:
              _context13.next = 21;
              break;
            case 18:
              _context13.prev = 18;
              _context13.t0 = _context13["catch"](0);
              handleError(_context13.t0, "Failed to mint and register IP");
            case 21:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this, [[0, 18]]);
      }));
      function mintAndRegisterIp(_x14) {
        return _mintAndRegisterIp.apply(this, arguments);
      }
      return mintAndRegisterIp;
    }()
    /**
     * Register Programmable IP License Terms (if unregistered) and attach it to IP.
     * @param request - The request object that contains all data needed to attach license terms.
     *   @param request.ipId The ID of the IP.
     *   @param {Array} request.licenseTermsData The PIL terms and licensing configuration data to be attached to the IP.
     *     @param {Object} request.licenseTermsData.terms The PIL terms to be used for the licensing.
     *       @param request.licenseTermsData.terms.transferable Indicates whether the license is transferable or not.
     *       @param request.licenseTermsData.terms.royaltyPolicy The address of the royalty policy contract which required to StoryProtocol in advance.
     *       @param request.licenseTermsData.terms.mintingFee The fee to be paid when minting a license.
     *       @param request.licenseTermsData.terms.expiration The expiration period of the license.
     *       @param request.licenseTermsData.terms.commercialUse Indicates whether the work can be used commercially or not, Commercial use is required to deploy a royalty vault.
     *       @param request.licenseTermsData.terms.commercialAttribution Whether attribution is required when reproducing the work commercially or not.
     *       @param request.licenseTermsData.terms.commercializerChecker Commercializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
     *       @param request.licenseTermsData.terms.commercializerCheckerData The data to be passed to the commercializer checker contract.
     *       @param request.licenseTermsData.terms.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *       @param request.licenseTermsData.terms.commercialRevCeiling The maximum revenue that can be generated from the commercial use of the work.
     *       @param request.licenseTermsData.terms.derivativesAllowed Indicates whether the licensee can create derivatives of his work or not.
     *       @param request.licenseTermsData.terms.derivativesAttribution Indicates whether attribution is required for derivatives of the work or not.
     *       @param request.licenseTermsData.terms.derivativesApproval Indicates whether the licensor must approve derivatives of the work before they can be linked to the licensor IP ID or not.
     *       @param request.licenseTermsData.terms.derivativesReciprocal Indicates whether the licensee must license derivatives of the work under the same terms or not.
     *       @param request.licenseTermsData.terms.derivativeRevCeiling The maximum revenue that can be generated from the derivative use of the work.
     *       @param request.licenseTermsData.terms.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *       @param request.licenseTermsData.terms.uri The URI of the license terms, which can be used to fetch the offchain license terms.
     *     @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *       @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *       @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *       @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *       @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *       @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *       @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *       @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *       If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *       @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *   @param request.deadline [Optional] The deadline for the signature in milliseconds, default is 1000s.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, returns an array containing the license terms ID.
     * @emits LicenseTermsAttached (caller, ipId, licenseTemplate, licenseTermsId)
     */
    )
  }, {
    key: "registerPilTermsAndAttach",
    value: (function () {
      var _registerPilTermsAndAttach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(request) {
        var _request$txOptions18, ipId, isRegistered, _yield$this$validateL3, licenseTerms, licenseTermsData, calculatedDeadline, ipAccount, _yield$ipAccount$stat2, state, _yield$getPermissionS4, signature, _object5, _request$txOptions19, txHash, licenseTermsIds;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.prev = 0;
              ipId = request.ipId;
              _context14.next = 4;
              return this.isRegistered(ipId);
            case 4:
              isRegistered = _context14.sent;
              if (isRegistered) {
                _context14.next = 7;
                break;
              }
              throw new Error("The IP with id ".concat(ipId, " is not registered."));
            case 7:
              _context14.next = 9;
              return this.validateLicenseTermsData(request.licenseTermsData);
            case 9:
              _yield$this$validateL3 = _context14.sent;
              licenseTerms = _yield$this$validateL3.licenseTerms;
              licenseTermsData = _yield$this$validateL3.licenseTermsData;
              _context14.next = 14;
              return this.getCalculatedDeadline(request.deadline);
            case 14:
              calculatedDeadline = _context14.sent;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              _context14.next = 18;
              return ipAccount.state();
            case 18:
              _yield$ipAccount$stat2 = _context14.sent;
              state = _yield$ipAccount$stat2.result;
              _context14.next = 22;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipId,
                  signer: getAddress$1(this.licenseAttachmentWorkflowsClient.address, "licenseAttachmentWorkflowsClient"),
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
                }, {
                  ipId: ipId,
                  signer: getAddress$1(this.licenseAttachmentWorkflowsClient.address, "licenseAttachmentWorkflowsClient"),
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
                }]
              });
            case 22:
              _yield$getPermissionS4 = _context14.sent;
              signature = _yield$getPermissionS4.signature;
              _object5 = {
                ipId: ipId,
                licenseTermsData: licenseTermsData,
                sigAttachAndConfig: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: signature
                }
              };
              if (!((_request$txOptions18 = request.txOptions) !== null && _request$txOptions18 !== void 0 && _request$txOptions18.encodedTxDataOnly)) {
                _context14.next = 29;
                break;
              }
              return _context14.abrupt("return", {
                encodedTxData: this.licenseAttachmentWorkflowsClient.registerPilTermsAndAttachEncode(_object5)
              });
            case 29:
              _context14.next = 31;
              return this.licenseAttachmentWorkflowsClient.registerPilTermsAndAttach(_object5);
            case 31:
              txHash = _context14.sent;
              if (!((_request$txOptions19 = request.txOptions) !== null && _request$txOptions19 !== void 0 && _request$txOptions19.waitForTransaction)) {
                _context14.next = 41;
                break;
              }
              _context14.next = 35;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 35:
              _context14.next = 37;
              return this.getLicenseTermsId(licenseTerms);
            case 37:
              licenseTermsIds = _context14.sent;
              return _context14.abrupt("return", {
                txHash: txHash,
                licenseTermsIds: licenseTermsIds
              });
            case 41:
              return _context14.abrupt("return", {
                txHash: txHash
              });
            case 42:
              _context14.next = 47;
              break;
            case 44:
              _context14.prev = 44;
              _context14.t0 = _context14["catch"](0);
              handleError(_context14.t0, "Failed to register PIL terms and attach");
            case 47:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this, [[0, 44]]);
      }));
      function registerPilTermsAndAttach(_x15) {
        return _registerPilTermsAndAttach.apply(this, arguments);
      }
      return registerPilTermsAndAttach;
    }()
    /**
     *  Mint an NFT from a collection and register it as a derivative IP using license tokens
     * Requires caller to have the minter role or the SPG NFT to allow public minting. Caller must own the license tokens and have approved DerivativeWorkflows to transfer them.
     * @param request - The request object that contains all data needed to mint and register ip and make derivative with license tokens.
     *   @param request.spgNftContract The address of the NFT collection.
     *   @param {Array} request.licenseTokenIds The IDs of the license tokens to be burned for linking the IP to parent IPs.
     *   @param request.allowDuplicates Set to true to allow minting an NFT with a duplicate metadata hash.
     *   @param request.maxRts The maximum number of royalty tokens that can be distributed to the external royalty policies (max: 100,000,000).
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.recipient - [Optional] The address to receive the minted NFT,default value is your wallet address.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, or if waitForTransaction is true, includes IP ID and Token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(request) {
        var _this5 = this;
        var _request$txOptions20, licenseTokenIds, _object6, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.prev = 0;
              _context16.next = 3;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 3:
              licenseTokenIds = _context16.sent;
              _object6 = {
                spgNftContract: getAddress$1(request.spgNftContract, "request.spgNftContract"),
                recipient: request.recipient && getAddress$1(request.recipient, "request.recipient") || this.walletAddress,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                licenseTokenIds: licenseTokenIds,
                royaltyContext: zeroAddress,
                maxRts: Number(request.maxRts),
                allowDuplicates: request.allowDuplicates
              };
              this.validateMaxRts(_object6.maxRts);
              encodedTxData = this.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode(_object6);
              if (!((_request$txOptions20 = request.txOptions) !== null && _request$txOptions20 !== void 0 && _request$txOptions20.encodedTxDataOnly)) {
                _context16.next = 9;
                break;
              }
              return _context16.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 9:
              contractCall = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                  return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                    while (1) switch (_context15.prev = _context15.next) {
                      case 0:
                        return _context15.abrupt("return", _this5.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_object6));
                      case 1:
                      case "end":
                        return _context15.stop();
                    }
                  }, _callee15);
                }));
                return function contractCall() {
                  return _ref2.apply(this, arguments);
                };
              }();
              return _context16.abrupt("return", this.commonRegistrationHandler({
                wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                  // need to disable multicall to avoid needing to transfer the license
                  // token to the multicall contract.
                  useMulticallWhenPossible: false
                }),
                sender: this.walletAddress,
                spgNftContract: _object6.spgNftContract,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 13:
              _context16.prev = 13;
              _context16.t0 = _context16["catch"](0);
              handleError(_context16.t0, "Failed to mint and register IP and make derivative with license tokens");
            case 16:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[0, 13]]);
      }));
      function mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_x16) {
        return _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * Register the given NFT as a derivative IP using license tokens.
     * @param request - The request object that contains all data needed to register ip and make derivative with license tokens.
     *   @param request.nftContract The address of the NFT collection.
     *   @param {Array} request.licenseTokenIds The IDs of the license tokens to be burned for linking the IP to parent IPs.
     *   @param request.tokenId The ID of the NFT.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, or if waitForTransaction is true, includes IP ID, Token ID.
     */
    )
  }, {
    key: "registerIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _registerIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(request) {
        var _request$txOptions21, tokenId, ipIdAddress, isRegistered, licenseTokenIds, calculatedDeadline, _yield$getPermissionS5, signature, _object7, _request$txOptions22, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context17.next = 4;
              return this.getIpIdAddress(request.nftContract, tokenId);
            case 4:
              ipIdAddress = _context17.sent;
              _context17.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context17.sent;
              if (!isRegistered) {
                _context17.next = 10;
                break;
              }
              throw new Error("The NFT with id ".concat(tokenId, " is already registered as IP."));
            case 10:
              _context17.next = 12;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 12:
              licenseTokenIds = _context17.sent;
              _context17.next = 15;
              return this.getCalculatedDeadline(request.deadline);
            case 15:
              calculatedDeadline = _context17.sent;
              _context17.next = 18;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.derivativeWorkflowsClient.address, "derivativeWorkflowsClient"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }, {
                  ipId: ipIdAddress,
                  signer: this.derivativeWorkflowsClient.address,
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleClient"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "registerDerivativeWithLicenseTokens")
                }]
              });
            case 18:
              _yield$getPermissionS5 = _context17.sent;
              signature = _yield$getPermissionS5.signature;
              _object7 = _objectSpread2(_objectSpread2({}, request), {}, {
                tokenId: tokenId,
                licenseTokenIds: licenseTokenIds,
                royaltyContext: zeroAddress,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigMetadataAndRegister: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: signature
                },
                maxRts: Number(request.maxRts)
              });
              this.validateMaxRts(_object7.maxRts);
              if (!((_request$txOptions21 = request.txOptions) !== null && _request$txOptions21 !== void 0 && _request$txOptions21.encodedTxDataOnly)) {
                _context17.next = 26;
                break;
              }
              return _context17.abrupt("return", {
                encodedTxData: this.derivativeWorkflowsClient.registerIpAndMakeDerivativeWithLicenseTokensEncode(_object7)
              });
            case 26:
              _context17.next = 28;
              return this.derivativeWorkflowsClient.registerIpAndMakeDerivativeWithLicenseTokens(_object7);
            case 28:
              txHash = _context17.sent;
              if (!((_request$txOptions22 = request.txOptions) !== null && _request$txOptions22 !== void 0 && _request$txOptions22.waitForTransaction)) {
                _context17.next = 35;
                break;
              }
              _context17.next = 32;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 32:
              receipt = _context17.sent;
              log = this.getIpIdAndTokenIdsFromEvent(receipt)[0];
              return _context17.abrupt("return", _objectSpread2({
                txHash: txHash
              }, log));
            case 35:
              return _context17.abrupt("return", {
                txHash: txHash
              });
            case 36:
              _context17.next = 41;
              break;
            case 38:
              _context17.prev = 38;
              _context17.t0 = _context17["catch"](0);
              handleError(_context17.t0, "Failed to register IP and make derivative with license tokens");
            case 41:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this, [[0, 38]]);
      }));
      function registerIpAndMakeDerivativeWithLicenseTokens(_x17) {
        return _registerIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * Register the given NFT and attach license terms and distribute royalty tokens. In order to successfully distribute royalty tokens, the first license terms attached to the IP must be
     * a commercial license.
     * @param request - The request object that contains all data needed to register ip and attach license terms and distribute royalty tokens.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param {Array} request.licenseTermsData The PIL terms and licensing configuration data to be attached to the IP.
     *     @param {Object} request.licenseTermsData.terms The PIL terms to be used for the licensing.
     *       @param request.licenseTermsData.terms.transferable Indicates whether the license is transferable or not.
     *       @param request.licenseTermsData.terms.royaltyPolicy The address of the royalty policy contract which required to StoryProtocol in advance.
     *       @param request.licenseTermsData.terms.mintingFee The fee to be paid when minting a license.
     *       @param request.licenseTermsData.terms.expiration The expiration period of the license.
     *       @param request.licenseTermsData.terms.commercialUse Indicates whether the work can be used commercially or not, Commercial use is required to deploy a royalty vault.
     *       @param request.licenseTermsData.terms.commercialAttribution Whether attribution is required when reproducing the work commercially or not.
     *       @param request.licenseTermsData.terms.commercializerChecker Commercializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
     *       @param request.licenseTermsData.terms.commercializerCheckerData The data to be passed to the commercializer checker contract.
     *       @param request.licenseTermsData.terms.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *       @param request.licenseTermsData.terms.commercialRevCeiling The maximum revenue that can be generated from the commercial use of the work.
     *       @param request.licenseTermsData.terms.derivativesAllowed Indicates whether the licensee can create derivatives of his work or not.
     *       @param request.licenseTermsData.terms.derivativesAttribution Indicates whether attribution is required for derivatives of the work or not.
     *       @param request.licenseTermsData.terms.derivativesApproval Indicates whether the licensor must approve derivatives of the work before they can be linked to the licensor IP ID or not.
     *       @param request.licenseTermsData.terms.derivativesReciprocal Indicates whether the licensee must license derivatives of the work under the same terms or not.
     *       @param request.licenseTermsData.terms.derivativeRevCeiling The maximum revenue that can be generated from the derivative use of the work.
     *       @param request.licenseTermsData.terms.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *       @param request.licenseTermsData.terms.uri The URI of the license terms, which can be used to fetch the offchain license terms.
     *     @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *       @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *       @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *       @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *       @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *       @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *       @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *       @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *       If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *       @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *  @param {Array} request.royaltyShares Authors of the IP and their shares of the royalty tokens.
     *    @param request.royaltyShares.recipient The address of the recipient.
     *    @param request.royaltyShares.percentage The percentage of the royalty share, 10 represents 10%.
     *  @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *  @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property, without encodedTxData option.
     * @returns A Promise that resolves to a transaction hashes, IP ID, IP royalty vault and an array containing the license terms ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     * @emits IpRoyaltyVaultDeployed (ipId, ipRoyaltyVault)
     */
    )
  }, {
    key: "registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(request) {
        var _request$txOptions23, _this$getRoyaltyShare, royaltyShares, totalAmount, _yield$this$validateL4, licenseTerms, licenseTermsData, calculatedDeadline, ipIdAddress, isRegistered, _yield$getPermissionS6, signature, registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash, txReceipt, ipId, licenseTermsIds, ipRoyaltyVault, distributeRoyaltyTokensTxHash;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.prev = 0;
              _this$getRoyaltyShare = this.getRoyaltyShares(request.royaltyShares), royaltyShares = _this$getRoyaltyShare.royaltyShares, totalAmount = _this$getRoyaltyShare.totalAmount;
              _context18.next = 4;
              return this.validateLicenseTermsData(request.licenseTermsData);
            case 4:
              _yield$this$validateL4 = _context18.sent;
              licenseTerms = _yield$this$validateL4.licenseTerms;
              licenseTermsData = _yield$this$validateL4.licenseTermsData;
              _context18.next = 9;
              return this.getCalculatedDeadline(request.deadline);
            case 9:
              calculatedDeadline = _context18.sent;
              _context18.next = 12;
              return this.getIpIdAddress(getAddress$1(request.nftContract, "request.nftContract"), request.tokenId);
            case 12:
              ipIdAddress = _context18.sent;
              _context18.next = 15;
              return this.isRegistered(ipIdAddress);
            case 15:
              isRegistered = _context18.sent;
              if (!isRegistered) {
                _context18.next = 18;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 18:
              _context18.next = 20;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.royaltyTokenDistributionWorkflowsClient.address, "royaltyTokenDistributionWorkflowsClient"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }, {
                  ipId: ipIdAddress,
                  signer: this.royaltyTokenDistributionWorkflowsClient.address,
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleClient"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
                }, {
                  ipId: ipIdAddress,
                  signer: this.royaltyTokenDistributionWorkflowsClient.address,
                  to: this.licensingModuleClient.address,
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
                }]
              });
            case 20:
              _yield$getPermissionS6 = _context18.sent;
              signature = _yield$getPermissionS6.signature;
              _context18.next = 24;
              return this.royaltyTokenDistributionWorkflowsClient.registerIpAndAttachPilTermsAndDeployRoyaltyVault({
                nftContract: request.nftContract,
                tokenId: BigInt(request.tokenId),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                licenseTermsData: licenseTermsData,
                sigMetadataAndAttachAndConfig: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: signature
                }
              });
            case 24:
              registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash = _context18.sent;
              _context18.next = 27;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash
              }));
            case 27:
              txReceipt = _context18.sent;
              ipId = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0].ipId;
              _context18.next = 31;
              return this.getLicenseTermsId(licenseTerms);
            case 31:
              licenseTermsIds = _context18.sent;
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(txReceipt)[0].ipRoyaltyVault;
              _context18.next = 35;
              return this.distributeRoyaltyTokens({
                ipId: ipId,
                deadline: calculatedDeadline,
                ipRoyaltyVault: ipRoyaltyVault,
                royaltyShares: royaltyShares,
                totalAmount: totalAmount,
                txOptions: request.txOptions
              });
            case 35:
              distributeRoyaltyTokensTxHash = _context18.sent;
              if (!((_request$txOptions23 = request.txOptions) !== null && _request$txOptions23 !== void 0 && _request$txOptions23.waitForTransaction)) {
                _context18.next = 39;
                break;
              }
              _context18.next = 39;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: distributeRoyaltyTokensTxHash
              }));
            case 39:
              return _context18.abrupt("return", {
                registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash: registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash,
                distributeRoyaltyTokensTxHash: distributeRoyaltyTokensTxHash,
                ipId: ipId,
                licenseTermsIds: licenseTermsIds,
                ipRoyaltyVault: ipRoyaltyVault
              });
            case 42:
              _context18.prev = 42;
              _context18.t0 = _context18["catch"](0);
              handleError(_context18.t0, "Failed to register IP and attach license terms and distribute royalty tokens");
            case 45:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this, [[0, 42]]);
      }));
      function registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens(_x18) {
        return _registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Register the given NFT as a derivative IP and attach license terms and distribute royalty tokens.  In order to successfully distribute royalty tokens, the license terms attached to the IP must be
     * a commercial license.
     * @param request - The request object that contains all data needed to register derivative IP and distribute royalty tokens.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param {Object} request.derivData The derivative data to be used for registerDerivative.
     *     @param {Array} request.derivData.parentIpIds The IDs of the parent IPs to link the registered derivative IP.
     *     @param request.derivData.licenseTemplate [Optional] The address of the license template to be used for the linking, default value is Programmable IP License.
     *     @param {Array} request.derivData.licenseTermsIds The IDs of the license terms to be used for the linking.
     *     @param request.derivData.maxMintingFee The maximum minting fee that the caller is willing to pay. if set to 0 then no limit.
     *     @param request.derivData.maxRts The maximum number of royalty tokens that can be distributed to the external royalty policies (max: 100,000,000).
     *     @param request.derivData.maxRevenueShare The maximum revenue share percentage allowed for minting the License Tokens. Must be between 0 and 100,000,000 (where 100,000,000 represents 100%).
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param {Array} request.royaltyShares Authors of the IP and their shares of the royalty tokens.
     *      @param request.royaltyShares.recipient The address of the recipient.
     *     @param request.royaltyShares.percentage The percentage of the royalty share, 10 represents 10%.
     *   @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property, without encodedTxData option.
     * @returns A Promise that resolves to a transaction hashes, IP ID and IP royalty vault, token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     * @emits IpRoyaltyVaultDeployed (ipId, ipRoyaltyVault)
     */
    )
  }, {
    key: "registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(request) {
        var _this6 = this;
        var _request$txOptions24, calculatedDeadline, ipIdAddress, _yield$getPermissionS7, signature, derivData, _object8, _this$getRoyaltyShare2, royaltyShares, totalAmount, isRegistered, encodedTxData, contractCall, _yield$this$commonReg, txHash, ipId, tokenId, receipt, ipRoyaltyVault, distributeRoyaltyTokensTxHash;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.prev = 0;
              _context19.next = 3;
              return this.getCalculatedDeadline(request.deadline);
            case 3:
              calculatedDeadline = _context19.sent;
              _context19.next = 6;
              return this.getIpIdAddress(request.nftContract, request.tokenId);
            case 6:
              ipIdAddress = _context19.sent;
              _context19.next = 9;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.royaltyTokenDistributionWorkflowsClient.address, "royaltyTokenDistributionWorkflowsClient"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }, {
                  ipId: ipIdAddress,
                  signer: this.royaltyTokenDistributionWorkflowsClient.address,
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "registerDerivative")
                }]
              });
            case 9:
              _yield$getPermissionS7 = _context19.sent;
              signature = _yield$getPermissionS7.signature;
              _context19.next = 13;
              return this.validateDerivativeData(request.derivData);
            case 13:
              derivData = _context19.sent;
              _object8 = {
                nftContract: request.nftContract,
                tokenId: BigInt(request.tokenId),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                derivData: derivData,
                sigMetadataAndRegister: {
                  signer: this.walletAddress,
                  deadline: calculatedDeadline,
                  signature: signature
                }
              };
              _this$getRoyaltyShare2 = this.getRoyaltyShares(request.royaltyShares), royaltyShares = _this$getRoyaltyShare2.royaltyShares, totalAmount = _this$getRoyaltyShare2.totalAmount;
              _context19.next = 18;
              return this.isRegistered(ipIdAddress);
            case 18:
              isRegistered = _context19.sent;
              if (!isRegistered) {
                _context19.next = 21;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 21:
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode(_object8);
              contractCall = function contractCall() {
                return _this6.royaltyTokenDistributionWorkflowsClient.registerIpAndMakeDerivativeAndDeployRoyaltyVault(_object8);
              };
              _context19.next = 25;
              return this.commonRegistrationHandler({
                wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                  useMulticallWhenPossible: false
                }),
                sender: this.walletAddress,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                derivData: derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: _objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                  waitForTransaction: true
                })
              });
            case 25:
              _yield$this$commonReg = _context19.sent;
              txHash = _yield$this$commonReg.txHash;
              ipId = _yield$this$commonReg.ipId;
              tokenId = _yield$this$commonReg.tokenId;
              receipt = _yield$this$commonReg.receipt;
              if (!(tokenId === undefined || ipId === undefined)) {
                _context19.next = 32;
                break;
              }
              throw new Error("Failed to register derivative ip and deploy royalty vault");
            case 32:
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(receipt).filter(function (item) {
                return item.ipId === ipId;
              })[0].ipRoyaltyVault;
              _context19.next = 35;
              return this.distributeRoyaltyTokens({
                ipId: ipId,
                deadline: calculatedDeadline,
                ipRoyaltyVault: ipRoyaltyVault,
                royaltyShares: royaltyShares,
                totalAmount: totalAmount,
                txOptions: request.txOptions
              });
            case 35:
              distributeRoyaltyTokensTxHash = _context19.sent;
              if (!((_request$txOptions24 = request.txOptions) !== null && _request$txOptions24 !== void 0 && _request$txOptions24.waitForTransaction)) {
                _context19.next = 39;
                break;
              }
              _context19.next = 39;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: distributeRoyaltyTokensTxHash
              }));
            case 39:
              return _context19.abrupt("return", {
                registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash: txHash,
                distributeRoyaltyTokensTxHash: distributeRoyaltyTokensTxHash,
                ipId: ipId,
                tokenId: tokenId,
                ipRoyaltyVault: ipRoyaltyVault
              });
            case 42:
              _context19.prev = 42;
              _context19.t0 = _context19["catch"](0);
              handleError(_context19.t0, "Failed to register derivative IP and attach license terms and distribute royalty tokens");
            case 45:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this, [[0, 42]]);
      }));
      function registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens(_x19) {
        return _registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Mint an NFT and register the IP, attach PIL terms, and distribute royalty tokens.
     * @param request - The request object that contains all data needed to mint an NFT and register the IP, attach PIL terms, and distribute royalty tokens.
     *   @param request.spgNftContract The address of the SPG NFT contract.
     *   @param request.allowDuplicates Set to true to allow minting an NFT with a duplicate metadata hash.
     *   @param {Array} request.licenseTermsData The PIL terms and licensing configuration data to attach to the IP.
     *     @param {Object} request.licenseTermsData.terms The PIL terms to be attached.
     *       @param request.licenseTermsData.terms.transferable Indicates whether the license is transferable or not.
     *       @param request.licenseTermsData.terms.royaltyPolicy The address of the royalty policy contract which required to StoryProtocol in advance.
     *       @param request.licenseTermsData.terms.mintingFee The fee to be paid when minting a license.
     *       @param request.licenseTermsData.terms.expiration The expiration period of the license.
     *       @param request.licenseTermsData.terms.commercialUse Indicates whether the work can be used commercially or not, Commercial use is required to deploy a royalty vault.
     *       @param request.licenseTermsData.terms.commercialAttribution Whether attribution is required when reproducing the work commercially or not.
     *       @param request.licenseTermsData.terms.commercializerChecker Commercializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
     *       @param request.licenseTermsData.terms.commercializerCheckerData The data to be passed to the commercializer checker contract.
     *       @param request.licenseTermsData.terms.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *       @param request.licenseTermsData.terms.commercialRevCeiling The maximum revenue that can be generated from the commercial use of the work.
     *       @param request.licenseTermsData.terms.derivativesAllowed Indicates whether the licensee can create derivatives of his work or not.
     *       @param request.licenseTermsData.terms.derivativesAttribution Indicates whether attribution is required for derivatives of the work or not.
     *       @param request.licenseTermsData.terms.derivativesApproval Indicates whether the licensor must approve derivatives of the work before they can be linked to the licensor IP ID or not.
     *       @param request.licenseTermsData.terms.derivativesReciprocal Indicates whether the licensee must license derivatives of the work under the same terms or not.
     *       @param request.licenseTermsData.terms.derivativeRevCeiling The maximum revenue that can be generated from the derivative use of the work.
     *       @param request.licenseTermsData.terms.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *       @param request.licenseTermsData.terms.uri The URI of the license terms, which can be used to fetch the offchain license terms.
     *     @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *       @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *       @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *       @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *       @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *       @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *       @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *       @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *       If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *       @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *  @param {Array} request.royaltyShares Authors of the IP and their shares of the royalty tokens.
     *    @param request.royaltyShares.recipient The address of the recipient.
     *    @param request.royaltyShares.percentage The percentage of the royalty share, 10 represents 10%.
     *   @param request.recipient - [Optional] The address to receive the minted NFT,default value is your wallet address.
     *  @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property, without encodedTxData option.
     * @returns A Promise that resolves to a transaction hash, IP ID, IP royalty vault, Token ID, and an array containing the license terms ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     * @emits IpRoyaltyVaultDeployed (ipId, ipRoyaltyVault)
     */
    )
  }, {
    key: "mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(request) {
        var _this7 = this;
        var _yield$this$validateL5, licenseTerms, licenseTermsData, _this$getRoyaltyShare3, royaltyShares, _object9, encodedTxData, contractCall, _yield$this$commonReg2, txHash, ipId, tokenId, receipt, licenseTermsIds, ipRoyaltyVault;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.prev = 0;
              _context20.next = 3;
              return this.validateLicenseTermsData(request.licenseTermsData);
            case 3:
              _yield$this$validateL5 = _context20.sent;
              licenseTerms = _yield$this$validateL5.licenseTerms;
              licenseTermsData = _yield$this$validateL5.licenseTermsData;
              _this$getRoyaltyShare3 = this.getRoyaltyShares(request.royaltyShares), royaltyShares = _this$getRoyaltyShare3.royaltyShares;
              _object9 = {
                spgNftContract: getAddress$1(request.spgNftContract, "request.spgNftContract"),
                recipient: request.recipient && getAddress$1(request.recipient, "request.recipient") || this.walletAddress,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                licenseTermsData: licenseTermsData,
                royaltyShares: royaltyShares,
                allowDuplicates: request.allowDuplicates
              };
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode(_object9);
              contractCall = function contractCall() {
                return _this7.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_object9);
              };
              _context20.next = 12;
              return this.commonRegistrationHandler({
                wipOptions: request.wipOptions,
                sender: this.walletAddress,
                spgNftContract: _object9.spgNftContract,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              });
            case 12:
              _yield$this$commonReg2 = _context20.sent;
              txHash = _yield$this$commonReg2.txHash;
              ipId = _yield$this$commonReg2.ipId;
              tokenId = _yield$this$commonReg2.tokenId;
              receipt = _yield$this$commonReg2.receipt;
              if (receipt) {
                _context20.next = 19;
                break;
              }
              return _context20.abrupt("return", {
                txHash: txHash
              });
            case 19:
              _context20.next = 21;
              return this.getLicenseTermsId(licenseTerms);
            case 21:
              licenseTermsIds = _context20.sent;
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(receipt)[0].ipRoyaltyVault;
              return _context20.abrupt("return", {
                txHash: txHash,
                ipId: ipId,
                licenseTermsIds: licenseTermsIds,
                ipRoyaltyVault: ipRoyaltyVault,
                tokenId: tokenId
              });
            case 26:
              _context20.prev = 26;
              _context20.t0 = _context20["catch"](0);
              handleError(_context20.t0, "Failed to mint and register IP and attach PIL terms and distribute royalty tokens");
            case 29:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this, [[0, 26]]);
      }));
      function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_x20) {
        return _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Mint an NFT and register the IP, make a derivative, and distribute royalty tokens.
     * @param request - The request object that contains all data needed to mint an NFT and register the IP, make a derivative, and distribute royalty tokens.
     *   @param request.spgNftContract The address of the SPG NFT collection.
     *   @param request.derivData The derivative data to be used for registerDerivative.
     *     @param  {Array} request.derivData.parentIpIds The IDs of the parent IPs to link the registered derivative IP.
     *     @param request.derivData.licenseTemplate [Optional] The address of the license template to be used for the linking, default value is Programmable IP License.
     *     @param {Array} request.derivData.licenseTermsIds The IDs of the license terms to be used for the linking.
     *     @param request.derivData.maxMintingFee The maximum minting fee that the caller is willing to pay. if set to 0 then no limit.
     *     @param request.derivData.maxRts The maximum number of royalty tokens that can be distributed to the external royalty policies (max: 100,000,000).
     *     @param request.derivData.maxRevenueShare The maximum revenue share percentage allowed for minting the License Tokens. Must be between 0 and 100,000,000 (where 100,000,000 represents 100%).
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param {Array} request.royaltyShares Authors of the IP and their shares of the royalty tokens.
     *     @param request.royaltyShares.recipient The address of the recipient.
     *     @param request.royaltyShares.percentage The percentage of the royalty share, 10 represents 10%.
     *  @param request.allowDuplicates Set to true to allow minting an NFT with a duplicate metadata hash.
     *  @param request.recipient - [Optional] The address to receive the minted NFT,default value is your wallet address.
     *  @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property, without encodedTxData option..
     * @returns A Promise that resolves to a transaction hash, IP ID and token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(request) {
        var _this8 = this;
        var nftRecipient, _this$getRoyaltyShare4, royaltyShares, derivData, _object10, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _context21.prev = 0;
              nftRecipient = request.recipient && getAddress$1(request.recipient, "request.recipient") || this.walletAddress;
              _this$getRoyaltyShare4 = this.getRoyaltyShares(request.royaltyShares), royaltyShares = _this$getRoyaltyShare4.royaltyShares;
              _context21.next = 5;
              return this.validateDerivativeData(request.derivData);
            case 5:
              derivData = _context21.sent;
              _object10 = {
                spgNftContract: getAddress$1(request.spgNftContract, "request.spgNftContract"),
                recipient: nftRecipient,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                derivData: derivData,
                royaltyShares: royaltyShares,
                allowDuplicates: request.allowDuplicates
              };
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode(_object10);
              contractCall = function contractCall() {
                return _this8.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_object10);
              };
              return _context21.abrupt("return", this.commonRegistrationHandler({
                spgNftContract: _object10.spgNftContract,
                wipOptions: request.wipOptions,
                sender: this.walletAddress,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                derivData: derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 12:
              _context21.prev = 12;
              _context21.t0 = _context21["catch"](0);
              handleError(_context21.t0, "Failed to mint and register IP and make derivative and distribute royalty tokens");
            case 15:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this, [[0, 12]]);
      }));
      function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_x21) {
        return _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens;
    }())
  }, {
    key: "getRoyaltyShares",
    value: function getRoyaltyShares(royaltyShares) {
      var actualTotal = 0;
      var sum = 0;
      var shares = royaltyShares.map(function (share) {
        if (share.percentage <= 0) {
          throw new Error("The percentage of the royalty shares must be greater than 0.");
        }
        if (share.percentage > 100) {
          throw new Error("The percentage of the royalty shares must be less than or equal to 100.");
        }
        sum += share.percentage;
        if (sum > 100) {
          throw new Error("The sum of the royalty shares cannot exceeds 100.");
        }
        var value = share.percentage / 100 * royaltySharesTotalSupply;
        actualTotal += value;
        return _objectSpread2(_objectSpread2({}, share), {}, {
          percentage: value
        });
      });
      return {
        royaltyShares: shares,
        totalAmount: actualTotal
      };
    }
  }, {
    key: "distributeRoyaltyTokens",
    value: function () {
      var _distributeRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(request) {
        var _request$txOptions25;
        var ipId, deadline, ipRoyaltyVault, totalAmount, ipRoyaltyVaultImpl, balance, ipAccount, _yield$ipAccount$stat3, state, _yield$getSignature2, signatureApproveRoyaltyTokens, txHash;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              ipId = request.ipId, deadline = request.deadline, ipRoyaltyVault = request.ipRoyaltyVault, totalAmount = request.totalAmount;
              ipRoyaltyVaultImpl = new IpRoyaltyVaultImplReadOnlyClient(this.rpcClient, ipRoyaltyVault);
              _context22.next = 4;
              return ipRoyaltyVaultImpl.balanceOf({
                account: ipId
              });
            case 4:
              balance = _context22.sent;
              if (!(BigInt(balance) < BigInt(totalAmount))) {
                _context22.next = 7;
                break;
              }
              throw new Error("The balance of the IP account in the IP Royalty Vault is insufficient to distribute the royalty tokens.");
            case 7:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(ipId, "arg.childIpId"));
              _context22.next = 10;
              return ipAccount.state();
            case 10:
              _yield$ipAccount$stat3 = _context22.sent;
              state = _yield$ipAccount$stat3.result;
              _context22.next = 14;
              return getSignature({
                verifyingContract: ipId,
                deadline: deadline,
                state: state,
                wallet: this.wallet,
                chainId: chain[this.chainId],
                to: ipRoyaltyVault,
                encodeData: encodeFunctionData({
                  abi: ipRoyaltyVaultImplAbi,
                  functionName: "approve",
                  args: [this.royaltyTokenDistributionWorkflowsClient.address, BigInt(totalAmount)]
                })
              });
            case 14:
              _yield$getSignature2 = _context22.sent;
              signatureApproveRoyaltyTokens = _yield$getSignature2.signature;
              _context22.next = 18;
              return this.royaltyTokenDistributionWorkflowsClient.distributeRoyaltyTokens({
                ipId: ipId,
                royaltyShares: request.royaltyShares,
                sigApproveRoyaltyTokens: {
                  signer: this.wallet.account.address,
                  deadline: deadline,
                  signature: signatureApproveRoyaltyTokens
                }
              });
            case 18:
              txHash = _context22.sent;
              if (!((_request$txOptions25 = request.txOptions) !== null && _request$txOptions25 !== void 0 && _request$txOptions25.waitForTransaction)) {
                _context22.next = 23;
                break;
              }
              _context22.next = 22;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 22:
              return _context22.abrupt("return", txHash);
            case 23:
              return _context22.abrupt("return", txHash);
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function distributeRoyaltyTokens(_x22) {
        return _distributeRoyaltyTokens.apply(this, arguments);
      }
      return distributeRoyaltyTokens;
    }()
  }, {
    key: "getIpIdAddress",
    value: function () {
      var _getIpIdAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(nftContract, tokenId) {
        var ipId;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return this.ipAssetRegistryClient.ipId({
                chainId: BigInt(chain[this.chainId]),
                tokenContract: getAddress$1(nftContract, "nftContract"),
                tokenId: BigInt(tokenId)
              });
            case 2:
              ipId = _context23.sent;
              return _context23.abrupt("return", ipId);
            case 4:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function getIpIdAddress(_x23, _x24) {
        return _getIpIdAddress.apply(this, arguments);
      }
      return getIpIdAddress;
    }()
  }, {
    key: "isRegistered",
    value: function () {
      var _isRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(ipId) {
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(ipId, "ipId")
              });
            case 2:
              return _context24.abrupt("return", _context24.sent);
            case 3:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function isRegistered(_x25) {
        return _isRegistered.apply(this, arguments);
      }
      return isRegistered;
    }()
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(licenseTerms) {
        var licenseTermsIds, _iterator5, _step5, licenseTerm, licenseRes;
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              licenseTermsIds = [];
              _iterator5 = _createForOfIteratorHelper(licenseTerms);
              _context25.prev = 2;
              _iterator5.s();
            case 4:
              if ((_step5 = _iterator5.n()).done) {
                _context25.next = 12;
                break;
              }
              licenseTerm = _step5.value;
              _context25.next = 8;
              return this.licenseTemplateClient.getLicenseTermsId({
                terms: licenseTerm
              });
            case 8:
              licenseRes = _context25.sent;
              licenseTermsIds.push(licenseRes.selectedLicenseTermsId);
            case 10:
              _context25.next = 4;
              break;
            case 12:
              _context25.next = 17;
              break;
            case 14:
              _context25.prev = 14;
              _context25.t0 = _context25["catch"](2);
              _iterator5.e(_context25.t0);
            case 17:
              _context25.prev = 17;
              _iterator5.f();
              return _context25.finish(17);
            case 20:
              return _context25.abrupt("return", licenseTermsIds);
            case 21:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this, [[2, 14, 17, 20]]);
      }));
      function getLicenseTermsId(_x26) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }, {
    key: "validateLicenseTokenIds",
    value: function () {
      var _validateLicenseTokenIds = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(licenseTokenIds) {
        var newLicenseTokenIds, _iterator6, _step6, licenseTokenId, tokenOwnerAddress;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              if (!(licenseTokenIds.length === 0)) {
                _context26.next = 2;
                break;
              }
              throw new Error("License token IDs must be provided.");
            case 2:
              newLicenseTokenIds = licenseTokenIds.map(function (id) {
                return BigInt(id);
              });
              _iterator6 = _createForOfIteratorHelper(newLicenseTokenIds);
              _context26.prev = 4;
              _iterator6.s();
            case 6:
              if ((_step6 = _iterator6.n()).done) {
                _context26.next = 15;
                break;
              }
              licenseTokenId = _step6.value;
              _context26.next = 10;
              return this.licenseTokenReadOnlyClient.ownerOf({
                tokenId: licenseTokenId
              });
            case 10:
              tokenOwnerAddress = _context26.sent;
              if (tokenOwnerAddress) {
                _context26.next = 13;
                break;
              }
              throw new Error("License token id ".concat(licenseTokenId, " must be owned by the caller."));
            case 13:
              _context26.next = 6;
              break;
            case 15:
              _context26.next = 20;
              break;
            case 17:
              _context26.prev = 17;
              _context26.t0 = _context26["catch"](4);
              _iterator6.e(_context26.t0);
            case 20:
              _context26.prev = 20;
              _iterator6.f();
              return _context26.finish(20);
            case 23:
              return _context26.abrupt("return", newLicenseTokenIds);
            case 24:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this, [[4, 17, 20, 23]]);
      }));
      function validateLicenseTokenIds(_x27) {
        return _validateLicenseTokenIds.apply(this, arguments);
      }
      return validateLicenseTokenIds;
    }()
  }, {
    key: "getIpIdAndTokenIdsFromEvent",
    value: function getIpIdAndTokenIdsFromEvent(txReceipt, key) {
      var IPRegisteredLog = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt);
      return IPRegisteredLog.map(function (log) {
        var baseResult = {
          ipId: log.ipId,
          tokenId: log.tokenId
        };
        if (key) {
          return _objectSpread2(_objectSpread2({}, baseResult), {}, _defineProperty({}, key, log.tokenContract));
        }
        return baseResult;
      });
    }
  }, {
    key: "getCalculatedDeadline",
    value: function () {
      var _getCalculatedDeadline = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(requestDeadline) {
        var blockTimestamp;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this.rpcClient.getBlock();
            case 2:
              blockTimestamp = _context27.sent.timestamp;
              return _context27.abrupt("return", getDeadline(blockTimestamp, requestDeadline));
            case 4:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function getCalculatedDeadline(_x28) {
        return _getCalculatedDeadline.apply(this, arguments);
      }
      return getCalculatedDeadline;
    }()
  }, {
    key: "validateMaxRts",
    value: function validateMaxRts(maxRts) {
      if (isNaN(maxRts)) {
        throw new Error("The maxRts must be a number.");
      }
      if (maxRts < 0 || maxRts > MAX_ROYALTY_TOKEN) {
        throw new Error("The maxRts must be greater than 0 and less than ".concat(MAX_ROYALTY_TOKEN, "."));
      }
    }
  }, {
    key: "validateDerivativeData",
    value: function () {
      var _validateDerivativeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(derivativeData) {
        var internalDerivativeData, i, parentId, isParentIpRegistered, isAttachedLicenseTerms, _yield$this$licenseRe, royaltyPercent;
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              internalDerivativeData = {
                parentIpIds: derivativeData.parentIpIds,
                licenseTermsIds: derivativeData.licenseTermsIds.map(function (id) {
                  return BigInt(id);
                }),
                licenseTemplate: derivativeData.licenseTemplate && getAddress$1(derivativeData.licenseTemplate, "derivativeData.licenseTemplate") || this.licenseTemplateClient.address,
                royaltyContext: zeroAddress,
                maxMintingFee: BigInt(derivativeData.maxMintingFee),
                maxRts: Number(derivativeData.maxRts),
                maxRevenueShare: getRevenueShare(derivativeData.maxRevenueShare)
              };
              if (!(internalDerivativeData.parentIpIds.length === 0)) {
                _context28.next = 3;
                break;
              }
              throw new Error("The parent IP IDs must be provided.");
            case 3:
              if (!(internalDerivativeData.licenseTermsIds.length === 0)) {
                _context28.next = 5;
                break;
              }
              throw new Error("The license terms IDs must be provided.");
            case 5:
              if (!(internalDerivativeData.parentIpIds.length !== internalDerivativeData.licenseTermsIds.length)) {
                _context28.next = 7;
                break;
              }
              throw new Error("The number of parent IP IDs must match the number of license terms IDs.");
            case 7:
              if (!(internalDerivativeData.maxMintingFee < 0)) {
                _context28.next = 9;
                break;
              }
              throw new Error("The maxMintingFee must be greater than 0.");
            case 9:
              this.validateMaxRts(internalDerivativeData.maxRts);
              i = 0;
            case 11:
              if (!(i < internalDerivativeData.parentIpIds.length)) {
                _context28.next = 32;
                break;
              }
              parentId = internalDerivativeData.parentIpIds[i];
              _context28.next = 15;
              return this.isRegistered(parentId);
            case 15:
              isParentIpRegistered = _context28.sent;
              if (isParentIpRegistered) {
                _context28.next = 18;
                break;
              }
              throw new Error("The parent IP with id ".concat(parentId, " is not registered."));
            case 18:
              _context28.next = 20;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: parentId,
                licenseTemplate: internalDerivativeData.licenseTemplate,
                licenseTermsId: internalDerivativeData.licenseTermsIds[i]
              });
            case 20:
              isAttachedLicenseTerms = _context28.sent;
              if (isAttachedLicenseTerms) {
                _context28.next = 23;
                break;
              }
              throw new Error("License terms id ".concat(internalDerivativeData.licenseTermsIds[i], " must be attached to the parent ipId ").concat(internalDerivativeData.parentIpIds[i], " before registering derivative."));
            case 23:
              _context28.next = 25;
              return this.licenseRegistryReadOnlyClient.getRoyaltyPercent({
                ipId: parentId,
                licenseTemplate: internalDerivativeData.licenseTemplate,
                licenseTermsId: internalDerivativeData.licenseTermsIds[i]
              });
            case 25:
              _yield$this$licenseRe = _context28.sent;
              royaltyPercent = _yield$this$licenseRe.royaltyPercent;
              if (!(internalDerivativeData.maxRevenueShare !== 0 && royaltyPercent > internalDerivativeData.maxRevenueShare)) {
                _context28.next = 29;
                break;
              }
              throw new Error("The royalty percent for the parent IP with id ".concat(parentId, " is greater than the maximum revenue share ").concat(internalDerivativeData.maxRevenueShare, "."));
            case 29:
              i++;
              _context28.next = 11;
              break;
            case 32:
              return _context28.abrupt("return", internalDerivativeData);
            case 33:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
      function validateDerivativeData(_x29) {
        return _validateDerivativeData.apply(this, arguments);
      }
      return validateDerivativeData;
    }()
  }, {
    key: "validateLicenseTermsData",
    value: function () {
      var _validateLicenseTermsData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(licenseTermsData) {
        var licenseTerms, processedLicenseTermsData, i, licenseTerm, licensingConfig;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              licenseTerms = [];
              processedLicenseTermsData = [];
              i = 0;
            case 3:
              if (!(i < licenseTermsData.length)) {
                _context29.next = 15;
                break;
              }
              _context29.next = 6;
              return validateLicenseTerms(licenseTermsData[i].terms, this.rpcClient);
            case 6:
              licenseTerm = _context29.sent;
              licensingConfig = validateLicenseConfig(licenseTermsData[i].licensingConfig);
              if (!(licensingConfig.mintingFee > 0 && licenseTerm.royaltyPolicy === zeroAddress)) {
                _context29.next = 10;
                break;
              }
              throw new Error("A royalty policy must be provided when the minting fee is greater than 0.");
            case 10:
              licenseTerms.push(licenseTerm);
              processedLicenseTermsData.push({
                terms: licenseTerm,
                licensingConfig: licensingConfig
              });
            case 12:
              i++;
              _context29.next = 3;
              break;
            case 15:
              return _context29.abrupt("return", {
                licenseTerms: licenseTerms,
                licenseTermsData: processedLicenseTermsData
              });
            case 16:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));
      function validateLicenseTermsData(_x30) {
        return _validateLicenseTermsData.apply(this, arguments);
      }
      return validateLicenseTermsData;
    }()
  }, {
    key: "commonRegistrationHandler",
    value: function () {
      var _commonRegistrationHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(_ref3) {
        var sender, derivData, spgNftContract, spgSpenderAddress, txOptions, wipOptions, encodedTxs, contractCall, totalFees, wipSpenders, nftMintFee, totalDerivativeMintingFee, i, derivativeMintingFee, _yield$contractCallWi, txHash, receipt, _this$getIpIdAndToken, ipId, tokenId;
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              sender = _ref3.sender, derivData = _ref3.derivData, spgNftContract = _ref3.spgNftContract, spgSpenderAddress = _ref3.spgSpenderAddress, txOptions = _ref3.txOptions, wipOptions = _ref3.wipOptions, encodedTxs = _ref3.encodedTxs, contractCall = _ref3.contractCall;
              totalFees = 0n;
              wipSpenders = []; // get spg minting fee
              if (!spgNftContract) {
                _context30.next = 9;
                break;
              }
              _context30.next = 6;
              return calculateSPGWipMintFee(new SpgnftImplReadOnlyClient(this.rpcClient, spgNftContract));
            case 6:
              nftMintFee = _context30.sent;
              totalFees += nftMintFee;
              wipSpenders.push({
                address: spgNftContract,
                amount: nftMintFee
              });
            case 9:
              if (!derivData) {
                _context30.next = 22;
                break;
              }
              totalDerivativeMintingFee = 0n;
              i = 0;
            case 12:
              if (!(i < derivData.parentIpIds.length)) {
                _context30.next = 20;
                break;
              }
              _context30.next = 15;
              return calculateLicenseWipMintFee({
                multicall3Client: this.multicall3Client,
                licenseTemplateClient: this.licenseTemplateClient,
                licensingModuleClient: this.licensingModuleClient,
                parentIpId: derivData.parentIpIds[i],
                licenseTermsId: derivData.licenseTermsIds[i],
                receiver: sender,
                amount: 1n
              });
            case 15:
              derivativeMintingFee = _context30.sent;
              totalDerivativeMintingFee += derivativeMintingFee;
            case 17:
              i++;
              _context30.next = 12;
              break;
            case 20:
              totalFees += totalDerivativeMintingFee;
              if (totalDerivativeMintingFee > 0) {
                wipSpenders.push({
                  address: spgSpenderAddress,
                  amount: totalDerivativeMintingFee
                });
              }
            case 22:
              if (!(totalFees < 0)) {
                _context30.next = 24;
                break;
              }
              throw new Error("Total fees for registering derivative should never be negative: ".concat(totalFees));
            case 24:
              _context30.next = 26;
              return contractCallWithWipFees({
                totalFees: totalFees,
                wipOptions: wipOptions,
                multicall3Client: this.multicall3Client,
                rpcClient: this.rpcClient,
                wipClient: this.wipClient,
                wipSpenders: wipSpenders,
                contractCall: contractCall,
                sender: sender,
                wallet: this.wallet,
                txOptions: txOptions,
                encodedTxs: encodedTxs
              });
            case 26:
              _yield$contractCallWi = _context30.sent;
              txHash = _yield$contractCallWi.txHash;
              receipt = _yield$contractCallWi.receipt;
              if (!receipt) {
                _context30.next = 34;
                break;
              }
              _this$getIpIdAndToken = this.getIpIdAndTokenIdsFromEvent(receipt)[0], ipId = _this$getIpIdAndToken.ipId, tokenId = _this$getIpIdAndToken.tokenId;
              return _context30.abrupt("return", {
                txHash: txHash,
                ipId: ipId,
                tokenId: tokenId,
                receipt: receipt
              });
            case 34:
              return _context30.abrupt("return", {
                txHash: txHash
              });
            case 35:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));
      function commonRegistrationHandler(_x31) {
        return _commonRegistrationHandler.apply(this, arguments);
      }
      return commonRegistrationHandler;
    }()
  }]);
}();

var PermissionClient = /*#__PURE__*/function () {
  function PermissionClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, PermissionClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.accessControllerClient = new AccessControllerClient(this.rpcClient, this.wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(this.rpcClient, this.wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(this.rpcClient, this.wallet);
  }

  /**
   * Sets the permission for a specific function call
   * Each policy is represented as a mapping from an IP account address to a signer address to a recipient
   * address to a function selector to a permission level. The permission level can be 0 (ABSTAIN), 1 (ALLOW), or
   * 2 (DENY).
   * By default, all policies are set to 0 (ABSTAIN), which means that the permission is not set.
   * The owner of ipAccount by default has all permission.
   * address(0) => wildcard
   * bytes4(0) => wildcard
   * Specific permission overrides wildcard permission.
   * @param request - The request object containing necessary data to set `permission`.
   *   @param request.ipId The IP ID that grants the permission for `signer`.
   *   @param request.signer The address that can call `to` on behalf of the `ipAccount`.
   *   @param request.to The address that can be called by the `signer` (currently only modules can be `to`).
   *   @param request.permission The new permission level.
   *   @param request.func [Optional] The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to an object containing the transaction hash.
   * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
   */
  return _createClass(PermissionClient, [{
    key: "setPermission",
    value: (function () {
      var _setPermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, req, _request$txOptions2, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.checkIsRegistered(request.ipId);
            case 3:
              req = {
                ipAccount: request.ipId,
                signer: request.signer,
                to: request.to,
                func: request.func ? toFunctionSelector(request.func) : defaultFunctionSelector,
                permission: request.permission
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.accessControllerClient.setPermissionEncode(req)
              });
            case 8:
              _context.next = 10;
              return this.accessControllerClient.setPermission(req);
            case 10:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 17;
                break;
              }
              _context.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              return _context.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 17:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context.next = 23;
              break;
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to set permissions");
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 20]]);
      }));
      function setPermission(_x) {
        return _setPermission.apply(this, arguments);
      }
      return setPermission;
    }()
    /**
     * Specific permission overrides wildcard permission with signature.
     * @param request - The request object containing necessary data to set permissions.
     *   @param request.ipId The IP ID that grants the permission for `signer`
     *   @param request.signer The address that can call `to` on behalf of the `ipAccount`
     *   @param request.to The address that can be called by the `signer` (currently only modules can be `to`)
     *   @param request.permission The new permission level.
     *   @param request.func [Optional] The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
     *   @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
     */
    )
  }, {
    key: "createSetPermissionSignature",
    value: (function () {
      var _createSetPermissionSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, ipId, signer, to, txOptions, func, permission, deadline, ipAccountClient, data, _yield$ipAccountClien, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS, signature, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              ipId = request.ipId, signer = request.signer, to = request.to, txOptions = request.txOptions, func = request.func, permission = request.permission, deadline = request.deadline;
              _context2.next = 4;
              return this.checkIsRegistered(ipId);
            case 4:
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              data = encodeFunctionData({
                abi: accessControllerAbi,
                functionName: "setTransientPermission",
                args: [ipId, getAddress$1(signer, "request.signer"), getAddress$1(to, "request.to"), func ? toFunctionSelector(func) : defaultFunctionSelector, permission]
              });
              _context2.next = 8;
              return ipAccountClient.state();
            case 8:
              _yield$ipAccountClien = _context2.sent;
              state = _yield$ipAccountClien.result;
              _context2.next = 12;
              return this.rpcClient.getBlock();
            case 12:
              blockTimestamp = _context2.sent.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context2.next = 16;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                permissions: [{
                  ipId: ipId,
                  signer: signer,
                  to: to,
                  permission: permission,
                  func: func
                }],
                chainId: chain[this.chainId],
                wallet: this.wallet
              });
            case 16:
              _yield$getPermissionS = _context2.sent;
              signature = _yield$getPermissionS.signature;
              req = {
                to: getAddress$1(this.accessControllerClient.address, "accessControllerClientAddress"),
                value: BigInt(0),
                data: data,
                signer: signer,
                deadline: calculatedDeadline,
                signature: signature
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 23;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 23:
              _context2.next = 25;
              return ipAccountClient.executeWithSig(req);
            case 25:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 32;
                break;
              }
              _context2.next = 29;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 29:
              return _context2.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 32:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 33:
              _context2.next = 38;
              break;
            case 35:
              _context2.prev = 35;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to create set permission signature");
            case 38:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 35]]);
      }));
      function createSetPermissionSignature(_x2) {
        return _createSetPermissionSignature.apply(this, arguments);
      }
      return createSetPermissionSignature;
    }()
    /**
     * Sets permission to a signer for all functions across all modules.
     * @param request - The request object containing necessary data to set all permissions.
     *   @param request.ipId The IP ID that grants the permission for `signer`
     *   @param request.signer The address of the signer receiving the permissions.
     *   @param request.permission The new permission.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash
     * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
     */
    )
  }, {
    key: "setAllPermissions",
    value: (function () {
      var _setAllPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, req, _request$txOptions6, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.checkIsRegistered(request.ipId);
            case 3:
              req = {
                ipAccount: request.ipId,
                signer: request.signer,
                permission: request.permission
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 8;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.accessControllerClient.setAllPermissionsEncode(req)
              });
            case 8:
              _context3.next = 10;
              return this.accessControllerClient.setAllPermissions(req);
            case 10:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 17;
                break;
              }
              _context3.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              return _context3.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 17:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context3.next = 23;
              break;
            case 20:
              _context3.prev = 20;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to set all permissions");
            case 23:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 20]]);
      }));
      function setAllPermissions(_x3) {
        return _setAllPermissions.apply(this, arguments);
      }
      return setAllPermissions;
    }()
    /**
     * Sets a batch of permissions in a single transaction.
     * @param request - The request object containing necessary data to set all permissions.
     * @param {Array} request.permissions - An array of `Permission` structure, each representing the permission to be set.
     *   @param request.permissions[].ipId The IP ID that grants the permission for `signer`.
     *   @param request.permissions[].signer The address that can call `to` on behalf of the `ipAccount`.
     *   @param request.permissions[].to The address that can be called by the `signer` (currently only modules can be `to`).
     *   @param request.permissions[].permission The new permission level.
     *   @param request.permissions[].func [Optional] The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
     *   @param request.deadline [Optional] The deadline for the signature in milliseconds, default is 1000ms.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash
     * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
     */
    )
  }, {
    key: "setBatchPermissions",
    value: (function () {
      var _setBatchPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, permissions, txOptions, _iterator, _step, permission, req, _request$txOptions8, txHash;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              permissions = request.permissions, txOptions = request.txOptions;
              _iterator = _createForOfIteratorHelper(permissions);
              _context4.prev = 3;
              _iterator.s();
            case 5:
              if ((_step = _iterator.n()).done) {
                _context4.next = 11;
                break;
              }
              permission = _step.value;
              _context4.next = 9;
              return this.checkIsRegistered(permission.ipId);
            case 9:
              _context4.next = 5;
              break;
            case 11:
              _context4.next = 16;
              break;
            case 13:
              _context4.prev = 13;
              _context4.t0 = _context4["catch"](3);
              _iterator.e(_context4.t0);
            case 16:
              _context4.prev = 16;
              _iterator.f();
              return _context4.finish(16);
            case 19:
              req = {
                permissions: permissions.map(function (permission) {
                  return {
                    ipAccount: permission.ipId,
                    signer: permission.signer,
                    to: permission.to,
                    func: permission.func ? toFunctionSelector(permission.func) : defaultFunctionSelector,
                    permission: permission.permission
                  };
                })
              };
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 24;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.accessControllerClient.setBatchPermissionsEncode(req)
              });
            case 24:
              _context4.next = 26;
              return this.accessControllerClient.setBatchPermissions(req);
            case 26:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 33;
                break;
              }
              _context4.next = 30;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 30:
              return _context4.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 33:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 34:
              _context4.next = 39;
              break;
            case 36:
              _context4.prev = 36;
              _context4.t1 = _context4["catch"](0);
              handleError(_context4.t1, "Failed to set batch permissions");
            case 39:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 36], [3, 13, 16, 19]]);
      }));
      function setBatchPermissions(_x4) {
        return _setBatchPermissions.apply(this, arguments);
      }
      return setBatchPermissions;
    }()
    /**
     * Sets a batch of permissions in a single transaction with signature.
     * @param request - The request object containing necessary data to set permissions.
     *   @param request.ipId The IP ID that grants the permission for `signer`
     *   @param {Array} request.permissions - An array of `Permission` structure, each representing the permission to be set.
     *   @param request.permissions[].ipId The IP ID that grants the permission for `signer`.
     *   @param request.permissions[].signer The address that can call `to` on behalf of the `ipAccount`.
     *   @param request.permissions[].to The address that can be called by the `signer` (currently only modules can be `to`).
     *   @param request.permissions[].permission The new permission level.
     *   @param request.permissions[].func [Optional] The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
     *   @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
     */
    )
  }, {
    key: "createBatchPermissionSignature",
    value: (function () {
      var _createBatchPermissionSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions9, permissions, deadline, ipId, txOptions, _iterator2, _step2, permission, ipAccountClient, data, _yield$ipAccountClien2, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS2, signature, req, _request$txOptions10, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              permissions = request.permissions, deadline = request.deadline, ipId = request.ipId, txOptions = request.txOptions;
              _iterator2 = _createForOfIteratorHelper(permissions);
              _context5.prev = 3;
              _iterator2.s();
            case 5:
              if ((_step2 = _iterator2.n()).done) {
                _context5.next = 11;
                break;
              }
              permission = _step2.value;
              _context5.next = 9;
              return this.checkIsRegistered(permission.ipId);
            case 9:
              _context5.next = 5;
              break;
            case 11:
              _context5.next = 16;
              break;
            case 13:
              _context5.prev = 13;
              _context5.t0 = _context5["catch"](3);
              _iterator2.e(_context5.t0);
            case 16:
              _context5.prev = 16;
              _iterator2.f();
              return _context5.finish(16);
            case 19:
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              data = encodeFunctionData({
                abi: accessControllerAbi,
                functionName: "setBatchTransientPermissions",
                args: [permissions.map(function (permission) {
                  return {
                    ipAccount: permission.ipId,
                    signer: permission.signer,
                    to: permission.to,
                    func: permission.func ? toFunctionSelector(permission.func) : defaultFunctionSelector,
                    permission: permission.permission
                  };
                })]
              });
              _context5.next = 23;
              return ipAccountClient.state();
            case 23:
              _yield$ipAccountClien2 = _context5.sent;
              state = _yield$ipAccountClien2.result;
              _context5.next = 27;
              return this.rpcClient.getBlock();
            case 27:
              blockTimestamp = _context5.sent.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context5.next = 31;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                permissions: permissions,
                chainId: chain[this.chainId],
                wallet: this.wallet
              });
            case 31:
              _yield$getPermissionS2 = _context5.sent;
              signature = _yield$getPermissionS2.signature;
              req = {
                to: getAddress$1(this.accessControllerClient.address, "accessControllerAddress"),
                value: BigInt(0),
                data: data,
                signer: getAddress$1(this.wallet.account.address, "walletAccountAddress"),
                deadline: calculatedDeadline,
                signature: signature
              };
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 38;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 38:
              _context5.next = 40;
              return ipAccountClient.executeWithSig(req);
            case 40:
              txHash = _context5.sent;
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.waitForTransaction)) {
                _context5.next = 47;
                break;
              }
              _context5.next = 44;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 44:
              return _context5.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 47:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 48:
              _context5.next = 53;
              break;
            case 50:
              _context5.prev = 50;
              _context5.t1 = _context5["catch"](0);
              handleError(_context5.t1, "Failed to create batch permission signature");
            case 53:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 50], [3, 13, 16, 19]]);
      }));
      function createBatchPermissionSignature(_x5) {
        return _createBatchPermissionSignature.apply(this, arguments);
      }
      return createBatchPermissionSignature;
    }())
  }, {
    key: "checkIsRegistered",
    value: function () {
      var _checkIsRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(ipId) {
        var isRegistered;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(ipId, "ipId")
              });
            case 2:
              isRegistered = _context6.sent;
              if (isRegistered) {
                _context6.next = 5;
                break;
              }
              throw new Error("IP id with ".concat(ipId, " is not registered."));
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function checkIsRegistered(_x6) {
        return _checkIsRegistered.apply(this, arguments);
      }
      return checkIsRegistered;
    }()
  }]);
}();

var LicenseClient = /*#__PURE__*/function () {
  function LicenseClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, LicenseClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.licenseRegistryClient = new LicenseRegistryEventClient(rpcClient);
    this.piLicenseTemplateReadOnlyClient = new PiLicenseTemplateReadOnlyClient(rpcClient);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.moduleRegistryReadOnlyClient = new ModuleRegistryReadOnlyClient(rpcClient);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.walletAddress = wallet.account.address;
  }
  /**
   * Registers new license terms and return the ID of the newly registered license terms.
   * @param request - The request object that contains all data needed to register a license term.
   *   @param request.transferable Indicates whether the license is transferable or not.
   *   @param request.royaltyPolicy The address of the royalty policy contract which required to StoryProtocol in advance.
   *   @param request.mintingFee The fee to be paid when minting a license.
   *   @param request.expiration The expiration period of the license.
   *   @param request.commercialUse Indicates whether the work can be used commercially or not.
   *   @param request.commercialAttribution Whether attribution is required when reproducing the work commercially or not.
   *   @param request.commercializerChecker Commercializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
   *   @param request.commercializerCheckerData The data to be passed to the commercializer checker contract.
   *   @param request.commercialRevShare Percentage of revenue that must be shared with the licensor.
   *   @param request.commercialRevCeiling The maximum revenue that can be generated from the commercial use of the work.
   *   @param request.derivativesAllowed Indicates whether the licensee can create derivatives of his work or not.
   *   @param request.derivativesAttribution Indicates whether attribution is required for derivatives of the work or not.
   *   @param request.derivativesApproval Indicates whether the licensor must approve derivatives of the work before they can be linked to the licensor IP ID or not.
   *   @param request.derivativesReciprocal Indicates whether the licensee must license derivatives of the work under the same terms or not.
   *   @param request.derivativeRevCeiling The maximum revenue that can be generated from the derivative use of the work.
   *   @param request.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
   *   @param request.uri The URI of the license terms, which can be used to fetch the offchain license terms.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes license terms Id.
   * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
   */
  return _createClass(LicenseClient, [{
    key: "registerPILTerms",
    value: (function () {
      var _registerPILTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, object, licenseTermsId, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return validateLicenseTerms(request, this.rpcClient);
            case 3:
              object = _context.sent;
              _context.next = 6;
              return this.getLicenseTermsId(object);
            case 6:
              licenseTermsId = _context.sent;
              if (!(licenseTermsId !== 0n)) {
                _context.next = 9;
                break;
              }
              return _context.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 9:
              if (!(request !== null && request !== void 0 && (_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 13;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: object
                })
              });
            case 13:
              _context.next = 15;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: object
              });
            case 15:
              txHash = _context.sent;
              if (!(request !== null && request !== void 0 && (_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 24;
                break;
              }
              _context.next = 19;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 19:
              txReceipt = _context.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 24:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 25:
              _context.next = 30;
              break;
            case 27:
              _context.prev = 27;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register license terms");
            case 30:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 27]]);
      }));
      function registerPILTerms(_x) {
        return _registerPILTerms.apply(this, arguments);
      }
      return registerPILTerms;
    }()
    /**
     * Convenient function to register a PIL non commercial social remix license to the registry
     * @param request - [Optional] The request object that contains all data needed to register a PIL non commercial social remix license.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes license terms Id.
     * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
     */
    )
  }, {
    key: "registerNonComSocialRemixingPIL",
    value: (function () {
      var _registerNonComSocialRemixingPIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, licenseTerms, licenseTermsId, _request$txOptions4, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.NON_COMMERCIAL_REMIX);
              _context2.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context2.sent;
              if (!(licenseTermsId !== 0n)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!(request !== null && request !== void 0 && (_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 11;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context2.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context2.sent;
              if (!(request !== null && request !== void 0 && (_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 22;
                break;
              }
              _context2.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context2.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context2.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context2.next = 28;
              break;
            case 25:
              _context2.prev = 25;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to register non commercial social remixing PIL");
            case 28:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 25]]);
      }));
      function registerNonComSocialRemixingPIL(_x2) {
        return _registerNonComSocialRemixingPIL.apply(this, arguments);
      }
      return registerNonComSocialRemixingPIL;
    }()
    /**
     * Convenient function to register a PIL commercial use license to the registry.
     * @param request - The request object that contains all data needed to register a PIL commercial use license.
     *   @param request.defaultMintingFee The fee to be paid when minting a license.
     *   @param request.currency The ERC20 token to be used to pay the minting fee and the token must be registered in story protocol.
     *   @param request.royaltyPolicyAddress [Optional] The address of the royalty policy contract, default value is LAP.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes license terms Id.
     * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
     */
    )
  }, {
    key: "registerCommercialUsePIL",
    value: (function () {
      var _registerCommercialUsePIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, licenseTerms, licenseTermsId, _request$txOptions6, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.COMMERCIAL_USE, {
                defaultMintingFee: request.defaultMintingFee,
                currency: request.currency,
                royaltyPolicyAddress: request.royaltyPolicyAddress && getAddress$1(request.royaltyPolicyAddress, "request.royaltyPolicyAddress") || royaltyPolicyLapAddress[chain[this.chainId]]
              });
              _context3.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context3.sent;
              if (!(licenseTermsId !== 0n)) {
                _context3.next = 7;
                break;
              }
              return _context3.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 11;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context3.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 22;
                break;
              }
              _context3.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context3.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context3.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context3.next = 28;
              break;
            case 25:
              _context3.prev = 25;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to register commercial use PIL");
            case 28:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 25]]);
      }));
      function registerCommercialUsePIL(_x3) {
        return _registerCommercialUsePIL.apply(this, arguments);
      }
      return registerCommercialUsePIL;
    }()
    /**
     * Convenient function to register a PIL commercial Remix license to the registry.
     * @param request - The request object that contains all data needed to register license.
     *   @param request.defaultMintingFee The fee to be paid when minting a license.
     *   @param request.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *   @param request.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *   @param request.royaltyPolicyAddress [Optional] The address of the royalty policy contract, default value is LAP.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes license terms Id.
     * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
     */
    )
  }, {
    key: "registerCommercialRemixPIL",
    value: (function () {
      var _registerCommercialRemixPIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, licenseTerms, licenseTermsId, _request$txOptions8, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.COMMERCIAL_REMIX, {
                defaultMintingFee: request.defaultMintingFee,
                currency: request.currency,
                royaltyPolicyAddress: request.royaltyPolicyAddress && getAddress$1(request.royaltyPolicyAddress, "request.royaltyPolicyAddress") || royaltyPolicyLapAddress[chain[this.chainId]],
                commercialRevShare: request.commercialRevShare
              });
              _context4.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context4.sent;
              if (!(licenseTermsId !== 0n)) {
                _context4.next = 7;
                break;
              }
              return _context4.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 11;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context4.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 22;
                break;
              }
              _context4.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context4.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context4.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context4.next = 28;
              break;
            case 25:
              _context4.prev = 25;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to register commercial remix PIL");
            case 28:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 25]]);
      }));
      function registerCommercialRemixPIL(_x4) {
        return _registerCommercialRemixPIL.apply(this, arguments);
      }
      return registerCommercialRemixPIL;
    }()
    /**
     * Attaches license terms to an IP.
     * @param request - The request object that contains all data needed to attach license terms.
     *   @param request.ipId The address of the IP to which the license terms are attached.
     *   @param request.licenseTemplate The address of the license template, default value is Programmable IP License.
     *   @param request.licenseTermsId The ID of the license terms.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes success.
     * If Ip have attached license terms, success will return false and txhash is empty.
     */
    )
  }, {
    key: "attachLicenseTerms",
    value: (function () {
      var _attachLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions9, isRegistered, isExisted, isAttachedLicenseTerms, req, _request$txOptions10, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              request.licenseTermsId = BigInt(request.licenseTermsId);
              _context5.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.ipId, "request.ipId")
              });
            case 4:
              isRegistered = _context5.sent;
              if (isRegistered) {
                _context5.next = 7;
                break;
              }
              throw new Error("The IP with id ".concat(request.ipId, " is not registered."));
            case 7:
              _context5.next = 9;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: request.licenseTermsId
              });
            case 9:
              isExisted = _context5.sent;
              if (isExisted) {
                _context5.next = 12;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 12:
              _context5.next = 14;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.ipId,
                licenseTemplate: request.licenseTemplate && getAddress$1(request.licenseTemplate, "request.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              });
            case 14:
              isAttachedLicenseTerms = _context5.sent;
              if (!isAttachedLicenseTerms) {
                _context5.next = 17;
                break;
              }
              return _context5.abrupt("return", {
                txHash: "",
                success: false
              });
            case 17:
              req = {
                ipId: request.ipId,
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              };
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 22;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: this.licensingModuleClient.attachLicenseTermsEncode(req)
              });
            case 22:
              _context5.next = 24;
              return this.licensingModuleClient.attachLicenseTerms(req);
            case 24:
              txHash = _context5.sent;
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.waitForTransaction)) {
                _context5.next = 31;
                break;
              }
              _context5.next = 28;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 28:
              return _context5.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 31:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 32:
              _context5.next = 37;
              break;
            case 34:
              _context5.prev = 34;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to attach license terms");
            case 37:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 34]]);
      }));
      function attachLicenseTerms(_x5) {
        return _attachLicenseTerms.apply(this, arguments);
      }
      return attachLicenseTerms;
    }()
    /**
     * Mints license tokens for the license terms attached to an IP.
     * The license tokens are minted to the receiver.
     * The license terms must be attached to the IP before calling this function.
     * But it can mint license token of default license terms without attaching the default license terms,
     * since it is attached to all IPs by default.
     * IP owners can mint license tokens for their IPs for arbitrary license terms
     * without attaching the license terms to IP.
     * It might require the caller pay the minting fee, depending on the license terms or configured by the iP owner.
     * The minting fee is paid in the minting fee token specified in the license terms or configured by the IP owner.
     * IP owners can configure the minting fee of their IPs or
     * configure the minting fee module to determine the minting fee.
     * @param request - The request object that contains all data needed to mint license tokens.
     *   @param request.licensorIpId The licensor IP ID.
     *   @param request.licenseTemplate The address of the license template, default value is Programmable IP License.
     *   @param request.licenseTermsId The ID of the license terms within the license template.
     *   @param request.amount The amount of license tokens to mint.
     *   @param request.receiver The address of the receiver.
     *   @param request.maxMintingFee The maximum minting fee that the caller is willing to pay. if set to 0 then no limit.
     *   @param request.maxRevenueShare The maximum revenue share percentage allowed for minting the License Tokens. Must be between 0 and 100,000,000 (where 100,000,000 represents 100%).
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes license token IDs.
     * @emits LicenseTokensMinted (msg.sender, licensorIpId, licenseTemplate, licenseTermsId, amount, receiver, startLicenseTokenId);
     */
    )
  }, {
    key: "mintLicenseTokens",
    value: (function () {
      var _mintLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
        var _this = this;
        var _request$txOptions11, receiver, req, isLicenseIpIdRegistered, isExisted, isAttachedLicenseTerms, encodedTxData, licenseMintingFee, wipSpenders, _yield$contractCallWi, txHash, receipt, targetLogs, startLicenseTokenId, licenseTokenIds, i;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              receiver = request.receiver && getAddress$1(request.receiver, "request.receiver") || this.walletAddress;
              req = {
                licensorIpId: getAddress$1(request.licensorIpId, "request.licensorIpId"),
                licenseTemplate: request.licenseTemplate && getAddress$1(request.licenseTemplate, "request.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: BigInt(request.licenseTermsId),
                amount: BigInt(request.amount || 1),
                receiver: receiver,
                royaltyContext: zeroAddress,
                maxMintingFee: BigInt(request.maxMintingFee),
                maxRevenueShare: getRevenueShare(request.maxRevenueShare)
              };
              if (!(req.maxMintingFee < 0)) {
                _context6.next = 5;
                break;
              }
              throw new Error("The maxMintingFee must be greater than 0.");
            case 5:
              _context6.next = 7;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.licensorIpId, "request.licensorIpId")
              });
            case 7:
              isLicenseIpIdRegistered = _context6.sent;
              if (isLicenseIpIdRegistered) {
                _context6.next = 10;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.licensorIpId, " is not registered."));
            case 10:
              _context6.next = 12;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: req.licenseTermsId
              });
            case 12:
              isExisted = _context6.sent;
              if (isExisted) {
                _context6.next = 15;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 15:
              _context6.next = 17;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.licensorIpId,
                licenseTemplate: request.licenseTemplate && getAddress$1(request.licenseTemplate, "request.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: req.licenseTermsId
              });
            case 17:
              isAttachedLicenseTerms = _context6.sent;
              if (isAttachedLicenseTerms) {
                _context6.next = 20;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " is not attached to the IP with id ").concat(request.licensorIpId, "."));
            case 20:
              encodedTxData = this.licensingModuleClient.mintLicenseTokensEncode(req);
              if (!((_request$txOptions11 = request.txOptions) !== null && _request$txOptions11 !== void 0 && _request$txOptions11.encodedTxDataOnly)) {
                _context6.next = 23;
                break;
              }
              return _context6.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 23:
              _context6.next = 25;
              return calculateLicenseWipMintFee({
                multicall3Client: this.multicall3Client,
                licenseTemplateClient: this.licenseTemplateClient,
                licensingModuleClient: this.licensingModuleClient,
                parentIpId: req.licensorIpId,
                licenseTermsId: req.licenseTermsId,
                receiver: receiver,
                amount: req.amount
              });
            case 25:
              licenseMintingFee = _context6.sent;
              wipSpenders = [];
              if (licenseMintingFee > 0n) {
                wipSpenders.push({
                  address: royaltyModuleAddress[chain[this.chainId]],
                  amount: licenseMintingFee
                });
              }
              _context6.next = 30;
              return contractCallWithWipFees({
                totalFees: licenseMintingFee,
                wipOptions: request.wipOptions,
                multicall3Client: this.multicall3Client,
                rpcClient: this.rpcClient,
                wipClient: this.wipClient,
                wipSpenders: wipSpenders,
                contractCall: function contractCall() {
                  return _this.licensingModuleClient.mintLicenseTokens(req);
                },
                wallet: this.wallet,
                sender: this.walletAddress,
                txOptions: request.txOptions,
                encodedTxs: [encodedTxData]
              });
            case 30:
              _yield$contractCallWi = _context6.sent;
              txHash = _yield$contractCallWi.txHash;
              receipt = _yield$contractCallWi.receipt;
              if (receipt) {
                _context6.next = 35;
                break;
              }
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 35:
              targetLogs = this.licensingModuleClient.parseTxLicenseTokensMintedEvent(receipt);
              startLicenseTokenId = targetLogs[0].startLicenseTokenId;
              licenseTokenIds = [];
              for (i = 0; i < req.amount; i++) {
                licenseTokenIds.push(startLicenseTokenId + BigInt(i));
              }
              return _context6.abrupt("return", {
                txHash: txHash,
                licenseTokenIds: licenseTokenIds,
                receipt: receipt
              });
            case 42:
              _context6.prev = 42;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to mint license tokens");
            case 45:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 42]]);
      }));
      function mintLicenseTokens(_x6) {
        return _mintLicenseTokens.apply(this, arguments);
      }
      return mintLicenseTokens;
    }()
    /**
     * Gets license terms of the given ID.
     * @param selectedLicenseTermsId The ID of the license terms.
     * @returns A Promise that resolves to an object containing the PILTerms associate with the given ID.
     */
    )
  }, {
    key: "getLicenseTerms",
    value: (function () {
      var _getLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(selectedLicenseTermsId) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return this.piLicenseTemplateReadOnlyClient.getLicenseTerms({
                selectedLicenseTermsId: BigInt(selectedLicenseTermsId)
              });
            case 3:
              return _context7.abrupt("return", _context7.sent);
            case 6:
              _context7.prev = 6;
              _context7.t0 = _context7["catch"](0);
              handleError(_context7.t0, "Failed to get license terms");
            case 9:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 6]]);
      }));
      function getLicenseTerms(_x7) {
        return _getLicenseTerms.apply(this, arguments);
      }
      return getLicenseTerms;
    }()
    /**
     * Pre-compute the minting license fee for the given IP and license terms. The function can be used to calculate the minting license fee before minting license tokens.
     * @param request - The request object that contains all data needed to predict minting licenses fee.
     *   @param request.licensorIpId The IP ID of the licensor.
     *   @param request.licenseTermsId The ID of the license terms.
     *   @param request.amount The amount of license tokens to mint.
     *   @param request.licenseTemplate [Optional] The address of the license template, default value is Programmable IP License.
     *   @param request.receiver [Optional] The address of the receiver,default value is your wallet address.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the currency token and token amount.
     */
    )
  }, {
    key: "predictMintingLicenseFee",
    value: (function () {
      var _predictMintingLicenseFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {
        var isLicenseIpIdRegistered, licenseTermsId, isExisted, object;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              _context8.next = 3;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.licensorIpId, "request.licensorIpId")
              });
            case 3:
              isLicenseIpIdRegistered = _context8.sent;
              if (isLicenseIpIdRegistered) {
                _context8.next = 6;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.licensorIpId, " is not registered."));
            case 6:
              licenseTermsId = BigInt(request.licenseTermsId);
              _context8.next = 9;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: licenseTermsId
              });
            case 9:
              isExisted = _context8.sent;
              if (isExisted) {
                _context8.next = 12;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 12:
              object = _objectSpread2(_objectSpread2({}, request), {}, {
                receiver: request.receiver && getAddress$1(request.receiver, "request.receiver") || this.wallet.account.address,
                amount: BigInt(request.amount),
                royaltyContext: zeroAddress,
                licenseTemplate: request.licenseTemplate && getAddress$1(request.licenseTemplate, "request.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: licenseTermsId
              });
              _context8.next = 15;
              return this.licensingModuleClient.predictMintingLicenseFee(object);
            case 15:
              return _context8.abrupt("return", _context8.sent);
            case 18:
              _context8.prev = 18;
              _context8.t0 = _context8["catch"](0);
              handleError(_context8.t0, "Failed to predict minting license fee");
            case 21:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[0, 18]]);
      }));
      function predictMintingLicenseFee(_x8) {
        return _predictMintingLicenseFee.apply(this, arguments);
      }
      return predictMintingLicenseFee;
    }()
    /**
     * Sets the licensing configuration for a specific license terms of an IP. If both licenseTemplate and licenseTermsId are not specified then the licensing config apply to all licenses of given IP.
     * @param request - The request object that contains all data needed to set licensing config.
     *   @param request.ipId The address of the IP for which the configuration is being set.
     *   @param request.licenseTermsId The ID of the license terms within the license template.
     *   @param request.licenseTemplate The address of the license template used, If not specified, the configuration applies to all licenses.
     *   @param request.licensingConfig The licensing configuration for the license.
     *   @param request.licensingConfig.isSet Whether the configuration is set or not.
     *   @param request.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *   @param request.licensingConfig.hookData The data to be used by the licensing hook.
     *   @param request.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none.
     *   @param request.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *   @param request.licensingConfig.disabled Whether the license is disabled or not.
     *   @param request.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *    If the remaining reward share in the group is less than the minimumGroupRewardShare, the IP cannot be added to the group.
     *   @param request.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address,
     *    or address(0) if the IP does not want to be added to any group.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes success.
     */
    )
  }, {
    key: "setLicensingConfig",
    value: (function () {
      var _setLicensingConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {
        var _request$txOptions12, req, isLicenseIpIdRegistered, isExisted, isRegistered, _request$txOptions13, txHash;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              req = {
                ipId: request.ipId,
                licenseTemplate: getAddress$1(request.licenseTemplate, "request.licenseTemplate"),
                licenseTermsId: BigInt(request.licenseTermsId),
                licensingConfig: {
                  isSet: request.licensingConfig.isSet,
                  mintingFee: BigInt(request.licensingConfig.mintingFee),
                  hookData: request.licensingConfig.hookData,
                  licensingHook: request.licensingConfig.licensingHook,
                  disabled: request.licensingConfig.disabled,
                  commercialRevShare: getRevenueShare(request.licensingConfig.commercialRevShare),
                  expectGroupRewardPool: getAddress$1(request.licensingConfig.expectGroupRewardPool, "request.licensingConfig.expectGroupRewardPool"),
                  expectMinimumGroupRewardShare: Number(request.licensingConfig.expectMinimumGroupRewardShare)
                }
              };
              if (!(req.licensingConfig.mintingFee < 0)) {
                _context9.next = 4;
                break;
              }
              throw new Error("The minting fee must be greater than 0.");
            case 4:
              if (!(request.licenseTemplate === zeroAddress && request.licensingConfig.commercialRevShare !== 0)) {
                _context9.next = 6;
                break;
              }
              throw new Error("The license template cannot be zero address if commercial revenue share is not zero.");
            case 6:
              _context9.next = 8;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.ipId, "request.ipId")
              });
            case 8:
              isLicenseIpIdRegistered = _context9.sent;
              if (isLicenseIpIdRegistered) {
                _context9.next = 11;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.ipId, " is not registered."));
            case 11:
              _context9.next = 13;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: req.licenseTermsId
              });
            case 13:
              isExisted = _context9.sent;
              if (isExisted) {
                _context9.next = 16;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 16:
              if (!(request.licensingConfig.licensingHook !== zeroAddress)) {
                _context9.next = 22;
                break;
              }
              _context9.next = 19;
              return this.moduleRegistryReadOnlyClient.isRegistered({
                moduleAddress: request.licensingConfig.licensingHook
              });
            case 19:
              isRegistered = _context9.sent;
              if (isRegistered) {
                _context9.next = 22;
                break;
              }
              throw new Error("The licensing hook is not registered.");
            case 22:
              if (!(request.licenseTemplate === zeroAddress && request.licenseTermsId !== 0n)) {
                _context9.next = 24;
                break;
              }
              throw new Error("The license template is zero address but license terms id is not zero.");
            case 24:
              if (!((_request$txOptions12 = request.txOptions) !== null && _request$txOptions12 !== void 0 && _request$txOptions12.encodedTxDataOnly)) {
                _context9.next = 28;
                break;
              }
              return _context9.abrupt("return", {
                encodedTxData: this.licensingModuleClient.setLicensingConfigEncode(req)
              });
            case 28:
              _context9.next = 30;
              return this.licensingModuleClient.setLicensingConfig(req);
            case 30:
              txHash = _context9.sent;
              if (!((_request$txOptions13 = request.txOptions) !== null && _request$txOptions13 !== void 0 && _request$txOptions13.waitForTransaction)) {
                _context9.next = 35;
                break;
              }
              _context9.next = 34;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 34:
              return _context9.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 35:
              return _context9.abrupt("return", {
                txHash: txHash
              });
            case 36:
              _context9.next = 41;
              break;
            case 38:
              _context9.prev = 38;
              _context9.t0 = _context9["catch"](0);
              handleError(_context9.t0, "Failed to set licensing config");
            case 41:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[0, 38]]);
      }));
      function setLicensingConfig(_x9) {
        return _setLicensingConfig.apply(this, arguments);
      }
      return setLicensingConfig;
    }())
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(request) {
        var licenseRes;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.licenseTemplateClient.getLicenseTermsId({
                terms: request
              });
            case 2:
              licenseRes = _context10.sent;
              return _context10.abrupt("return", licenseRes.selectedLicenseTermsId);
            case 4:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getLicenseTermsId(_x10) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }]);
}();

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var v0Prefix = "1220";
var convertCIDtoHashIPFS = function convertCIDtoHashIPFS(cid) {
  var isV0 = cid.startsWith("Qm");
  var parsedCID = CID.parse(cid);
  var base58CID = isV0 ? parsedCID.toString() : parsedCID.toV0().toString();
  var bytes = bs58.decode(base58CID);
  var base16CID = Array.from(bytes).map(function (_byte) {
    return _byte.toString(16).padStart(2, "0");
  }).join("");
  return "0x" + base16CID.slice(v0Prefix.length);
};
var convertHashIPFStoCID = function convertHashIPFStoCID(hash) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "v0";
  var base16CID = v0Prefix + hash.slice(2);
  var bytes = new Uint8Array(base16CID.match(/.{1,2}/g).map(function (_byte2) {
    return parseInt(_byte2, 16);
  }));
  var base58CID = bs58.encode(Buffer.from(bytes));
  if (version === "v0") {
    return base58CID;
  } else {
    return CID.parse(base58CID, base58btc).toV1().toString();
  }
};

var DisputeClient = /*#__PURE__*/function () {
  function DisputeClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, DisputeClient);
    this.rpcClient = rpcClient;
    this.disputeModuleClient = new DisputeModuleClient(rpcClient, wallet);
    this.arbitrationPolicyUmaReadOnlyClient = new ArbitrationPolicyUmaReadOnlyClient(rpcClient);
    this.chainId = chainId;
  }

  /**
   * Raises a dispute on a given ipId
   * @param request - The request object containing necessary data to raise a dispute.
   *   @param request.targetIpId The IP ID that is the target of the dispute.
   *   @param request.targetTag The target tag of the dispute.
   *   @param request.cid CID (Content Identifier) is a unique identifier in IPFS, including CID v0 (base58) and CID v1 (base32).
   *   @param request.liveness The liveness time.
   *   @param request.bond The bond size.
   *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to a RaiseDisputeResponse containing the transaction hash.
   * @throws `NotRegisteredIpId` if targetIpId is not registered in the IPA Registry.
   * @throws `NotWhitelistedDisputeTag` if targetTag is not whitelisted.
   * @throws `ZeroLinkToDisputeEvidence` if linkToDisputeEvidence is empty
   * @calls raiseDispute(address _targetIpId, string memory _linkToDisputeEvidence, bytes32 _targetTag, bytes calldata _data) external nonReentrant returns (uint256) {
   * @emits DisputeRaised (disputeId_, targetIpId, msg.sender, arbitrationPolicy, linkToDisputeEvidence, targetTag, calldata);
   */
  return _createClass(DisputeClient, [{
    key: "raiseDispute",
    value: (function () {
      var _raiseDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, liveness, bonds, tokenAddress, _yield$Promise$all, _yield$Promise$all2, minLiveness, maxLiveness, tag, maxBonds, data, _yield$this$disputeMo, isWhiteList, req, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              liveness = BigInt(request.liveness);
              bonds = BigInt(request.bond);
              tokenAddress = wrappedIpAddress[chain[this.chainId]];
              _context.next = 6;
              return Promise.all([this.arbitrationPolicyUmaReadOnlyClient.minLiveness(), this.arbitrationPolicyUmaReadOnlyClient.maxLiveness()]);
            case 6:
              _yield$Promise$all = _context.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              minLiveness = _yield$Promise$all2[0];
              maxLiveness = _yield$Promise$all2[1];
              tag = stringToHex(request.targetTag, {
                size: 32
              });
              if (!(liveness < minLiveness || liveness > maxLiveness)) {
                _context.next = 13;
                break;
              }
              throw new Error("Liveness must be between ".concat(minLiveness, " and ").concat(maxLiveness, "."));
            case 13:
              _context.next = 15;
              return this.arbitrationPolicyUmaReadOnlyClient.maxBonds({
                token: tokenAddress
              });
            case 15:
              maxBonds = _context.sent;
              if (!(bonds > maxBonds)) {
                _context.next = 18;
                break;
              }
              throw new Error("Bonds must be less than ".concat(maxBonds, "."));
            case 18:
              data = encodeAbiParameters([{
                name: "",
                type: "uint64"
              }, {
                name: "",
                type: "address"
              }, {
                name: "",
                type: "uint256"
              }], [liveness, tokenAddress, bonds]);
              _context.next = 21;
              return this.disputeModuleClient.isWhitelistedDisputeTag({
                tag: tag
              });
            case 21:
              _yield$this$disputeMo = _context.sent;
              isWhiteList = _yield$this$disputeMo.allowed;
              if (isWhiteList) {
                _context.next = 25;
                break;
              }
              throw new Error("The target tag ".concat(request.targetTag, " is not whitelisted."));
            case 25:
              req = {
                targetIpId: getAddress$1(request.targetIpId, "request.targetIpId"),
                targetTag: tag,
                disputeEvidenceHash: convertCIDtoHashIPFS(request.cid),
                data: data
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 30;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.disputeModuleClient.raiseDisputeEncode(req)
              });
            case 30:
              _context.next = 32;
              return this.disputeModuleClient.raiseDispute(req);
            case 32:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 39;
                break;
              }
              _context.next = 36;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 36:
              txReceipt = _context.sent;
              targetLogs = this.disputeModuleClient.parseTxDisputeRaisedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                disputeId: targetLogs[0].disputeId
              });
            case 39:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 40:
              _context.next = 45;
              break;
            case 42:
              _context.prev = 42;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to raise dispute");
            case 45:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 42]]);
      }));
      function raiseDispute(_x) {
        return _raiseDispute.apply(this, arguments);
      }
      return raiseDispute;
    }()
    /**
     * Cancels an ongoing dispute
     * @param request - The request object containing details to cancel the dispute.
     *   @param request.disputeId The ID of the dispute to be cancelled.
     *   @param request.data [Optional] additional data used in the cancellation process.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a CancelDisputeResponse containing the transaction hash.
     * @throws NotInDisputeState, if the currentTag of the Dispute is not being disputed
     * @throws NotDisputeInitiator, if the transaction executor is not the one that initiated the dispute
     * @throws error if the Dispute's ArbitrationPolicy contract is not valid
     * @calls cancelDispute(uint256 _disputeId, bytes calldata _data) external nonReentrant {
     * @emits DisputeCancelled (_disputeId, _data);
     */
    )
  }, {
    key: "cancelDispute",
    value: (function () {
      var _cancelDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              req = {
                disputeId: BigInt(request.disputeId),
                data: request.data ? request.data : "0x"
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 6;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.disputeModuleClient.cancelDisputeEncode(req)
              });
            case 6:
              _context2.next = 8;
              return this.disputeModuleClient.cancelDispute(req);
            case 8:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 12;
                break;
              }
              _context2.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 13:
              _context2.next = 18;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to cancel dispute");
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 15]]);
      }));
      function cancelDispute(_x2) {
        return _cancelDispute.apply(this, arguments);
      }
      return cancelDispute;
    }()
    /**
     * Resolves a dispute after it has been judged
     * @param request - The request object containing details to resolve the dispute.
     *   @param request.disputeId The ID of the dispute to be resolved.
     *   @param request.data The data to resolve the dispute.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a ResolveDisputeResponse.
     * @throws NotAbleToResolve, if currentTag is still in dispute (i.e still needs a judgement to be set)
     * @throws NotDisputeInitiator, if the transaction executor is not the one that initiated the dispute
     * @emits DisputeResolved (_disputeId)
     */
    )
  }, {
    key: "resolveDispute",
    value: (function () {
      var _resolveDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, req, _request$txOptions6, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              req = {
                disputeId: BigInt(request.disputeId),
                data: request.data
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 6;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.disputeModuleClient.resolveDisputeEncode(req)
              });
            case 6:
              _context3.next = 8;
              return this.disputeModuleClient.resolveDispute(req);
            case 8:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 12;
                break;
              }
              _context3.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 13:
              _context3.next = 18;
              break;
            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to resolve dispute");
            case 18:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 15]]);
      }));
      function resolveDispute(_x3) {
        return _resolveDispute.apply(this, arguments);
      }
      return resolveDispute;
    }())
  }]);
}();

var IPAccountClient = /*#__PURE__*/function () {
  function IPAccountClient(rpcClient, wallet) {
    _classCallCheck(this, IPAccountClient);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
  }

  /** Executes a transaction from the IP Account.
   * @param request - The request object containing necessary data to execute IP Account a transaction.
   *   @param request.ipId The Ip Id to get ip account.
   *   @param request.to The recipient of the transaction.
   *   @param request.value The amount of Ether to send.
   *   @param request.accountAddress The ipId to send.
   *   @param request.data The data to send along with the transaction.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns Tx hash for the transaction.
   */
  return _createClass(IPAccountClient, [{
    key: "execute",
    value: (function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, ipAccountClient, req, _request$txOptions2, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(request.ipId, "request.ipId"));
              req = {
                to: request.to,
                value: BigInt(0),
                data: request.data
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: ipAccountClient.executeEncode(_objectSpread2(_objectSpread2({}, req), {}, {
                  operation: 0
                }))
              });
            case 7:
              _context.next = 9;
              return ipAccountClient.execute(_objectSpread2(_objectSpread2({}, req), {}, {
                operation: 0
              }));
            case 9:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 13;
                break;
              }
              _context.next = 13;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 13:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 14:
              _context.next = 19;
              break;
            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to execute the IP Account transaction");
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 16]]);
      }));
      function execute(_x) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /** Executes a transaction from the IP Account.
     * @param request - The request object containing necessary data to execute IP Account a transaction.
     *   @param request.ipId The Ip Id to get ip account.
     *   @param request.to The recipient of the transaction.
     *   @param request.data The data to send along with the transaction.
     *   @param request.signer The signer of the transaction.
     *   @param request.deadline The deadline of the transaction signature.
     *   @param request.signature The signature of the transaction, EIP-712 encoded.
     *   @param request.value [Optional] The amount of Ether to send.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns Tx hash for the transaction.
     */
    )
  }, {
    key: "executeWithSig",
    value: (function () {
      var _executeWithSig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, ipAccountClient, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(request.ipId, "request.ipId"));
              req = {
                to: getAddress$1(request.to, "request.to"),
                value: BigInt(request.value || 0),
                data: request.data,
                signer: getAddress$1(request.signer, "request.signer"),
                deadline: BigInt(request.deadline),
                signature: request.signature
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 7:
              _context2.next = 9;
              return ipAccountClient.executeWithSig(req);
            case 9:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 13;
                break;
              }
              _context2.next = 13;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 13:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 14:
              _context2.next = 19;
              break;
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to execute with signature for the IP Account transaction");
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 16]]);
      }));
      function executeWithSig(_x2) {
        return _executeWithSig.apply(this, arguments);
      }
      return executeWithSig;
    }()
    /** Returns the IPAccount's internal nonce for transaction ordering.
     * @param ipId The IP ID
     * @returns A Promise that resolves to the IP Account's nonce.
     */
    )
  }, {
    key: "getIpAccountNonce",
    value: (function () {
      var _getIpAccountNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(ipId) {
        var ipAccount, _yield$ipAccount$stat, state;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(ipId, "ipId"));
              _context3.next = 4;
              return ipAccount.state();
            case 4:
              _yield$ipAccount$stat = _context3.sent;
              state = _yield$ipAccount$stat.result;
              return _context3.abrupt("return", state);
            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to get the IP Account nonce");
            case 12:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 9]]);
      }));
      function getIpAccountNonce(_x3) {
        return _getIpAccountNonce.apply(this, arguments);
      }
      return getIpAccountNonce;
    }()
    /**
     * Returns the identifier of the non-fungible token which owns the account
     * @returns A Promise that resolves to an object containing the chain ID, token contract address, and token ID.
     */
    )
  }, {
    key: "getToken",
    value: (function () {
      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ipId) {
        var ipAccount, _yield$ipAccount$toke, _yield$ipAccount$toke2, chainId, tokenContract, tokenId;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(ipId, "ipId"));
              _context4.next = 4;
              return ipAccount.token();
            case 4:
              _yield$ipAccount$toke = _context4.sent;
              _yield$ipAccount$toke2 = _slicedToArray(_yield$ipAccount$toke, 3);
              chainId = _yield$ipAccount$toke2[0];
              tokenContract = _yield$ipAccount$toke2[1];
              tokenId = _yield$ipAccount$toke2[2];
              return _context4.abrupt("return", {
                chainId: chainId,
                tokenContract: tokenContract,
                tokenId: tokenId
              });
            case 12:
              _context4.prev = 12;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to get the token");
            case 15:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 12]]);
      }));
      function getToken(_x4) {
        return _getToken.apply(this, arguments);
      }
      return getToken;
    }())
  }]);
}();

var RoyaltyClient = /*#__PURE__*/function () {
  function RoyaltyClient(rpcClient, wallet) {
    _classCallCheck(this, RoyaltyClient);
    this.royaltyModuleClient = new RoyaltyModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.ipRoyaltyVaultImplReadOnlyClient = new IpRoyaltyVaultImplReadOnlyClient(rpcClient);
    this.ipRoyaltyVaultImplEventClient = new IpRoyaltyVaultImplEventClient(rpcClient);
    this.ipAccountClient = new IPAccountClient(rpcClient, wallet);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.walletAddress = wallet.account.address;
  }
  return _createClass(RoyaltyClient, [{
    key: "claimAllRevenue",
    value: function () {
      var _claimAllRevenue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(req) {
        var _req$claimOptions, _req$claimOptions2, ancestorIpId, claimer, childIpIds, royaltyPolicies, currencyTokens, _yield$simulateAndWri, txHash, receipt, txHashes, isClaimerIp, ipAccount, ownsClaimer, ipOwner, claimedTokens, skipTransfer, skipUnwrapIp, hashes, _iterator, _step, _step$value, token, amount, hash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              ancestorIpId = validateAddress(req.ancestorIpId);
              claimer = validateAddress(req.claimer);
              childIpIds = validateAddresses(req.childIpIds);
              royaltyPolicies = validateAddresses(req.royaltyPolicies);
              currencyTokens = validateAddresses(req.currencyTokens); // todo: use generated code when aeneid explorer is available
              _context.next = 8;
              return simulateAndWriteContract({
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                waitForTransaction: true,
                data: {
                  abi: royaltyWorkflowsAbi,
                  address: royaltyWorkflowsAddress[1315],
                  functionName: "claimAllRevenue",
                  args: [ancestorIpId, claimer, childIpIds, royaltyPolicies, currencyTokens]
                }
              });
            case 8:
              _yield$simulateAndWri = _context.sent;
              txHash = _yield$simulateAndWri.txHash;
              receipt = _yield$simulateAndWri.receipt;
              txHashes = [];
              txHashes.push(txHash);

              // determine if the claimer is an IP owned by the wallet
              _context.next = 15;
              return this.ipAssetRegistryClient.isRegistered({
                id: claimer
              });
            case 15:
              isClaimerIp = _context.sent;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, claimer);
              ownsClaimer = claimer === this.walletAddress;
              if (!isClaimerIp) {
                _context.next = 23;
                break;
              }
              _context.next = 21;
              return ipAccount.owner();
            case 21:
              ipOwner = _context.sent;
              ownsClaimer = ipOwner === this.walletAddress;
            case 23:
              if (ownsClaimer) {
                _context.next = 25;
                break;
              }
              return _context.abrupt("return", {
                receipt: receipt,
                txHashes: txHashes
              });
            case 25:
              claimedTokens = this.getClaimedTokensFromReceipt(receipt);
              skipTransfer = ((_req$claimOptions = req.claimOptions) === null || _req$claimOptions === void 0 ? void 0 : _req$claimOptions.autoTransferAllClaimedTokensFromIp) === false;
              skipUnwrapIp = ((_req$claimOptions2 = req.claimOptions) === null || _req$claimOptions2 === void 0 ? void 0 : _req$claimOptions2.autoUnwrapIpTokens) === false; // transfer claimed tokens from IP to wallet if wallet owns IP
              if (!(!skipTransfer && isClaimerIp && ownsClaimer)) {
                _context.next = 35;
                break;
              }
              _context.next = 31;
              return this.transferClaimedTokensFromIpToWallet({
                ipAccount: ipAccount,
                skipUnwrapIp: skipUnwrapIp,
                claimedTokens: claimedTokens
              });
            case 31:
              hashes = _context.sent;
              txHashes.push.apply(txHashes, _toConsumableArray(hashes));
              _context.next = 59;
              break;
            case 35:
              if (!(!skipUnwrapIp && this.walletAddress === claimer)) {
                _context.next = 59;
                break;
              }
              // if the claimer is the wallet, then we can unwrap any claimed WIP tokens
              _iterator = _createForOfIteratorHelper(claimedTokens);
              _context.prev = 37;
              _iterator.s();
            case 39:
              if ((_step = _iterator.n()).done) {
                _context.next = 51;
                break;
              }
              _step$value = _step.value, token = _step$value.token, amount = _step$value.amount;
              if (!(token !== WIP_TOKEN_ADDRESS)) {
                _context.next = 43;
                break;
              }
              return _context.abrupt("continue", 49);
            case 43:
              _context.next = 45;
              return this.wipClient.withdraw({
                value: amount
              });
            case 45:
              hash = _context.sent;
              txHashes.push(hash);
              _context.next = 49;
              return this.rpcClient.waitForTransactionReceipt({
                hash: hash
              });
            case 49:
              _context.next = 39;
              break;
            case 51:
              _context.next = 56;
              break;
            case 53:
              _context.prev = 53;
              _context.t0 = _context["catch"](37);
              _iterator.e(_context.t0);
            case 56:
              _context.prev = 56;
              _iterator.f();
              return _context.finish(56);
            case 59:
              return _context.abrupt("return", {
                receipt: receipt,
                claimedTokens: claimedTokens,
                txHashes: txHashes
              });
            case 62:
              _context.prev = 62;
              _context.t1 = _context["catch"](0);
              handleError(_context.t1, "Failed to claim all revenue");
            case 65:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 62], [37, 53, 56, 59]]);
      }));
      function claimAllRevenue(_x) {
        return _claimAllRevenue.apply(this, arguments);
      }
      return claimAllRevenue;
    }()
    /**
     * Allows the function caller to pay royalties to the receiver IP asset on behalf of the payer IP asset.
     * @param request - The request object that contains all data needed to pay royalty on behalf.
     *   @param request.receiverIpId The ipId that receives the royalties.
     *   @param request.payerIpId The ID of the IP asset that pays the royalties.
     *   @param request.token The token to use to pay the royalties.
     *   @param request.amount The amount to pay.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
  }, {
    key: "payRoyaltyOnBehalf",
    value: (function () {
      var _payRoyaltyOnBehalf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _this = this;
        var _request$txOptions, receiverIpId, payerIpId, token, amount, wipOptions, txOptions, sender, payAmount, isReceiverRegistered, isPayerRegistered, req, encodedTxData, contractCall, wipSpenders, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              receiverIpId = request.receiverIpId, payerIpId = request.payerIpId, token = request.token, amount = request.amount, wipOptions = request.wipOptions, txOptions = request.txOptions;
              sender = this.wallet.account.address;
              payAmount = BigInt(amount);
              if (!(payAmount <= 0n)) {
                _context2.next = 6;
                break;
              }
              throw new Error("The amount to pay must be number greater than 0.");
            case 6:
              _context2.next = 8;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(receiverIpId, "request.receiverIpId")
              });
            case 8:
              isReceiverRegistered = _context2.sent;
              if (isReceiverRegistered) {
                _context2.next = 11;
                break;
              }
              throw new Error("The receiver IP with id ".concat(receiverIpId, " is not registered."));
            case 11:
              if (!(getAddress$1(payerIpId, "request.payerIpId") && payerIpId !== zeroAddress)) {
                _context2.next = 17;
                break;
              }
              _context2.next = 14;
              return this.ipAssetRegistryClient.isRegistered({
                id: payerIpId
              });
            case 14:
              isPayerRegistered = _context2.sent;
              if (isPayerRegistered) {
                _context2.next = 17;
                break;
              }
              throw new Error("The payer IP with id ".concat(request.payerIpId, " is not registered."));
            case 17:
              req = {
                receiverIpId: receiverIpId,
                payerIpId: payerIpId,
                token: getAddress$1(token, "request.token"),
                amount: BigInt(amount)
              };
              encodedTxData = this.royaltyModuleClient.payRoyaltyOnBehalfEncode(req);
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context2.next = 21;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 21:
              contractCall = function contractCall() {
                return _this.royaltyModuleClient.payRoyaltyOnBehalf(req);
              }; // auto wrap wallet's IP to WIP if paying WIP
              if (!(token === WIP_TOKEN_ADDRESS)) {
                _context2.next = 27;
                break;
              }
              wipSpenders = [{
                address: this.royaltyModuleClient.address,
                amount: payAmount
              }];
              return _context2.abrupt("return", contractCallWithWipFees({
                totalFees: payAmount,
                wipOptions: wipOptions,
                multicall3Client: this.multicall3Client,
                rpcClient: this.rpcClient,
                wipClient: this.wipClient,
                wipSpenders: wipSpenders,
                contractCall: contractCall,
                sender: sender,
                wallet: this.wallet,
                txOptions: txOptions,
                encodedTxs: [encodedTxData]
              }));
            case 27:
              _context2.next = 29;
              return contractCall();
            case 29:
              txHash = _context2.sent;
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 31:
              _context2.next = 36;
              break;
            case 33:
              _context2.prev = 33;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to pay royalty on behalf");
            case 36:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 33]]);
      }));
      function payRoyaltyOnBehalf(_x2) {
        return _payRoyaltyOnBehalf.apply(this, arguments);
      }
      return payRoyaltyOnBehalf;
    }()
    /**
     * Get total amount of revenue token claimable by a royalty token holder.
     * @param request - The request object that contains all data needed to claim Revenue.
     *   @param request.royaltyVaultIpId The id of the royalty vault.
     *   @param request.claimer The address of the royalty token holder
     *   @param request.token The revenue token to claim.
     * @returns A Promise that contains the amount of revenue token claimable
     */
    )
  }, {
    key: "claimableRevenue",
    value: (function () {
      var _claimableRevenue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var proxyAddress, ipRoyaltyVault;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.getRoyaltyVaultAddress(getAddress$1(request.royaltyVaultIpId, "request.royaltyVaultIpId"));
            case 3:
              proxyAddress = _context3.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplReadOnlyClient(this.rpcClient, proxyAddress);
              _context3.next = 7;
              return ipRoyaltyVault.claimableRevenue({
                claimer: getAddress$1(request.claimer, "request.account"),
                token: getAddress$1(request.token, "request.token")
              });
            case 7:
              return _context3.abrupt("return", _context3.sent);
            case 10:
              _context3.prev = 10;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to calculate claimable revenue");
            case 13:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 10]]);
      }));
      function claimableRevenue(_x3) {
        return _claimableRevenue.apply(this, arguments);
      }
      return claimableRevenue;
    }()
    /**
     * Get the royalty vault proxy address of given royaltyVaultIpId.
     * @param royaltyVaultIpId the id of the royalty vault.
     * @returns A Promise that resolves to an object containing the royalty vault address.
     */
    )
  }, {
    key: "getRoyaltyVaultAddress",
    value: (function () {
      var _getRoyaltyVaultAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(royaltyVaultIpId) {
        var isRoyaltyVaultIpIdRegistered;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(royaltyVaultIpId, "royaltyVaultIpId")
              });
            case 2:
              isRoyaltyVaultIpIdRegistered = _context4.sent;
              if (isRoyaltyVaultIpIdRegistered) {
                _context4.next = 5;
                break;
              }
              throw new Error("The royalty vault IP with id ".concat(royaltyVaultIpId, " is not registered."));
            case 5:
              _context4.next = 7;
              return this.royaltyModuleClient.ipRoyaltyVaults({
                ipId: royaltyVaultIpId
              });
            case 7:
              return _context4.abrupt("return", _context4.sent);
            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getRoyaltyVaultAddress(_x4) {
        return _getRoyaltyVaultAddress.apply(this, arguments);
      }
      return getRoyaltyVaultAddress;
    }())
  }, {
    key: "getClaimedTokensFromReceipt",
    value: function getClaimedTokensFromReceipt(receipt) {
      var eventName = "RevenueTokenClaimed";
      var claimedTokens = [];
      var _iterator2 = _createForOfIteratorHelper(receipt.logs),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var log = _step2.value;
          try {
            var event = decodeEventLog({
              abi: ipRoyaltyVaultImplAbi,
              eventName: eventName,
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === eventName) {
              claimedTokens.push({
                token: event.args.token,
                amount: event.args.amount
              });
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return claimedTokens;
    }
  }, {
    key: "transferClaimedTokensFromIpToWallet",
    value: function () {
      var _transferClaimedTokensFromIpToWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref) {
        var _this2 = this;
        var ipAccount, skipUnwrapIp, claimedTokens, txHashes, transferToken, _iterator3, _step3, _step3$value, token, amount;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              ipAccount = _ref.ipAccount, skipUnwrapIp = _ref.skipUnwrapIp, claimedTokens = _ref.claimedTokens;
              txHashes = [];
              transferToken = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(token, amount) {
                  var hash, withdrawalHash;
                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                    while (1) switch (_context5.prev = _context5.next) {
                      case 0:
                        if (!(amount <= 0)) {
                          _context5.next = 2;
                          break;
                        }
                        return _context5.abrupt("return");
                      case 2:
                        _context5.next = 4;
                        return ipAccount.execute({
                          to: token,
                          value: BigInt(0),
                          operation: 0,
                          data: encodeFunctionData({
                            abi: erc20Abi,
                            functionName: "transfer",
                            args: [_this2.walletAddress, amount]
                          })
                        });
                      case 4:
                        hash = _context5.sent;
                        _context5.next = 7;
                        return _this2.rpcClient.waitForTransactionReceipt({
                          hash: hash
                        });
                      case 7:
                        txHashes.push(hash);

                        // auto unwrap WIP tokens once they are transferred
                        if (!(token === WIP_TOKEN_ADDRESS && !skipUnwrapIp)) {
                          _context5.next = 15;
                          break;
                        }
                        _context5.next = 11;
                        return _this2.wipClient.withdraw({
                          value: amount
                        });
                      case 11:
                        withdrawalHash = _context5.sent;
                        txHashes.push(withdrawalHash);
                        _context5.next = 15;
                        return _this2.rpcClient.waitForTransactionReceipt({
                          hash: withdrawalHash
                        });
                      case 15:
                      case "end":
                        return _context5.stop();
                    }
                  }, _callee5);
                }));
                return function transferToken(_x6, _x7) {
                  return _ref2.apply(this, arguments);
                };
              }();
              _iterator3 = _createForOfIteratorHelper(claimedTokens);
              _context6.prev = 4;
              _iterator3.s();
            case 6:
              if ((_step3 = _iterator3.n()).done) {
                _context6.next = 12;
                break;
              }
              _step3$value = _step3.value, token = _step3$value.token, amount = _step3$value.amount;
              _context6.next = 10;
              return transferToken(token, amount);
            case 10:
              _context6.next = 6;
              break;
            case 12:
              _context6.next = 17;
              break;
            case 14:
              _context6.prev = 14;
              _context6.t0 = _context6["catch"](4);
              _iterator3.e(_context6.t0);
            case 17:
              _context6.prev = 17;
              _iterator3.f();
              return _context6.finish(17);
            case 20:
              return _context6.abrupt("return", txHashes);
            case 21:
            case "end":
              return _context6.stop();
          }
        }, _callee6, null, [[4, 14, 17, 20]]);
      }));
      function transferClaimedTokensFromIpToWallet(_x5) {
        return _transferClaimedTokensFromIpToWallet.apply(this, arguments);
      }
      return transferClaimedTokensFromIpToWallet;
    }()
  }]);
}();

var NftClient = /*#__PURE__*/function () {
  function NftClient(rpcClient, wallet) {
    _classCallCheck(this, NftClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.registrationWorkflowsClient = new RegistrationWorkflowsClient(rpcClient, wallet);
  }

  /**
   * Creates a new SPG NFT Collection.
   * @param request - The request object containing necessary data to create a SPG NFT Collection.
   *   @param request.name - The name of the collection.
   * 	 @param request.symbol - The symbol of the collection.
   * 	 @param request.isPublicMinting - If true, anyone can mint from the collection. If false, only the addresses with the minter role can mint.
   * 	 @param request.mintOpen Whether the collection is open for minting on creation.
   *   @param request.mintFeeRecipient - The address to receive mint fees.
   *   @param request.contractURI - The contract URI for the collection. Follows ERC-7572 standard. See https://eips.ethereum.org/EIPS/eip-7572
   * 	 @param request.baseURI - [Optional] The base URI for the collection. If baseURI is not empty, tokenURI will be either baseURI + token ID (if nftMetadataURI is empty) or baseURI + nftMetadataURI.
   * 	 @param request.maxSupply - [Optional] The maximum supply of the collection.
   * 	 @param request.mintFee - [Optional] The cost to mint a token.
   * 	 @param request.mintFeeToken - [Optional] The token to mint.
   * 	 @param request.owner - [Optional] The owner of the collection.
   *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes spg nft contract address.
   * @emits CollectionCreated (spgNftContract);
   */
  return _createClass(NftClient, [{
    key: "createNFTCollection",
    value: (function () {
      var _createNFTCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$baseURI, _request$maxSupply, _request$mintFee, _request$mintFeeToken, _request$txOptions, object, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              if (!(request.mintFee !== undefined && (request.mintFee < 0n || request.mintFeeToken === zeroAddress || !isAddress(request.mintFeeToken || "")))) {
                _context.next = 3;
                break;
              }
              throw new Error("Invalid mint fee token address, mint fee is greater than 0.");
            case 3:
              object = {
                spgNftInitParams: {
                  name: request.name,
                  symbol: request.symbol,
                  baseURI: (_request$baseURI = request.baseURI) !== null && _request$baseURI !== void 0 ? _request$baseURI : "",
                  maxSupply: (_request$maxSupply = request.maxSupply) !== null && _request$maxSupply !== void 0 ? _request$maxSupply : Number(maxUint32),
                  mintFee: (_request$mintFee = request.mintFee) !== null && _request$mintFee !== void 0 ? _request$mintFee : 0n,
                  mintFeeToken: (_request$mintFeeToken = request.mintFeeToken) !== null && _request$mintFeeToken !== void 0 ? _request$mintFeeToken : zeroAddress,
                  owner: request.owner && getAddress$1(request.owner, "request.owner") || this.wallet.account.address,
                  mintFeeRecipient: getAddress$1(request.mintFeeRecipient, "request.mintFeeRecipient"),
                  mintOpen: request.mintOpen,
                  isPublicMinting: request.isPublicMinting,
                  contractURI: request.contractURI
                }
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.registrationWorkflowsClient.createCollectionEncode(object)
              });
            case 8:
              _context.next = 10;
              return this.registrationWorkflowsClient.createCollection(object);
            case 10:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 17;
                break;
              }
              _context.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              txReceipt = _context.sent;
              targetLogs = this.registrationWorkflowsClient.parseTxCollectionCreatedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                spgNftContract: targetLogs[0].spgNftContract
              });
            case 17:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context.next = 23;
              break;
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to create a SPG NFT collection");
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 20]]);
      }));
      function createNFTCollection(_x) {
        return _createNFTCollection.apply(this, arguments);
      }
      return createNFTCollection;
    }())
  }]);
}();

var GroupClient = /*#__PURE__*/function () {
  function GroupClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, GroupClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.groupingWorkflowsClient = new GroupingWorkflowsClient(rpcClient, wallet);
    this.groupingModuleEventClient = new GroupingModuleEventClient(rpcClient);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseTokenReadOnlyClient = new LicenseTokenReadOnlyClient(rpcClient);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.groupingModuleClient = new GroupingModuleClient(rpcClient, wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(rpcClient, wallet);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
  }
  /** Registers a Group IPA.
   * @param request - The request object containing necessary data to register group.
   *   @param request.groupPool The address specifying how royalty will be split amongst the pool of IPs in the group.
   *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes group id.
   * @emits PGroupRegistered (groupId, groupPool);
   */
  return _createClass(GroupClient, [{
    key: "registerGroup",
    value: (function () {
      var _registerGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, object, _request$txOptions2, txHash, txReceipt, groupId;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              object = {
                groupPool: getAddress$1(request.groupPool, "request.groupPool")
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.groupingModuleClient.registerGroupEncode(object)
              });
            case 6:
              _context.next = 8;
              return this.groupingModuleClient.registerGroup(object);
            case 8:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 15;
                break;
              }
              _context.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              txReceipt = _context.sent;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context.abrupt("return", {
                txHash: txHash,
                groupId: groupId
              });
            case 15:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 16:
              _context.next = 21;
              break;
            case 18:
              _context.prev = 18;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register group");
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 18]]);
      }));
      function registerGroup(_x) {
        return _registerGroup.apply(this, arguments);
      }
      return registerGroup;
    }()
    /**  Mint an NFT from a SPGNFT collection, register it with metadata as an IP, attach license terms to the registered IP, and add it to a group IP.
     * @param request - The request object containing necessary data to mint and register Ip and attach license and add to group.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.groupId The ID of the group IP to add the newly registered IP.
     *   @param request.maxAllowedRewardShare The maximum reward share percentage that can be allocated to each member IP.
     *   @param {Array} request.licenseData licenseData The data of the license and its configuration to be attached to the new group IP.
     *      @param request.licenseData.licenseTermsId The ID of the registered license terms that will be attached to the new group IP.
     *      @param request.licenseData.licenseTemplate [Optional] The address of the license template to be attached to the new group IP, default value is Programmable IP License.
     *      @param request.licenseData.licensingConfig The licensing configuration for the IP.
     *     @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *       @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *       @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *       @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *       @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *       @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *       @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *       @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *       If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *       @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *   @param request.allowDuplicates Set to true to allow minting an NFT with a duplicate metadata hash.
     *   @param request.recipient [Optional] The address of the recipient of the minted NFT,default value is your wallet address.
     * . @param request.deadline [Optional] The deadline for the signature in seconds, default value is 1000s.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes IP ID, token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, resolverAddr, metadataProviderAddress, metadata)
     */
    )
  }, {
    key: "mintAndRegisterIpAndAttachLicenseAndAddToGroup",
    value: (function () {
      var _mintAndRegisterIpAndAttachLicenseAndAddToGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, groupId, recipient, spgNftContract, deadline, isRegistered, ipAccount, _yield$ipAccount$stat, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS, sigAddToGroupSignature, object, _request$txOptions4, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              groupId = request.groupId, recipient = request.recipient, spgNftContract = request.spgNftContract, deadline = request.deadline;
              _context2.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(groupId, "groupId")
              });
            case 4:
              isRegistered = _context2.sent;
              if (isRegistered) {
                _context2.next = 7;
                break;
              }
              throw new Error("Group IP ".concat(groupId, " is not registered."));
            case 7:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, groupId);
              _context2.next = 10;
              return ipAccount.state();
            case 10:
              _yield$ipAccount$stat = _context2.sent;
              state = _yield$ipAccount$stat.result;
              _context2.next = 14;
              return this.rpcClient.getBlock();
            case 14:
              blockTimestamp = _context2.sent.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context2.next = 18;
              return getPermissionSignature({
                ipId: groupId,
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: groupId,
                  signer: getAddress$1(this.groupingWorkflowsClient.address, "groupingWorkflowsClient"),
                  to: getAddress$1(this.groupingModuleClient.address, "groupingModuleClient"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(groupingModuleAbi, "addIp")
                }]
              });
            case 18:
              _yield$getPermissionS = _context2.sent;
              sigAddToGroupSignature = _yield$getPermissionS.signature;
              object = _objectSpread2(_objectSpread2({}, request), {}, {
                spgNftContract: getAddress$1(spgNftContract, "request.spgNftContract"),
                recipient: recipient && getAddress$1(recipient, "request.recipient") || this.wallet.account.address,
                maxAllowedRewardShare: BigInt(getRevenueShare(request.maxAllowedRewardShare)),
                licensesData: this.getLicenseData(request.licenseData),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigAddToGroup: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: sigAddToGroupSignature
                }
              });
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 25;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.groupingWorkflowsClient.mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode(object)
              });
            case 25:
              _context2.next = 27;
              return this.groupingWorkflowsClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup(object);
            case 27:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 34;
                break;
              }
              _context2.next = 31;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 31:
              receipt = _context2.sent;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context2.abrupt("return", {
                txHash: txHash,
                ipId: log.ipId,
                tokenId: log.tokenId
              });
            case 34:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 35:
              _context2.next = 40;
              break;
            case 37:
              _context2.prev = 37;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to mint and register IP and attach license and add to group");
            case 40:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 37]]);
      }));
      function mintAndRegisterIpAndAttachLicenseAndAddToGroup(_x2) {
        return _mintAndRegisterIpAndAttachLicenseAndAddToGroup.apply(this, arguments);
      }
      return mintAndRegisterIpAndAttachLicenseAndAddToGroup;
    }()
    /** Register an NFT as IP with metadata, attach license terms to the registered IP, and add it to a group IP.
     * @param request - The request object containing necessary data to register ip and attach license and add to group.
     *   @param request.spgNftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param request.maxAllowedRewardShare The maximum reward share percentage that can be allocated to each member IP.
     *   @param request.groupId The ID of the group IP to add the newly registered IP.
     *    @param {Array} request.licenseData licenseData The data of the license and its configuration to be attached to the new group IP.
     *      @param request.licenseData.licenseTermsId The ID of the registered license terms that will be attached to the new group IP.
     *      @param request.licenseData.licenseTemplate [Optional] The address of the license template to be attached to the new group IP, default value is Programmable IP License.
     *      @param request.licenseData.licensingConfig The licensing configuration for the IP.
     *      @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *        @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *        @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *        @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *        @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *        @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *        @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *        @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *        If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *        @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     * . @param request.deadline [Optional] The deadline for the signature in seconds, default is 1000s.
     *   @param {Object} request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *     @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *     @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *     @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *     @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.txOptions [Optional] This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes IP ID, token ID.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, resolverAddr, metadataProviderAddress, metadata)
     */
    )
  }, {
    key: "registerIpAndAttachLicenseAndAddToGroup",
    value: (function () {
      var _registerIpAndAttachLicenseAndAddToGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, _request$txOptions6, ipIdAddress, isRegistered, ipAccount, _yield$ipAccount$stat2, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS2, sigAddToGroupSignature, _yield$getPermissionS3, sigMetadataAndAttachSignature, object, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.ipAssetRegistryClient.ipId({
                chainId: BigInt(chain[this.chainId]),
                tokenContract: getAddress$1(request.nftContract, "nftContract"),
                tokenId: BigInt(request.tokenId)
              });
            case 3:
              ipIdAddress = _context3.sent;
              _context3.next = 6;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.groupId, "request.groupId")
              });
            case 6:
              isRegistered = _context3.sent;
              if (isRegistered) {
                _context3.next = 9;
                break;
              }
              throw new Error("Group IP ".concat(request.groupId, " is not registered."));
            case 9:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, request.groupId);
              _context3.next = 12;
              return ipAccount.state();
            case 12:
              _yield$ipAccount$stat2 = _context3.sent;
              state = _yield$ipAccount$stat2.result;
              _context3.next = 16;
              return this.rpcClient.getBlock();
            case 16:
              blockTimestamp = _context3.sent.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, request.deadline);
              _context3.next = 20;
              return getPermissionSignature({
                ipId: getAddress$1(request.groupId, "request.groupId"),
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: getAddress$1(request.groupId, "request.groupId"),
                  signer: this.groupingWorkflowsClient.address,
                  to: this.groupingModuleClient.address,
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(groupingModuleAbi, "addIp")
                }]
              });
            case 20:
              _yield$getPermissionS2 = _context3.sent;
              sigAddToGroupSignature = _yield$getPermissionS2.signature;
              _context3.next = 24;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }, {
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
                }, {
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
                }]
              });
            case 24:
              _yield$getPermissionS3 = _context3.sent;
              sigMetadataAndAttachSignature = _yield$getPermissionS3.signature;
              object = {
                nftContract: getAddress$1(request.nftContract, "request.nftContract"),
                groupId: request.groupId,
                licensesData: this.getLicenseData(request.licenseData),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                tokenId: BigInt(request.tokenId),
                maxAllowedRewardShare: BigInt(getRevenueShare(request.maxAllowedRewardShare)),
                sigAddToGroup: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: sigAddToGroupSignature
                },
                sigMetadataAndAttachAndConfig: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: sigMetadataAndAttachSignature
                }
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 29;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.groupingWorkflowsClient.registerIpAndAttachLicenseAndAddToGroupEncode(object)
              });
            case 29:
              _context3.next = 31;
              return this.groupingWorkflowsClient.registerIpAndAttachLicenseAndAddToGroup(object);
            case 31:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 38;
                break;
              }
              _context3.next = 35;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 35:
              receipt = _context3.sent;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context3.abrupt("return", {
                txHash: txHash,
                ipId: log.ipId,
                tokenId: log.tokenId
              });
            case 38:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 41:
              _context3.prev = 41;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to register IP and attach license and add to group");
            case 44:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 41]]);
      }));
      function registerIpAndAttachLicenseAndAddToGroup(_x3) {
        return _registerIpAndAttachLicenseAndAddToGroup.apply(this, arguments);
      }
      return registerIpAndAttachLicenseAndAddToGroup;
    }()
    /** Register a group IP with a group reward pool and attach license terms to the group IP.
     * @param request - The request object containing necessary data to register group and attach license.
     *   @param request.groupPool The address specifying how royalty will be split amongst the pool of IPs in the group.
     *    @param {Object} request.licenseData licenseData The data of the license and its configuration to be attached to the new group IP.
     *      @param request.licenseData.licenseTermsId The ID of the registered license terms that will be attached to the new group IP.
     *      @param request.licenseData.licenseTemplate [Optional] The address of the license template to be attached to the new group IP, default value is Programmable IP License.
     *      @param request.licenseData.licensingConfig The licensing configuration for the IP.
     *      @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *        @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *        @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *        @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *        @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *        @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *        @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *        @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *        If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *        @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *   @param request.txOptions [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes group id.
     * @emits PGroupRegistered (groupId, groupPool);
     */
    )
  }, {
    key: "registerGroupAndAttachLicense",
    value: (function () {
      var _registerGroupAndAttachLicense = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, _request$txOptions8, object, txHash, txReceipt, groupId;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              object = {
                groupPool: getAddress$1(request.groupPool, "request.groupPool"),
                licenseData: this.getLicenseData(request.licenseData)[0]
              };
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.groupingWorkflowsClient.registerGroupAndAttachLicenseEncode(object)
              });
            case 4:
              _context4.next = 6;
              return this.groupingWorkflowsClient.registerGroupAndAttachLicense(object);
            case 6:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 13;
                break;
              }
              _context4.next = 10;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 10:
              txReceipt = _context4.sent;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context4.abrupt("return", {
                txHash: txHash,
                groupId: groupId
              });
            case 13:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 16:
              _context4.prev = 16;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to register group and attach license");
            case 19:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 16]]);
      }));
      function registerGroupAndAttachLicense(_x4) {
        return _registerGroupAndAttachLicense.apply(this, arguments);
      }
      return registerGroupAndAttachLicense;
    }()
    /** Register a group IP with a group reward pool, attach license terms to the group IP, and add individual IPs to the group IP.
     * @param request - The request object containing necessary data to register group and attach license and add ips.
     *   @param request.ipIds The IP IDs of the IPs to be added to the group.
     *   @param request.groupPool The address specifying how royalty will be split amongst the pool of IPs in the group.
     *   @param request.maxAllowedRewardShare The maximum reward share percentage that can be allocated to each member IP.
     *   @param {Object} request.licenseData licenseData The data of the license and its configuration to be attached to the new group IP.
     *      @param request.licenseData.licenseTermsId The ID of the registered license terms that will be attached to the new group IP.
     *      @param request.licenseData.licenseTemplate [Optional] The address of the license template to be attached to the new group IP, default value is Programmable IP License.
     *      @param request.licenseData.licensingConfig The licensing configuration for the IP.
     *      @param {Object} request.licenseTermsData.licensingConfig The PIL terms and licensing configuration data to attach to the IP.
     *        @param request.licenseTermsData.licensingConfig.isSet Whether the configuration is set or not.
     *        @param request.licenseTermsData.licensingConfig.mintingFee The minting fee to be paid when minting license tokens.
     *        @param request.licenseTermsData.licensingConfig.licensingHook The hook contract address for the licensing module, or address(0) if none
     *        @param request.licenseTermsData.licensingConfig.hookData The data to be used by the licensing hook.
     *        @param request.licenseTermsData.licensingConfig.commercialRevShare The commercial revenue share percentage.
     *        @param request.licenseTermsData.licensingConfig.disabled Whether the licensing is disabled or not.
     *        @param request.licenseTermsData.licensingConfig.expectMinimumGroupRewardShare The minimum percentage of the group’s reward share (from 0 to 100%, represented as 100 * 10 ** 6) that can be allocated to the IP when it is added to the group.
     *        If the remaining reward share in the group is less than the minimumGroupRewardShare,the IP cannot be added to the group.
     *        @param request.licenseTermsData.licensingConfig.expectGroupRewardPool The address of the expected group reward pool. The IP can only be added to a group with this specified reward pool address, or address(0) if the IP does not want to be added to any group.
     *   @param request.txOptions [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a transaction hash, and if encodedTxDataOnly is true, includes encoded transaction data, and if waitForTransaction is true, includes group id.
     * @emits PGroupRegistered (groupId, groupPool);
     */
    )
  }, {
    key: "registerGroupAndAttachLicenseAndAddIps",
    value: (function () {
      var _registerGroupAndAttachLicenseAndAddIps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions9, _request$txOptions10, object, i, isRegistered, _i, isAttachedLicenseTerms, txHash, txReceipt, groupId;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              object = {
                groupPool: getAddress$1(request.groupPool, "request.groupPool"),
                ipIds: request.ipIds,
                licenseData: this.getLicenseData(request.licenseData)[0],
                maxAllowedRewardShare: BigInt(getRevenueShare(request.maxAllowedRewardShare))
              };
              i = 0;
            case 3:
              if (!(i < request.ipIds.length)) {
                _context5.next = 12;
                break;
              }
              _context5.next = 6;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.ipIds[i], "request.ipIds".concat(i))
              });
            case 6:
              isRegistered = _context5.sent;
              if (isRegistered) {
                _context5.next = 9;
                break;
              }
              throw new Error("IP ".concat(request.ipIds[i], " is not registered."));
            case 9:
              i++;
              _context5.next = 3;
              break;
            case 12:
              _i = 0;
            case 13:
              if (!(_i < request.ipIds.length)) {
                _context5.next = 22;
                break;
              }
              _context5.next = 16;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.ipIds[_i],
                licenseTemplate: object.licenseData.licenseTemplate,
                licenseTermsId: object.licenseData.licenseTermsId
              });
            case 16:
              isAttachedLicenseTerms = _context5.sent;
              if (isAttachedLicenseTerms) {
                _context5.next = 19;
                break;
              }
              throw new Error("License terms must be attached to IP ".concat(request.ipIds[_i], " before adding to group."));
            case 19:
              _i++;
              _context5.next = 13;
              break;
            case 22:
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 24;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: this.groupingWorkflowsClient.registerGroupAndAttachLicenseAndAddIpsEncode(object)
              });
            case 24:
              _context5.next = 26;
              return this.groupingWorkflowsClient.registerGroupAndAttachLicenseAndAddIps(object);
            case 26:
              txHash = _context5.sent;
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.waitForTransaction)) {
                _context5.next = 33;
                break;
              }
              _context5.next = 30;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 30:
              txReceipt = _context5.sent;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context5.abrupt("return", {
                txHash: txHash,
                groupId: groupId
              });
            case 33:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 36:
              _context5.prev = 36;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to register group and attach license and add ips");
            case 39:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 36]]);
      }));
      function registerGroupAndAttachLicenseAndAddIps(_x5) {
        return _registerGroupAndAttachLicenseAndAddIps.apply(this, arguments);
      }
      return registerGroupAndAttachLicenseAndAddIps;
    }())
  }, {
    key: "getLicenseData",
    value: function getLicenseData(licenseData) {
      var _this = this;
      var isArray = Array.isArray(licenseData);
      if (isArray && licenseData.length === 0 || !licenseData) {
        throw new Error("License data is required.");
      }
      var licenseDataArray = isArray ? licenseData : [licenseData];
      return licenseDataArray.map(function (item, index) {
        return {
          licenseTemplate: item.licenseTemplate && getAddress$1(item.licenseTemplate, "request.licenseData.licenseTemplate".concat(isArray ? "[".concat(index, "]") : "")) || _this.licenseTemplateClient.address,
          licenseTermsId: BigInt(item.licenseTermsId),
          licensingConfig: validateLicenseConfig(item.licensingConfig)
        };
      });
    }
  }]);
}();

var WipClient = /*#__PURE__*/function () {
  function WipClient(rpcClient, wallet) {
    _classCallCheck(this, WipClient);
    this.wipClient = new WrappedIpClient(rpcClient, wallet, WIP_TOKEN_ADDRESS);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }

  /**
   * Wraps the selected amount of IP to WIP.
   * The WIP will be deposited to the wallet that transferred the IP.
   */
  return _createClass(WipClient, [{
    key: "deposit",
    value: (function () {
      var _deposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
        var amount, txOptions, _yield$this$rpcClient, call, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              amount = _ref.amount, txOptions = _ref.txOptions;
              _context.prev = 1;
              if (!(amount <= 0)) {
                _context.next = 4;
                break;
              }
              throw new Error("WIP deposit amount must be greater than 0.");
            case 4:
              _context.next = 6;
              return this.rpcClient.simulateContract({
                abi: wrappedIpAbi,
                address: WIP_TOKEN_ADDRESS,
                functionName: "deposit",
                account: this.wallet.account,
                value: BigInt(amount)
              });
            case 6:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 10;
              return this.wallet.writeContract(call);
            case 10:
              txHash = _context.sent;
              return _context.abrupt("return", handleTxOptions({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](1);
              handleError(_context.t0, "Failed to deposit IP for WIP");
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 14]]);
      }));
      function deposit(_x) {
        return _deposit.apply(this, arguments);
      }
      return deposit;
    }()
    /**
     * Unwraps the selected amount of WIP to IP.
     */
    )
  }, {
    key: "withdraw",
    value: (function () {
      var _withdraw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {
        var amount, txOptions, targetAmt, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              amount = _ref2.amount, txOptions = _ref2.txOptions;
              _context2.prev = 1;
              targetAmt = BigInt(amount);
              if (!(targetAmt <= 0)) {
                _context2.next = 5;
                break;
              }
              throw new Error("WIP withdraw amount must be greater than 0.");
            case 5:
              _context2.next = 7;
              return this.wipClient.withdraw({
                value: targetAmt
              });
            case 7:
              txHash = _context2.sent;
              return _context2.abrupt("return", handleTxOptions({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 11:
              _context2.prev = 11;
              _context2.t0 = _context2["catch"](1);
              handleError(_context2.t0, "Failed to withdraw WIP");
            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[1, 11]]);
      }));
      function withdraw(_x2) {
        return _withdraw.apply(this, arguments);
      }
      return withdraw;
    }()
    /**
     * Approve a spender to use the wallet's WIP balance.
     */
    )
  }, {
    key: "approve",
    value: (function () {
      var _approve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(req) {
        var amount, spender, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              amount = BigInt(req.amount);
              if (!(amount <= 0)) {
                _context3.next = 4;
                break;
              }
              throw new Error("WIP approve amount must be greater than 0.");
            case 4:
              spender = validateAddress(req.spender);
              _context3.next = 7;
              return this.wipClient.approve({
                spender: spender,
                amount: amount
              });
            case 7:
              txHash = _context3.sent;
              return _context3.abrupt("return", handleTxOptions({
                txHash: txHash,
                txOptions: req.txOptions,
                rpcClient: this.rpcClient
              }));
            case 11:
              _context3.prev = 11;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to approve WIP");
            case 14:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 11]]);
      }));
      function approve(_x3) {
        return _approve.apply(this, arguments);
      }
      return approve;
    }()
    /**
     * Returns the balance of WIP for an address.
     */
    )
  }, {
    key: "balanceOf",
    value: (function () {
      var _balanceOf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(addr) {
        var owner, ret;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              owner = validateAddress(addr);
              _context4.next = 3;
              return this.wipClient.balanceOf({
                owner: owner
              });
            case 3:
              ret = _context4.sent;
              return _context4.abrupt("return", ret.result);
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function balanceOf(_x4) {
        return _balanceOf.apply(this, arguments);
      }
      return balanceOf;
    }())
  }]);
}();

if (typeof process !== "undefined") {
  dotenv.config();
}
/**
 * The StoryClient is the main entry point for the SDK.
 */
var StoryClient = /*#__PURE__*/function () {
  /**
   * @param config - the configuration for the SDK client
   */
  function StoryClient(config) {
    _classCallCheck(this, StoryClient);
    _defineProperty(this, "_ipAsset", null);
    _defineProperty(this, "_permission", null);
    _defineProperty(this, "_license", null);
    _defineProperty(this, "_dispute", null);
    _defineProperty(this, "_ipAccount", null);
    _defineProperty(this, "_royalty", null);
    _defineProperty(this, "_nftClient", null);
    _defineProperty(this, "_group", null);
    _defineProperty(this, "_wip", null);
    this.config = _objectSpread2(_objectSpread2({}, config), {}, {
      chainId: chain[config.chainId || "aeneid"]
    });
    if (!this.config.transport) {
      throw new Error("transport is null, please pass in a valid RPC Provider URL as the transport.");
    }
    var clientConfig = {
      chain: chainStringToViemChain(this.chainId),
      transport: this.config.transport
    };
    this.rpcClient = createPublicClient(clientConfig);
    if (this.config.wallet) {
      this.wallet = this.config.wallet;
    } else if (this.config.account) {
      var account = this.config.account;
      this.wallet = createWalletClient(_objectSpread2(_objectSpread2({}, clientConfig), {}, {
        account: account
      }));
    } else {
      throw new Error("must specify a wallet or account");
    }
  }
  return _createClass(StoryClient, [{
    key: "chainId",
    get: function get() {
      return this.config.chainId;
    }
    /**
     * Factory method for creating a SDK client with a signer.
     *
     * @param config StoryClient - the configuration for a new SDK client
     */
  }, {
    key: "ipAsset",
    get:
    /**
     * Getter for the ip asset client. The client is lazily created when
     * this method is called.
     *
     * @returns the IPAssetClient instance
     */
    function get() {
      if (this._ipAsset === null) {
        this._ipAsset = new IPAssetClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._ipAsset;
    }

    /**
     * Getter for the permission client. The client is lazily created when
     * this method is called.
     *
     * @returns the PermissionClient instance
     */
  }, {
    key: "permission",
    get: function get() {
      if (this._permission === null) {
        this._permission = new PermissionClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._permission;
    }

    /**
     * Getter for the license client. The client is lazily created when
     * this method is called.
     *
     * @returns the LicenseClient instance
     */
  }, {
    key: "license",
    get: function get() {
      if (this._license === null) {
        this._license = new LicenseClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._license;
    }

    /**
     * Getter for the dispute client. The client is lazily created when
     * this method is called.
     *
     * @returns the DisputeClient instance
     */
  }, {
    key: "dispute",
    get: function get() {
      if (this._dispute === null) {
        this._dispute = new DisputeClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._dispute;
    }

    /**
     * Getter for the ip account client. The client is lazily created when
     * this method is called.
     *
     * @returns the IPAccountClient instance
     */
  }, {
    key: "ipAccount",
    get: function get() {
      if (this._ipAccount === null) {
        this._ipAccount = new IPAccountClient(this.rpcClient, this.wallet);
      }
      return this._ipAccount;
    }

    /**
     * Getter for the royalty client. The client is lazily created when
     * this method is called.
     *
     * @returns the RoyaltyClient instance
     */
  }, {
    key: "royalty",
    get: function get() {
      if (this._royalty === null) {
        this._royalty = new RoyaltyClient(this.rpcClient, this.wallet);
      }
      return this._royalty;
    }

    /**
     * Getter for the NFT client. The client is lazily created when
     * this method is called.
     *
     * @returns the NftClient instance
     */
  }, {
    key: "nftClient",
    get: function get() {
      if (this._nftClient === null) {
        this._nftClient = new NftClient(this.rpcClient, this.wallet);
      }
      return this._nftClient;
    }

    /**
     * Getter for the group client. The client is lazily created when
     * this method is called.
     *
     * @returns the GroupClient instance
     */
  }, {
    key: "groupClient",
    get: function get() {
      if (this._group === null) {
        this._group = new GroupClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._group;
    }
  }, {
    key: "wipClient",
    get: function get() {
      if (this._wip === null) {
        this._wip = new WipClient(this.rpcClient, this.wallet);
      }
      return this._wip;
    }
  }, {
    key: "getWalletBalance",
    value: function () {
      var _getWalletBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.wallet.account) {
                _context.next = 2;
                break;
              }
              throw new Error("No account found in wallet");
            case 2:
              _context.next = 4;
              return this.getBalance(this.wallet.account.address);
            case 4:
              return _context.abrupt("return", _context.sent);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getWalletBalance() {
        return _getWalletBalance.apply(this, arguments);
      }
      return getWalletBalance;
    }()
  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address) {
        var validAddress;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              validAddress = validateAddress(address);
              _context2.next = 3;
              return this.rpcClient.getBalance({
                address: validAddress
              });
            case 3:
              return _context2.abrupt("return", _context2.sent);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getBalance(_x) {
        return _getBalance.apply(this, arguments);
      }
      return getBalance;
    }()
  }], [{
    key: "newClient",
    value: function newClient(config) {
      return new StoryClient(config);
    }

    /**
     * Factory method for creating a SDK client with a signer.
     *
     * @param config WalletClientConfig - the configuration for a new SDK client
     */
  }, {
    key: "newClientUseWallet",
    value: function newClientUseWallet(config) {
      return new StoryClient({
        chainId: config.chainId,
        transport: config.transport,
        wallet: config.wallet
      });
    }

    /**
     * Factory method for creating a SDK client with a signer.
     *
     * @param config UseAccountStoryConfig - the configuration for a new SDK client
     */
  }, {
    key: "newClientUseAccount",
    value: function newClientUseAccount(config) {
      return new StoryClient({
        account: config.account,
        chainId: config.chainId,
        transport: config.transport
      });
    }
  }]);
}();

export { AccessPermission, AddressZero, DisputeClient, GroupClient, HashZero, IPAccountClient, IPAssetClient, LicenseClient, NftClient, PIL_TYPE, PermissionClient, RoyaltyClient, StoryClient, WIP_TOKEN_ADDRESS, aeneid, convertCIDtoHashIPFS, convertHashIPFStoCID, getPermissionSignature, getSignature, mainnet };
